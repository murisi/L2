(ignore The constants to be used in x86-64-assembler.l2)

(function write-elf-sh-count (l r) [=# #7 r])

(function write-elf-alignment (l r) [=# #8 r])

(function write-elf-max-instr-len (l r) [=# #15 r])

(ignore A representation of an object code relocation.)

  (function relocation (l r) [=# #40 r])

  (function reloc-type (l r) [property #0 #8 (\ r (`(@ reloc-type reloc)r)) l r])

  (function reloc-operand (l r) [property #8 #8 (\ r (`(@ operand reloc)r)) l r])

  (function reloc-binding (l r) [property #16 #8 (\ r (`(@ bndg-aug reloc)r)) l r])
  
  (function reloc-context (l r) [property #24 #8 (\ r (`(@ (,[var r]) reloc)r)) l r])
  
  (ignore
    reloc-addend-func takes as its arguments context, operand location, operand size,
    instruction location, instruction size, and computes an addend for the relocation.)
    
  (function reloc-addend-func (l r)
    [property #32 #8 (\ r (with-vars (a b c d e f) (`(@ (function (,f ,b ,c ,d ,e) ,a) reloc)r)r)) l r])

(ignore A representation of an instruction.)

  (function instruction (l r) [=# #24 r])

  (function instr-code (l r) [property #0 #8 (\ r (`(@ instr-code instr)r)) l r])
  
  (function instr-operands (l r) [property #8 #8 (\ r (`(@ (list operand) instr)r)) l r])
  
  (function instr-binding (l r) [property #16 #8 (\ r (`(@ bndg-aug instr)r)) l r])

(ignore x86-64 instruction codes.)
  
  (function label (l r) [=## #33 (\ r (` instr-code r)) r])

  (function x86-lea (l r) [=## #17 (\ r (` instr-code r)) r])

  (function x86-mov (l r) [=## #18 (\ r (` instr-code r)) r])

  (function x86-jmp (l r) [=## #19 (\ r (` instr-code r)) r])
  
  (function x86-movzx (l r) [=## #20 (\ r (` instr-code r)) r])

  (function x86-push (l r) [=## #21 (\ r (` instr-code r)) r])

  (function x86-sub (l r) [=## #23 (\ r (` instr-code r)) r])

  (function x86-add (l r) [=## #24 (\ r (` instr-code r)) r])

  (function x86-pop (l r) [=## #25 (\ r (` instr-code r)) r])

  (function x86-leave (l r) [=## #26 (\ r (` instr-code r)) r])

  (function x86-ret (l r) [=## #27 (\ r (` instr-code r)) r])

  (function x86-je (l r) [=## #29 (\ r (` instr-code r)) r])

  (function x86-or (l r) [=## #30 (\ r (` instr-code r)) r])

  (function x86-call (l r) [=## #32 (\ r (` instr-code r)) r])
  
  (function x86-mul (l r) [=## #38 (\ r (` instr-code r)) r])
  
  (function x86-shl (l r) [=## #39 (\ r (` instr-code r)) r])
  
  (function x86-shr (l r) [=## #40 (\ r (` instr-code r)) r])
  
  (function x86-and (l r) [=## #41 (\ r (` instr-code r)) r])
  
  (function x86-not (l r) [=## #42 (\ r (` instr-code r)) r])
  
  (function x86-xor (l r) [=## #44 (\ r (` instr-code r)) r])
  
  (function x86-div (l r) [=## #47 (\ r (` instr-code r)) r])
  
  (function x86-setz (l r) [=## #48 (\ r (` instr-code r)) r])
  
  (function x86-setc (l r) [=## #49 (\ r (` instr-code r)) r])
  
  (function x86-setb (l r) [=## #49 (\ r (` instr-code r)) r])
  
  (function x86-nop (l r) [=## #50 (\ r (` instr-code r)) r])
  
  (function x86-cmp (l r) [=## #51 (\ r (` instr-code r)) r])
  
  (function x86-jnz (l r) [=## #52 (\ r (` instr-code r)) r])
  
  (function x86-jnc (l r) [=## #53 (\ r (` instr-code r)) r])
  
  (function x86-jae (l r) [=## #53 (\ r (` instr-code r)) r])
  
  (function x86-setg (l r) [=## #54 (\ r (` instr-code r)) r])
  
  (function x86-jle (l r) [=## #55 (\ r (` instr-code r)) r])

(ignore A representation of an operand.)
  
  (function operand (l r) [=# #64 r])
  
  (function op-type (l r) [property #0 #8 (\ r (`(@ operand-type operand)r)) l r])
  
  (function op-size (l r) [property #8 #8 (\ r (`(@ (,[var r]) operand)r)) l r])
  
  (function op-locations (l r) [property #16 #8 (\ r (with-vars (a b c d) (`(@ (list (values ,a ,b ,c ,d)) operand)r)r)) l r])

(ignore Only for type(s) (register-operand))

  (function op-register (l r) [property #24 #8 (\ r (`(@ register operand)r)) l r])

(ignore Only for type(s) (immediate-operand))

  (function op-immediate (l r) [property #24 #8 (\ r (`(@ (,[var r]) operand)r)) l r])

(ignore Only for type(s) (memory-operand))

  (function op-base (l r) [property #24 #8 (\ r (`(@ register operand)r)) l r])
  
  (function op-index (l r) [property #32 #8 (\ r (`(@ register operand)r)) l r])
  
  (function op-scale (l r) [property #40 #8 (\ r (`(@ (,[var r]) operand)r)) l r])
  
  (function op-disp (l r) [property #48 #8 (\ r (`(@ (,[var r]) operand)r)) l r])
  
  (function op-disp-size (l r) [property #56 #8 (\ r (`(@ (,[var r]) operand)r)) l r])

(ignore x86-64 operand types.)

  (function register-operand (l r) [=## #0 (\ r (` operand-type r)) r])
  
  (function immediate-operand (l r) [=## #1 (\ r (` operand-type r)) r])
  
  (function memory-operand (l r) [=## #2 (\ r (` operand-type r)) r])
  
  (function none-operand (l r) [=## #3 (\ r (` operand-type r)) r])

(ignore x86-64 registers.)
  
  (function r/m8 (l r) [=# [<< #1 #5] r])
  
  (function r/m16 (l r) [=# [<< #1 #6] r])
  
  (function r/m32 (l r) [=# [<< #1 #7] r])
  
  (function r/m64 (l r) [=# [<< #1 #8] r])
  
  (function w/rex (l r) [=# [<< #1 #9] r])
  
  (function w/orex (l r) [=# [<< #1 #10] r])
  
  (function none (l r) [=## #17 (\ r (` register r)) r])
  
  (function x86-/0 (l r) [=## [bor #0(r/m32)] (\ r (` register r)) r])

  (function x86-/1 (l r) [=## [bor #1(r/m32)] (\ r (` register r)) r])

  (function x86-/2 (l r) [=## [bor #2(r/m32)] (\ r (` register r)) r])

  (function x86-/3 (l r) [=## [bor #3(r/m32)] (\ r (` register r)) r])

  (function x86-/4 (l r) [=## [bor #4(r/m32)] (\ r (` register r)) r])

  (function x86-/5 (l r) [=## [bor #5(r/m32)] (\ r (` register r)) r])

  (function x86-/6 (l r) [=## [bor #6(r/m32)] (\ r (` register r)) r])

  (function x86-/7 (l r) [=## [bor #7(r/m32)] (\ r (` register r)) r])

  (function al (l r) [=## [bor #0(r/m8)] (\ r (` register r)) r])

  (function cl (l r) [=## [bor #1(r/m8)] (\ r (` register r)) r])

  (function dl (l r) [=## [bor #2(r/m8)] (\ r (` register r)) r])

  (function bl (l r) [=## [bor #3(r/m8)] (\ r (` register r)) r])

  (function ah (l r) [=## [bor #4(r/m8)] (\ r (` register r)) r])

  (function ch (l r) [=## [bor #5(r/m8)] (\ r (` register r)) r])

  (function dh (l r) [=## [bor #6(r/m8)] (\ r (` register r)) r])

  (function bh (l r) [=## [bor #7(r/m8)] (\ r (` register r)) r])
  
  (function spl (l r) [=## [bor [bor #4(r/m8)] (w/rex)] (\ r (` register r)) r])

  (function bpl (l r) [=## [bor [bor #5(r/m8)] (w/rex)] (\ r (` register r)) r])

  (function sil (l r) [=## [bor [bor #6(r/m8)] (w/rex)] (\ r (` register r)) r])

  (function dil (l r) [=## [bor [bor #7(r/m8)] (w/rex)] (\ r (` register r)) r])

  (function r8l (l r) [=## [bor [bor #8(r/m8)] (w/rex)] (\ r (` register r)) r])

  (function r9l (l r) [=## [bor [bor #9(r/m8)] (w/rex)] (\ r (` register r)) r])

  (function r10l (l r) [=## [bor [bor #10(r/m8)] (w/rex)] (\ r (` register r)) r])

  (function r11l (l r) [=## [bor [bor #11(r/m8)] (w/rex)] (\ r (` register r)) r])

  (function r12l (l r) [=## [bor [bor #12(r/m8)] (w/rex)] (\ r (` register r)) r])

  (function r13l (l r) [=## [bor [bor #13(r/m8)] (w/rex)] (\ r (` register r)) r])

  (function r14l (l r) [=## [bor [bor #14(r/m8)] (w/rex)] (\ r (` register r)) r])

  (function r15l (l r) [=## [bor [bor #15(r/m8)] (w/rex)] (\ r (` register r)) r])
  
  (function ax (l r) [=## [bor #0(r/m16)] (\ r (` register r)) r])

  (function cx (l r) [=## [bor #1(r/m16)] (\ r (` register r)) r])

  (function dx (l r) [=## [bor #2(r/m16)] (\ r (` register r)) r])

  (function bx (l r) [=## [bor #3(r/m16)] (\ r (` register r)) r])

  (function sp (l r) [=## [bor #4(r/m16)] (\ r (` register r)) r])

  (function bp (l r) [=## [bor #5(r/m16)] (\ r (` register r)) r])

  (function si (l r) [=## [bor #6(r/m16)] (\ r (` register r)) r])

  (function di (l r) [=## [bor #7(r/m16)] (\ r (` register r)) r])
  
  (function r8w (l r) [=## [bor [bor #8(r/m16)] (w/rex)] (\ r (` register r)) r])

  (function r9w (l r) [=## [bor [bor #9(r/m16)] (w/rex)] (\ r (` register r)) r])

  (function r10w (l r) [=## [bor [bor #10(r/m16)] (w/rex)] (\ r (` register r)) r])

  (function r11w (l r) [=## [bor [bor #11(r/m16)] (w/rex)] (\ r (` register r)) r])

  (function r12w (l r) [=## [bor [bor #12(r/m16)] (w/rex)] (\ r (` register r)) r])

  (function r13w (l r) [=## [bor [bor #13(r/m16)] (w/rex)] (\ r (` register r)) r])

  (function r14w (l r) [=## [bor [bor #14(r/m16)] (w/rex)] (\ r (` register r)) r])

  (function r15w (l r) [=## [bor [bor #15(r/m16)] (w/rex)] (\ r (` register r)) r])
  
  (function eax (l r) [=## [bor #0(r/m32)] (\ r (` register r)) r])

  (function ecx (l r) [=## [bor #1(r/m32)] (\ r (` register r)) r])

  (function edx (l r) [=## [bor #2(r/m32)] (\ r (` register r)) r])

  (function ebx (l r) [=## [bor #3(r/m32)] (\ r (` register r)) r])

  (function esp (l r) [=## [bor #4(r/m32)] (\ r (` register r)) r])

  (function ebp (l r) [=## [bor #5(r/m32)] (\ r (` register r)) r])

  (function esi (l r) [=## [bor #6(r/m32)] (\ r (` register r)) r])

  (function edi (l r) [=## [bor #7(r/m32)] (\ r (` register r)) r])
  
  (function r8d (l r) [=## [bor [bor #8(r/m32)] (w/rex)] (\ r (` register r)) r])

  (function r9d (l r) [=## [bor [bor #9(r/m32)] (w/rex)] (\ r (` register r)) r])

  (function r10d (l r) [=## [bor [bor #10(r/m32)] (w/rex)] (\ r (` register r)) r])

  (function r11d (l r) [=## [bor [bor #11(r/m32)] (w/rex)] (\ r (` register r)) r])

  (function r12d (l r) [=## [bor [bor #12(r/m32)] (w/rex)] (\ r (` register r)) r])

  (function r13d (l r) [=## [bor [bor #13(r/m32)] (w/rex)] (\ r (` register r)) r])

  (function r14d (l r) [=## [bor [bor #14(r/m32)] (w/rex)] (\ r (` register r)) r])

  (function r15d (l r) [=## [bor [bor #15(r/m32)] (w/rex)] (\ r (` register r)) r])
  
  (function rax (l r) [=## [bor [bor #0(r/m64)] (w/rex)] (\ r (` register r)) r])

  (function rcx (l r) [=## [bor [bor #1(r/m64)] (w/rex)] (\ r (` register r)) r])

  (function rdx (l r) [=## [bor [bor #2(r/m64)] (w/rex)] (\ r (` register r)) r])

  (function rbx (l r) [=## [bor [bor #3(r/m64)] (w/rex)] (\ r (` register r)) r])

  (function rsp (l r) [=## [bor [bor #4(r/m64)] (w/rex)] (\ r (` register r)) r])

  (function rbp (l r) [=## [bor [bor #5(r/m64)] (w/rex)] (\ r (` register r)) r])

  (function rsi (l r) [=## [bor [bor #6(r/m64)] (w/rex)] (\ r (` register r)) r])

  (function rdi (l r) [=## [bor [bor #7(r/m64)] (w/rex)] (\ r (` register r)) r])

  (function r8 (l r) [=## [bor [bor #8(r/m64)] (w/rex)] (\ r (` register r)) r])

  (function r9 (l r) [=## [bor [bor #9(r/m64)] (w/rex)] (\ r (` register r)) r])

  (function r10 (l r) [=## [bor [bor #10(r/m64)] (w/rex)] (\ r (` register r)) r])

  (function r11 (l r) [=## [bor [bor #11(r/m64)] (w/rex)] (\ r (` register r)) r])

  (function r12 (l r) [=## [bor [bor #12(r/m64)] (w/rex)] (\ r (` register r)) r])

  (function r13 (l r) [=## [bor [bor #13(r/m64)] (w/rex)] (\ r (` register r)) r])

  (function r14 (l r) [=## [bor [bor #14(r/m64)] (w/rex)] (\ r (` register r)) r])

  (function r15 (l r) [=## [bor [bor #15(r/m64)] (w/rex)] (\ r (` register r)) r])
  
  (function rip (l r) [=## [bor [bor #16(r/m64)] (w/rex)] (\ r (` register r)) r])

(ignore Defined to enable the x64 registers to be indexed dynamically.)

(storage x64-r64s
  (rax)(rcx)(rdx)(rbx)(rsp)(rbp)(rsi)(rdi)(r8)(r9)(r10)(r11)(r12)(r13)(r14)(r15))

(ignore Usage (make-instrN opcode (ops ...) buf handler))

(function make-instrN (l r)
  [llllst (` invoke r) (` make-instruction r) [@fst l] [list [lst [@frst l] [@rrst l] r] r] [@rrst l] r])

(constrain make-instruction (\ r (with-vars (b) (`(function (instr-code (list operand) buffer ,b) instr)r)r)))

(function make-instruction (code operands reg handler)
  (let (u [buffer-alloc (instruction) reg handler]) (do
    (setf instr-code u code)
    (setf instr-operands u operands)
    (setf instr-binding u null-binding)
    u)))

(constrain make-relocation (\ r (with-vars (a b c) (`(function (reloc-type operand bndg-aug ,c ,a buffer ,b) reloc)r)r)))

(function make-relocation (type operand binding ctx addend-func buf handler)
  (substitute (.. buf handler)
    (let (r [buffer-alloc (relocation) ..]) (do
      (setf reloc-type r type)
      (setf reloc-operand r operand)
      (setf reloc-binding r binding)
      (setf reloc-context r ctx)
      (setf reloc-addend-func r addend-func)
      r))))

(constrain register-size (\ r (with-vars (a) (`(function (register) ,a)r)r)))

(function register-size (reg)
  (if [band reg(r/m8)] #1
  (if [band reg(r/m16)] #2
  (if [band reg(r/m32)] #4
  (if [band reg(r/m64)] #8
    (ignore))))))

(constrain make-reg-op (\ r (with-vars (a) (`(function (register buffer ,a) operand)r)r)))

(function make-reg-op (reg buf handler)
  (substitute (.. buf handler)
    (let (op [buffer-alloc (operand) ..]) (do
      (setf op-type op (register-operand))
      (setf op-size op [register-size reg])
      (setf op-register op reg)
      (setf op-locations op nil)
      op))))

(constrain make-imm-op (\ r (with-vars (a b c) (`(function (,b ,c buffer ,a) operand)r)r)))

(function make-imm-op (op-size imm buf handler)
  (substitute (.. buf handler)
    (let (op [buffer-alloc (operand) ..]) (do
      (setf op-type op (immediate-operand))
      (setf op-size op op-size)
      (setf op-immediate op imm)
      (setf op-locations op nil)
      op))))

(constrain make-none-op (\ r (with-vars (a) (`(function (buffer ,a) operand)r)r)))

(function make-none-op (buf handler)
  (substitute (.. buf handler)
    (let (op [buffer-alloc (operand) ..]) (do
      (setf op-type op (none-operand))
      (setf op-size op #0)
      op))))

(constrain make-mem-op (\ r (with-vars (a b c d e) (`(function (,a register register ,b ,c ,d buffer ,e) operand)r)r)))

(function make-mem-op (op-size base index scale disp disp-size buf handler)
  (substitute (.. buf handler)
    (let (op [buffer-alloc (operand) ..]) (do
      (setf op-type op (memory-operand))
      (setf op-size op op-size)
      (setf op-base op base)
      (setf op-index op index)
      (setf op-scale op scale)
      (setf op-disp op disp)
      (setf op-disp-size op disp-size)
      (setf op-locations op nil)
      op))))

(constrain reg-lower-8 (\ r (`(function (register) register)r)))

(function reg-lower-8 (reg) (switch = reg
  ((ah)(ah)) ((bh)(bh)) ((ch)(ch)) ((dh)(dh)) ((al)(al)) ((bl)(bl)) ((cl)(cl)) ((dl)(dl))
  ((dil)(dil)) ((sil)(sil)) ((bpl) (bpl)) ((spl)(spl)) ((r8l)(r8l)) ((r9l)(r9l)) ((r10l)(r10l))
  ((r11l)(r11l)) ((r12l)(r12l)) ((r13l)(r13l)) ((r14l)(r14l)) ((r15l)(r15l)) ((ax)(al))
  ((bx)(bl)) ((cx)(cl)) ((dx)(dl)) ((di)(dil)) ((si)(sil)) ((bp)(bpl)) ((sp)(spl)) ((r8w)(r8l))
  ((r9w)(r9l)) ((r10w)(r10l)) ((r11w)(r11l)) ((r12w)(r12l)) ((r13w)(r13l)) ((r14w)(r14l))
  ((r15w)(r15l)) ((eax)(al)) ((ebx)(bl)) ((ecx)(cl)) ((edx)(dl)) ((edi)(dl)) ((esi)(sil))
  ((ebp)(bpl)) ((esp)(spl)) ((r8d)(r8l)) ((r9d)(r9l)) ((r10d)(r10l)) ((r11d)(r11l))
  ((r12d)(r12l)) ((r13d)(r13l)) ((r14d)(r14l)) ((r15d)(r15l)) ((rax)(al)) ((rbx)(bl))
  ((rcx)(cl)) ((rdx)(dl)) ((rdi)(dil)) ((rsi)(sil)) ((rbp)(bpl)) ((rsp)(spl)) ((r8)(r8l))
  ((r9)(r9l)) ((r10)(r10l)) ((r11)(r11l)) ((r12)(r12l)) ((r13)(r13l)) ((r14)(r14l))
  ((r15)(r15l)) (ignore)))

(constrain op-lower-8 (\ r (with-vars (a) (`(function (operand buffer ,a) operand)r)r)))

(function op-lower-8 (op buf handler)
  (substitute (.. buf handler)
    (switch = (@ op-type op)
      ((register-operand) [make-reg-op [reg-lower-8 (@ op-register op)] ..])
      ((immediate-operand) [make-imm-op #1 (@ op-immediate op) ..])
      ((memory-operand) [make-mem-op #1 (@ op-base op) (@ op-index op) (@ op-scale op)
        (@ op-disp op) (@ op-disp-size op) ..])
      (ignore))))

(constrain reg-lower-16 (\ r (`(function (register) register)r)))

(function reg-lower-16 (reg) (switch = reg
  ((ax)(ax)) ((bx)(bx)) ((cx)(cx)) ((dx)(dx)) ((di)(di)) ((si)(si)) ((bp)(bp)) ((sp)(sp))
  ((r8w)(r8w)) ((r9w)(r9w)) ((r10w)(r10w)) ((r11w)(r11w)) ((r12w)(r12w)) ((r13w)(r13w))
  ((r14w)(r14w)) ((r15w)(r15w)) ((eax)(ax)) ((ebx)(bx)) ((ecx)(cx)) ((edx)(dx)) ((edi)(di))
  ((esi)(si)) ((ebp)(bp)) ((esp)(sp)) ((r8d)(r8w)) ((r9d)(r9w)) ((r10d)(r10w)) ((r11d)(r11w))
  ((r12d)(r12w)) ((r13d)(r13w)) ((r14d)(r14w)) ((r15d)(r15w)) ((rax)(ax)) ((rbx)(bx))
  ((rcx)(cx)) ((rdx)(dx)) ((rdi)(di)) ((rsi)(si)) ((rbp)(bp)) ((rsp)(sp)) ((r8)(r8w))
  ((r9)(r9w)) ((r10)(r10w)) ((r11)(r11w)) ((r12)(r12w)) ((r13)(r13w)) ((r14)(r14w))
  ((r15)(r15w)) (ignore)))

(constrain op-lower-16 (\ r (with-vars (a) (`(function (operand buffer ,a) operand)r)r)))

(function op-lower-16 (op buf handler)
  (substitute (.. buf handler)
    (switch = (@ op-type op)
      ((register-operand) [make-reg-op [reg-lower-16 (@ op-register op)] ..])
      ((immediate-operand) [make-imm-op #2 (@ op-immediate op) ..])
      ((memory-operand) [make-mem-op #2 (@ op-base op) (@ op-index op) (@ op-scale op)
        (@ op-disp op) (@ op-disp-size op) ..])
      (ignore))))

(constrain reg-lower-32 (\ r (`(function (register) register)r)))

(function reg-lower-32 (reg) (switch = reg
  ((eax)(eax)) ((ebx)(ebx)) ((ecx)(ecx)) ((edx)(edx)) ((edi)(edi)) ((esi)(esi)) ((ebp)(ebp))
  ((esp)(esp)) ((r8d)(r8d)) ((r9d)(r9d)) ((r10d)(r10d)) ((r11d)(r11d)) ((r12d)(r12d))
  ((r13d)(r13d)) ((r14d)(r14d)) ((r15d)(r15d)) ((rax)(eax)) ((rbx)(ebx)) ((rcx)(ecx))
  ((rdx)(edx)) ((rdi)(edi)) ((rsi)(esi)) ((rbp)(ebp)) ((rsp)(esp)) ((r8)(r8d)) ((r9)(r9d))
  ((r10)(r10d)) ((r11)(r11d)) ((r12)(r12d)) ((r13)(r13d)) ((r14)(r14d)) ((r15)(r15d))
  (ignore)))

(constrain op-lower-32 (\ r (with-vars (a) (`(function (operand buffer ,a) operand)r)r)))

(function op-lower-32 (op buf handler)
  (substitute (.. buf handler)
    (switch = (@ op-type op)
      ((register-operand) [make-reg-op [reg-lower-32 (@ op-register op)] ..])
      ((immediate-operand) [make-imm-op #4 (@ op-immediate op) ..])
      ((memory-operand) [make-mem-op #4 (@ op-base op) (@ op-index op) (@ op-scale op)
        (@ op-disp op) (@ op-disp-size op) ..])
      (ignore))))

(constrain reg-lower-64 (\ r (`(function (register) register)r)))

(function reg-lower-64 (reg) (switch = reg
  ((rax)(rax)) ((rbx)(rbx)) ((rcx)(rcx)) ((rdx)(rdx)) ((rdi)(rdi)) ((rsi)(rsi)) ((rbp)(rbp))
  ((rsp)(rsp)) ((r8)(r8)) ((r9)(r9)) ((r10)(r10)) ((r11)(r11)) ((r12)(r12)) ((r13)(r13))
  ((r14)(r14)) ((r15)(r15)) (ignore)))

(constrain op-lower-64 (\ r (with-vars (a) (`(function (operand buffer ,a) operand)r)r)))

(function op-lower-64 (op buf handler)
  (substitute (.. buf handler)
    (switch = (@ op-type op)
      ((register-operand) [make-reg-op [reg-lower-64 (@ op-register op)] ..])
      ((immediate-operand) [make-imm-op #8 (@ op-immediate op) ..])
      ((memory-operand) [make-mem-op #8 (@ op-base op) (@ op-index op) (@ op-scale op)
        (@ op-disp op) (@ op-disp-size op) ..])
      (ignore))))

(constrain print-instr-code (\ r (with-vars (a) (`(function (instr-code ,a) ())r)r)))

(function print-instr-code (code handler)
  [print-str (stdout) (switch = code
    ((label) (" label)) ((x86-lea) (" lea)) ((x86-mov) (" mov)) ((x86-jmp) (" jmp))
    ((x86-movzx) (" movzx)) ((x86-push) (" push)) ((x86-sub) (" sub)) ((x86-add) (" add))
    ((x86-pop) (" pop)) ((x86-leave) (" leave)) ((x86-ret) (" ret)) ((x86-je) (" je))
    ((x86-or) (" or)) ((x86-call) (" call)) ((x86-mul) (" mul)) ((x86-shl) (" shl))
    ((x86-shr) (" shr)) ((x86-and) (" and)) ((x86-not) (" not)) ((x86-xor) (" xor))
    ((x86-div) (" div)) ((x86-setz) (" setz)) ((x86-setc) (" setc)) ((x86-jnc) (" jnc))
    ((x86-jnz) (" jnz)) ((x86-cmp) (" cmp)) ((x86-setg) (" setg)) ((x86-jle) (" jle))
    (ignore)) handler])

(constrain print-register (\ r (with-vars (a) (`(function (register ,a) ())r)r)))

(function print-register (reg handler)
  [print-str (stdout) (switch = reg
    ((none)(" (lparen)none(rparen))) ((al)(" al)) ((cl)(" cl)) ((dl)(" dl)) ((bl)(" bl))
    ((ah)(" ah)) ((ch)(" ch)) ((dh)(" dh)) ((bh)(" bh)) ((spl)(" spl)) ((bpl)(" bpl))
    ((sil)(" sil)) ((dil)(" dil)) ((r8l)(" r8l)) ((r9l)(" r9l)) ((r10l)(" r10l))
    ((r11l)(" r11l)) ((r12l)(" r12l)) ((r13l)(" r13l)) ((r14l)(" r14l)) ((r15l)(" r15l))  
    ((ax)(" ax)) ((cx)(" cx)) ((dx)(" dx)) ((bx)(" bx)) ((sp)(" sp)) ((bp)(" bp))
    ((si)(" si)) ((di)(" di)) ((r8w)(" r8w)) ((r9w)(" r9w)) ((r10w)(" r10w)) ((r11w)(" r11w))
    ((r12w)(" r12w)) ((r13w)(" r13w)) ((r14w)(" r14w)) ((r15w)(" r15w)) ((eax)(" eax))
    ((ecx)(" ecx)) ((edx)(" edx)) ((ebx)(" ebx)) ((esp)(" esp)) ((ebp)(" ebp))
    ((esi)(" esi)) ((edi)(" edi)) ((r8d)(" r8d)) ((r9d)(" r9d)) ((r10d)(" r10d))
    ((r11d)(" r11d)) ((r12d)(" r12d)) ((r13d)(" r13d)) ((r14d)(" r14d)) ((r15d)(" r15d))  
    ((rax)(" rax)) ((rcx)(" rcx)) ((rdx)(" rdx)) ((rbx)(" rbx)) ((rsp)(" rsp))
    ((rbp)(" rbp)) ((rsi)(" rsi)) ((rdi)(" rdi)) ((r8)(" r8)) ((r9)(" r9)) ((r10)(" r10))
    ((r11)(" r11)) ((r12)(" r12)) ((r13)(" r13)) ((r14)(" r14)) ((r15)(" r15))  
    ((rip)(" rip)) (ignore)) handler])

(constrain print-operand (\ r (with-vars (a) (`(function (operand ,a) ())r)r)))

(function print-operand (op handler)
  (switch = (@ op-type op)
    ((register-operand)
      [print-register (@ op-register op) handler])
    ((immediate-operand)
      [print-uint (stdout) (@ op-immediate op) handler])
    ((memory-operand) (do
      [print-char (stdout) (lbracket) handler]
      (if [not= (@ op-base op) (none)]
        [print-register (@ op-base op) handler]
        (ignore))
      (if (and [not= (@ op-base op) (none)] [not= (@ op-index op) (none)])
        [print-str (stdout) ("(space)+(space)) handler]
        (ignore))
      (if [not= (@ op-index op) (none)] (do
        [print-register (@ op-index op) handler]
        [print-str (stdout) (" *) handler]
        [print-uint (stdout) (@ op-scale op) handler])
        (ignore))
      (if (and (or [not= (@ op-base op) (none)] [not= (@ op-index op) (none)])
          [not= (@ op-disp-size op) #0])
        [print-str (stdout) ("(space)+(space)) handler]
        (ignore))
      (if [not= (@ op-disp-size op) #0]
        [print-uint (stdout) (@ op-disp op) handler]
        (ignore))
      [print-char (stdout) (rbracket) handler]))
    ((none-operand)
      [print-str (stdout) ("(lparen)none(rparen)) handler])
    (ignore)))

(constrain print-instr (\ r (with-vars (a) (`(function (instr ,a) ())r)r)))

(function print-instr (instr handler) (do
  [print-instr-code (@ instr-code instr) handler]
  (if [nil? (@ instr-operands instr)] (ignore) (do
    [print-str (stdout) ("(space)) handler]
    [print-operand [@car (@ instr-operands instr)] handler]
    (foreach (op [@cdr (@ instr-operands instr)]) (do
      [print-str (stdout) (" ,(space)) handler]
      [print-operand op handler]))))))

(constrain mem-write (\ r (with-vars (a b c d) (`(function (,a (ref ,b) ,c ,d) ())r)r)))

(function mem-write (mem idx bytes cnt)
  (let (end [+ $idx cnt])
  (loop write-bytes (bytes bytes)
    (if [= $idx end] (ignore) (do
      [setb [+ mem $idx] [getb bytes]]
      [set+ idx #1]
      {write-bytes [+ bytes #1]})))))

(constrain write-instr
  (\ r (with-vars (a b c d e f) (`(function (,a (ref ,b) ,c ,d operand operand operand operand buffer ,f) ,e)r)r)))

(function write-instr (bin pos opcode opcode-size opcode.reg-op modrm.reg-op modrm.rm-op imm-op buf handler)
  (substitute (.. buf handler)
    (let (modrm.rm-op-code [band
      (if [= (@ op-type modrm.rm-op) (register-operand)] (@ op-register modrm.rm-op)
      (if [= (@ op-type modrm.rm-op) (memory-operand)] (@ op-base modrm.rm-op) (ignore))) #7])
    
    (let (modrm.reg-op-code [band (@ op-register modrm.reg-op) #7])
    
    (let (opcode [+ opcode
      (if [= (@ op-type opcode.reg-op) (register-operand)] [band (@ op-register opcode.reg-op) #7] #0)])
    
    (let (has-modrm? (or [not= (@ op-type modrm.reg-op) (none-operand)] [not= (@ op-type modrm.rm-op) (none-operand)]))
    
    (let (modrm.mod
      (if [= (@ op-type modrm.rm-op) (register-operand)] #3
      (if (or [= (@ op-disp-size modrm.rm-op) #0] [= (@ op-base modrm.rm-op) (none)] [= (@ op-base modrm.rm-op) (rip)]) #0
      (if [= (@ op-disp-size modrm.rm-op) #1] #1
      (if [= (@ op-disp-size modrm.rm-op) #4] #2 (ignore))))))
    
    (let (has-sib? (and [= (@ op-type modrm.rm-op) (memory-operand)]
      (or [not= (@ op-index modrm.rm-op) (none)] [= modrm.rm-op-code [band (rsp) #7]]
        (and [= modrm.rm-op-code [band (rbp) #7]] [= (@ op-disp-size modrm.rm-op) #0]))))
    
    (let (modrm.rm
      (if [= (@ op-type modrm.rm-op) (register-operand)] modrm.rm-op-code
      (if has-sib? #4
      (if [= (@ op-base modrm.rm-op) (none)] #5
      (if [= (@ op-base modrm.rm-op) (rip)] #5
        modrm.rm-op-code)))))
    
    (let (modrm.reg modrm.reg-op-code)
            
    (let (sib.scale (switch = (@ op-scale modrm.rm-op) (#1 #0) (#2 #1) (#4 #2) (#8 #3) (ignore)))
    
    (let (sib.index (if [= (@ op-index modrm.rm-op) (none)] #4 (@ op-index modrm.rm-op)))
    
    (let (sib.base (if (or [= (@ op-base modrm.rm-op) (none)]) #5 modrm.rm-op-code))
    
    (let (has-rex? (or [band [bor (@ op-register modrm.reg-op) [bor (@ op-register modrm.rm-op) (@ op-register opcode.reg-op)]] (w/rex)]
      (and [= (@ op-type modrm.rm-op) (memory-operand)] (or
        (and [not= (@ op-base modrm.rm-op) (none)] [= [register-size (@ op-base modrm.rm-op)] #8])
        (and [not= (@ op-index modrm.rm-op) (none)] [= [register-size (@ op-index modrm.rm-op)] #8])
        [= (@ op-disp-size modrm.rm-op) #8]))))
    
    (let (rex.w (if (or [= (@ op-size modrm.reg-op) #8] [= (@ op-size modrm.rm-op) #8] [= (@ op-size opcode.reg-op) #8]) #1 #0))
    
    (let (rex.r (if (and [= (@ op-type modrm.reg-op) (register-operand)] [band (@ op-register modrm.reg-op) #8]) #1 #0))
    
    (let (rex.x (if (and [= (@ op-type modrm.rm-op) (memory-operand)] [not= (@ op-index modrm.rm-op) (none)]
      [band (@ op-index modrm.rm-op) #8]) #1 #0))
    
    (let (rex.b (if (or (and [= (@ op-type modrm.rm-op) (memory-operand)] [not= (@ op-base modrm.rm-op) (none)]
      [band (@ op-base modrm.rm-op) #8]) (and [= (@ op-type modrm.rm-op) (register-operand)] [not= (@ op-register modrm.rm-op) (none)]
      [band (@ op-register modrm.rm-op) #8]) (and [= (@ op-type opcode.reg-op) (register-operand)]
      [not= (@ op-register opcode.reg-op) (none)] [band (@ op-register opcode.reg-op) #8])) #1 #0))
    
    (let (has-oso? [= [max (@ op-size modrm.reg-op) (@ op-size modrm.rm-op)] #2])
    
    (let (has-aso? (and [= (@ op-type modrm.rm-op) (memory-operand)] (or
        (and [not= (@ op-base modrm.rm-op) (none)] [= [register-size (@ op-base modrm.rm-op)] #2])
        (and [not= (@ op-index modrm.rm-op) (none)] [= [register-size (@ op-index modrm.rm-op)] #2])
        [= (@ op-disp-size modrm.rm-op) #2])))
    
    (let (instr-start-pos $pos) (do
    
    (if has-oso? [mem-write bin pos (storage _ (hex 66)) #1] (ignore))
    
    (if has-aso? [mem-write bin pos (storage _ (hex 67)) #1] (ignore))
    
    (if has-rex?
      [mem-write bin pos (storage _
        [bor [<< #4 #4]
        [bor [<< rex.w #3]
        [bor [<< rex.r #2]
        [bor [<< rex.x #1]
        [bor [<< rex.b #0]
          #0]]]]]) #1] (ignore))
          
    [mem-write bin pos (storage _ opcode) opcode-size]
    
    (if has-modrm? (do
      [mem-write bin pos (storage _
        [bor [<< modrm.mod #6]
        [bor [<< modrm.reg #3]
        [bor [<< modrm.rm #0]
          #0]]]) #1]
      
      (if has-sib?
        [mem-write bin pos (storage _
          [bor [<< sib.scale #6]
          [bor [<< sib.index #3]
          [bor [<< sib.base #0]
            #0]]]) #1] (ignore)))
            
      (ignore))
    
    (let (disp-pos $pos) (do
    
    (if [= (@ op-type modrm.rm-op) (memory-operand)]
      [mem-write bin pos (storage _ (@ op-disp modrm.rm-op)) (@ op-disp-size modrm.rm-op)]
      (ignore))
    
    (let (imm-pos $pos) (do
    
    (if [= (@ op-type imm-op) (immediate-operand)]
      [mem-write bin pos (storage _ (@ op-immediate imm-op)) (@ op-size imm-op)]
      (ignore))
    
    (let (instr-size [- $pos instr-start-pos]) (do
    
    (if [= (@ op-type modrm.rm-op) (memory-operand)]
      [prepend (values (buffer-storage ..) disp-pos (@ op-disp-size modrm.rm-op) instr-start-pos instr-size)
        (& op-locations modrm.rm-op) ..]
      (ignore))
    
    (if [= (@ op-type imm-op) (immediate-operand)]
      [prepend (values (buffer-storage ..) imm-pos (@ op-size imm-op) instr-start-pos instr-size) (& op-locations imm-op) ..]
      (ignore))
    
    (true)))))))))))))))))))))))))))))

(constrain write-nm-instr (\ r (with-vars (f g h i) (`(function (instr ,f (ref ,g) buffer ,h) ,i)r)r)))

(function write-nm-instr (n bin pos buf handler)
  (substitute (.. buf handler)
    (bind-if (match-list-prefix
        (%(match-property (op-type (%[= (none-operand)])))) (@ instr-operands n))
      () (true) (false))))

(constrain write-mr-instr (\ r (with-vars (a b c d e f g h i) (`(function (,a ,b ,c ,d ,e instr ,f (ref ,g) buffer ,h) ,i)r)r)))

(function write-mr-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 n bin pos buf handler)
  (substitute (.. buf handler)
    (bind-if (match-list-prefix
        (%(match-and
          (%[variable op1])
          (%(match-property (op-type (%(match-or (%[= (memory-operand)]) (%[= (register-operand)]))))))))
        (%(match-and
          (%[variable op2])
          (%(match-property (op-type (%[= (register-operand)])))))) (@ instr-operands n))
      (op1 op2)
        (if (and [band mask #1] [= (@ op-size $op1) #1] [= (@ op-size $op2) #1])
          [write-instr bin pos opcode-8 [>> mask #4] [make-none-op ..] $op2 $op1 [make-none-op ..] ..]
        (if (and [band mask #2] [= (@ op-size $op1) #2] [= (@ op-size $op2) #2])
          [write-instr bin pos opcode-16 [>> mask #4] [make-none-op ..] $op2 $op1 [make-none-op ..] ..]
        (if (and [band mask #4] [= (@ op-size $op1) #4] [= (@ op-size $op2) #4])
          [write-instr bin pos opcode-32 [>> mask #4] [make-none-op ..] $op2 $op1 [make-none-op ..] ..]
        (if (and [band mask #8] [= (@ op-size $op1) #8] [= (@ op-size $op2) #8])
          [write-instr bin pos opcode-64 [>> mask #4] [make-none-op ..] $op2 $op1 [make-none-op ..] ..]
          (false)))))
      (false))))

(constrain write-rm-instr (\ r (with-vars (a b c d e f g h i) (`(function (,a ,b ,c ,d ,e instr ,f (ref ,g) buffer ,h) ,i)r)r)))

(function write-rm-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 n bin pos buf handler)
  (substitute (.. buf handler)
    (bind-if (match-list-prefix
        (%(match-and
          (%[variable op1])
          (%(match-property (op-type (%[= (register-operand)]))))))
        (%(match-and
          (%[variable op2])
          (%(match-property (op-type (%(match-or (%[= (memory-operand)]) (%[= (register-operand)])))))))) (@ instr-operands n))
      (op1 op2)
        (if (and [band mask #1] [= (@ op-size $op1) #1] [= (@ op-size $op2) #1])
          [write-instr bin pos opcode-8 [>> mask #4] [make-none-op ..] $op1 $op2 [make-none-op ..] ..]
        (if (and [band mask #2] [= (@ op-size $op1) #2] [= (@ op-size $op2) #2])
          [write-instr bin pos opcode-16 [>> mask #4] [make-none-op ..] $op1 $op2 [make-none-op ..] ..]
        (if (and [band mask #4] [= (@ op-size $op1) #4] [= (@ op-size $op2) #4])
          [write-instr bin pos opcode-32 [>> mask #4] [make-none-op ..] $op1 $op2 [make-none-op ..] ..]
        (if (and [band mask #8] [= (@ op-size $op1) #8] [= (@ op-size $op2) #8])
          [write-instr bin pos opcode-64 [>> mask #4] [make-none-op ..] $op1 $op2 [make-none-op ..] ..]
          (false)))))
      (false))))

(constrain write-mi-instr (\ r (with-vars (a b c d e f g h i) (`(function (,a ,b ,c ,d ,e operand instr ,f (ref ,g) buffer ,h) ,i)r)r)))

(function write-mi-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 opcode.reg-op n bin pos buf handler)
  (substitute (.. buf handler)
    (bind-if (match-list-prefix
        (%(match-and
          (%[variable op1])
          (%(match-property (op-type (%(match-or (%[= (memory-operand)]) (%[= (register-operand)]))))))))
        (%(match-and
          (%[variable op2])
          (%(match-property (op-type (%[= (immediate-operand)])))))) (@ instr-operands n))
      (op1 op2)
        (if (and [= (@ op-size $op1) #1] [= (@ op-size $op2) #1])
          [write-instr bin pos opcode-8 [>> mask #4] [make-none-op ..] opcode.reg-op $op1 $op2 ..]
        (if (and [= (@ op-size $op1) #2] [= (@ op-size $op2) #2])
          [write-instr bin pos opcode-16 [>> mask #4] [make-none-op ..] opcode.reg-op $op1 $op2 ..]
        (if (and [= (@ op-size $op1) #4] [= (@ op-size $op2) #4])
          [write-instr bin pos opcode-32 [>> mask #4] [make-none-op ..] opcode.reg-op $op1 $op2 ..]
        (if (and [= (@ op-size $op1) #8] [= (@ op-size $op2) #4])
          [write-instr bin pos opcode-64 [>> mask #4] [make-none-op ..] opcode.reg-op $op1 $op2 ..]
          (false)))))
      (false))))

(constrain write-mi8-instr (\ r (with-vars (a b c d e f g h i) (`(function (,a ,b ,c ,d ,e operand instr ,f (ref ,g) buffer ,h) ,i)r)r)))

(function write-mi8-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 opcode.reg-op n bin pos buf handler)
  (substitute (.. buf handler)
    (bind-if (match-list-prefix
        (%(match-and
          (%[variable op1])
          (%(match-property (op-type (%(match-or (%[= (memory-operand)]) (%[= (register-operand)]))))))))
        (%(match-and
          (%[variable op2])
          (%(match-property (op-type (%[= (immediate-operand)])))))) (@ instr-operands n))
      (op1 op2)
        (if (and [band mask #1] [= (@ op-size $op1) #1] [= (@ op-size $op2) #1])
          [write-instr bin pos opcode-8 [>> mask #4] [make-none-op ..] opcode.reg-op $op1 $op2 ..]
        (if (and [band mask #2] [= (@ op-size $op1) #2] [= (@ op-size $op2) #1])
          [write-instr bin pos opcode-16 [>> mask #4] [make-none-op ..] opcode.reg-op $op1 $op2 ..]
        (if (and [band mask #4] [= (@ op-size $op1) #4] [= (@ op-size $op2) #1])
          [write-instr bin pos opcode-32 [>> mask #4] [make-none-op ..] opcode.reg-op $op1 $op2 ..]
        (if (and [band mask #8] [= (@ op-size $op1) #8] [= (@ op-size $op2) #1])
          [write-instr bin pos opcode-64 [>> mask #4] [make-none-op ..] opcode.reg-op $op1 $op2 ..]
          (false)))))
      (false))))

(constrain write-mm-instr (\ r (with-vars (a b c d e f g h i) (`(function (,a ,b ,c ,d ,e instr ,f (ref ,g) buffer ,h) ,i)r)r)))

(function write-mm-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 n bin pos buf handler)
  (substitute (.. buf handler)
    (bind-if (match-list-prefix
        (%(match-and
          (%[variable op1])
          (%(match-property (op-type (%[= (memory-operand)]))))))
        (%(match-and
          (%[variable op2])
          (%(match-property (op-type (%[= (memory-operand)]))))))
        (%[variable op3]) (@ instr-operands n))
      (op1 op2 op3)
        (if (and [band mask #1] [= (@ op-size $op1) #1] [= (@ op-size $op2) #1]) (do
          [write-instr bin pos (hex 8A) #1 [make-none-op ..] $op3 $op2 [make-none-op ..] ..]
          [write-instr bin pos opcode-8 [>> mask #4] [make-none-op ..] $op3 $op1 [make-none-op ..] ..])
        (if (and [band mask #2] [= (@ op-size $op1) #2] [= (@ op-size $op2) #2]) (do
          [write-instr bin pos (hex 8B) #1 [make-none-op ..] $op3 $op2 [make-none-op ..] ..]
          [write-instr bin pos opcode-16 [>> mask #4] [make-none-op ..] $op3 $op1 [make-none-op ..] ..])
        (if (and [band mask #4] [= (@ op-size $op1) #4] [= (@ op-size $op2) #4]) (do
          [write-instr bin pos (hex 8B) #1 [make-none-op ..] $op3 $op2 [make-none-op ..] ..]
          [write-instr bin pos opcode-32 [>> mask #4] [make-none-op ..] $op3 $op1 [make-none-op ..] ..])
        (if (and [band mask #8] [= (@ op-size $op1) #8] [= (@ op-size $op2) #8]) (do
          [write-instr bin pos (hex 8B) #1 [make-none-op ..] $op3 $op2 [make-none-op ..] ..]
          [write-instr bin pos opcode-64 [>> mask #4] [make-none-op ..] $op3 $op1 [make-none-op ..] ..])
          (false)))))
      (false))))

(constrain write-m-instr (\ r (with-vars (a b c d e f g h i) (`(function (,a ,b ,c ,d ,e operand instr ,f (ref ,g) buffer ,h) ,i)r)r)))

(function write-m-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 opcode.reg-op n bin pos buf handler)
  (substitute (.. buf handler)
    (bind-if (match-list-prefix
        (%(match-and
          (%[variable op1])
          (%(match-property (op-type (%(match-or (%[= (memory-operand)]) (%[= (register-operand)])))))))) (@ instr-operands n))
      (op1)
        (if (and [band mask #1] [= (@ op-size $op1) #1])
          [write-instr bin pos opcode-8 [>> mask #4] [make-none-op ..] opcode.reg-op $op1 [make-none-op ..] ..]
        (if (and [band mask #2] [= (@ op-size $op1) #2])
          [write-instr bin pos opcode-16 [>> mask #4] [make-none-op ..] opcode.reg-op $op1 [make-none-op ..] ..]
        (if (and [band mask #4] [= (@ op-size $op1) #4])
          [write-instr bin pos opcode-32 [>> mask #4] [make-none-op ..] opcode.reg-op $op1 [make-none-op ..] ..]
        (if (and [band mask #8] [= (@ op-size $op1) #8])
          [write-instr bin pos opcode-64 [>> mask #4] [make-none-op ..] opcode.reg-op $op1 [make-none-op ..] ..]
          (false)))))
      (false))))

(constrain write-d-instr (\ r (with-vars (a b c d e f g h i) (`(function (,a ,b ,c ,d ,e instr ,f (ref ,g) buffer ,h) ,i)r)r)))

(function write-d-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 n bin pos buf handler)
  (substitute (.. buf handler)
    (bind-if (match-list-prefix
        (%(match-and
          (%[variable op1])
          (%(match-property (op-type (%[= (immediate-operand)])))))) (@ instr-operands n))
      (op1)
        (if (and [band mask #1] [= (@ op-size $op1) #1])
          [write-instr bin pos opcode-8 [>> mask #4] [make-none-op ..] [make-none-op ..] [make-none-op ..] $op1 ..]
        (if (and [band mask #2] [= (@ op-size $op1) #2])
          [write-instr bin pos opcode-16 [>> mask #4] [make-none-op ..] [make-none-op ..] [make-none-op ..] $op1 ..]
        (if (and [band mask #4] [= (@ op-size $op1) #4])
          [write-instr bin pos opcode-32 [>> mask #4] [make-none-op ..] [make-none-op ..] [make-none-op ..] $op1 ..]
        (if (and [band mask #8] [= (@ op-size $op1) #8])
          [write-instr bin pos opcode-64 [>> mask #4] [make-none-op ..] [make-none-op ..] [make-none-op ..] $op1 ..]
          (false)))))
      (false))))

(constrain write-mc-instr (\ r (with-vars (a b c d e f g h i) (`(function (,a ,b ,c ,d ,e operand instr ,f (ref ,g) buffer ,h) ,i)r)r)))

(function write-mc-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 opcode.reg-op n bin pos buf handler)
  (substitute (.. buf handler)
    (bind-if (match-list-prefix
        (%(match-and
          (%[variable op1])
          (%(match-property (op-type (%(match-or (%[= (memory-operand)]) (%[= (register-operand)]))))))))
        (%(match-property
          (op-type (%[= (register-operand)]))
          (op-register (%[= (cl)])))) (@ instr-operands n))
      (op1)
        (if (and [band mask #1] [= (@ op-size $op1) #1])
          [write-instr bin pos opcode-8 [>> mask #4] [make-none-op ..] opcode.reg-op $op1 [make-none-op ..] ..]
        (if (and [band mask #2] [= (@ op-size $op1) #2])
          [write-instr bin pos opcode-16 [>> mask #4] [make-none-op ..] opcode.reg-op $op1 [make-none-op ..] ..]
        (if (and [band mask #4] [= (@ op-size $op1) #4])
          [write-instr bin pos opcode-32 [>> mask #4] [make-none-op ..] opcode.reg-op $op1 [make-none-op ..] ..]
        (if (and [band mask #8] [= (@ op-size $op1) #8])
          [write-instr bin pos opcode-64 [>> mask #4] [make-none-op ..] opcode.reg-op $op1 [make-none-op ..] ..]
          (false)))))
      (false))))

(storage unsupported-instruction-error (ignore))

(constrain assemble (\ r (with-vars (a b c e) (`(function ((list instr) ,a buffer ,e) (values ,b ,c))r)r)))

(function assemble (instrs ret-val buf handler)
  (substitute (.. buf handler)
    (let (pos (storage _ #0))
    (let (max-text-sec-len [pad-size [* (write-elf-max-instr-len) [length instrs]] (write-elf-alignment)])
    (let (bin [buffer-alloc max-text-sec-len ..]) (do
    (foreach (n instrs) (do
      (let (instr-bndg (@ instr-binding n))
        (if [not= instr-bndg null-binding] (do
          (setf bndg-storage instr-bndg (absolute-storage))
          (setf bndg-offset instr-bndg $pos)
          (setf st-value (@ lkdst-raw (@ bndg-other instr-bndg)) $pos))
          (ignore)))
      
      (switch = (@ instr-code n)
        ((label) (ignore))
        ((x86-nop)
          [write-instr bin pos (hex 90) #1 [make-none-op ..] [make-none-op ..] [make-none-op ..] [make-none-op ..] ..])
        ((x86-push) (or
          [write-m-instr (hex 1E) (ignore) (hex FF) (hex FF) (hex FF) [make-reg-op (x86-/6) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-pop) (or
          [write-m-instr (hex 1E) (ignore) (hex 8F) (hex 8F) (hex 8F) [make-reg-op (x86-/0) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-xor) (or
          [write-mi-instr (hex 1F) (hex 80) (hex 81) (hex 81) (hex 81) [make-reg-op (x86-/6) ..] n bin pos ..]
          [write-mr-instr (hex 1F) (hex 30) (hex 31) (hex 31) (hex 31) n bin pos ..]
          [write-rm-instr (hex 1F) (hex 32) (hex 33) (hex 33) (hex 33) n bin pos ..]
          [write-mm-instr (hex 1F) (hex 30) (hex 31) (hex 31) (hex 31) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-setz) (or
          [write-m-instr (hex 21) (hex 940F) (ignore) (ignore) (ignore) [make-none-op ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-setc) (or
          [write-m-instr (hex 21) (hex 920F) (ignore) (ignore) (ignore) [make-none-op ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-setg) (or
          [write-m-instr (hex 21) (hex 9F0F) (ignore) (ignore) (ignore) [make-none-op ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-mul) (or
          [write-m-instr (hex 1F) (hex F6) (hex F7) (hex F7) (hex F7) [make-reg-op (x86-/4) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-div) (or
          [write-m-instr (hex 1F) (hex F6) (hex F7) (hex F7) (hex F7) [make-reg-op (x86-/6) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-jmp) (or
          [write-m-instr (hex 1E) (ignore) (hex FF) (hex FF) (hex FF) [make-reg-op (x86-/4) ..] n bin pos ..]
          [write-d-instr (hex 17) (hex EB) (hex E9) (hex E9) (ignore) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-sub) (or
          [write-rm-instr (hex 1F) (hex 2A) (hex 2B) (hex 2B) (hex 2B) n bin pos ..]
          [write-mr-instr (hex 1F) (hex 28) (hex 29) (hex 29) (hex 29) n bin pos ..]
          [write-mi-instr (hex 1F) (hex 80) (hex 81) (hex 81) (hex 81) [make-reg-op (x86-/5) ..] n bin pos ..]
          [write-mm-instr (hex 1F) (hex 28) (hex 29) (hex 29) (hex 29) n bin pos ..]
          [write-mi8-instr (hex 1E) (ignore) (hex 83) (hex 83) (hex 83) [make-reg-op (x86-/5) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-cmp) (or
          [write-rm-instr (hex 1F) (hex 3A) (hex 3B) (hex 3B) (hex 3B) n bin pos ..]
          [write-mr-instr (hex 1F) (hex 38) (hex 39) (hex 39) (hex 39) n bin pos ..]
          [write-mi-instr (hex 1F) (hex 80) (hex 81) (hex 81) (hex 81) [make-reg-op (x86-/7) ..] n bin pos ..]
          [write-mm-instr (hex 1F) (hex 38) (hex 39) (hex 39) (hex 39) n bin pos ..]
          [write-mi8-instr (hex 1E) (ignore) (hex 83) (hex 83) (hex 83) [make-reg-op (x86-/7) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-add) (or
          [write-rm-instr (hex 1F) (hex 02) (hex 03) (hex 03) (hex 03) n bin pos ..]
          [write-mr-instr (hex 1F) (hex 00) (hex 01) (hex 01) (hex 01) n bin pos ..]
          [write-mi-instr (hex 1F) (hex 80) (hex 81) (hex 81) (hex 81) [make-reg-op (x86-/0) ..] n bin pos ..]
          [write-mm-instr (hex 1F) (hex 00) (hex 01) (hex 01) (hex 01) n bin pos ..]
          [write-mi8-instr (hex 1E) (ignore) (hex 83) (hex 83) (hex 83) [make-reg-op (x86-/0) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-or) (or
          [write-rm-instr (hex 1F) (hex 0A) (hex 0B) (hex 0B) (hex 0B) n bin pos ..]
          [write-mr-instr (hex 1F) (hex 08) (hex 09) (hex 09) (hex 09) n bin pos ..]
          [write-mm-instr (hex 1F) (hex 08) (hex 09) (hex 09) (hex 09) n bin pos ..]
          [write-mi-instr (hex 1F) (hex 80) (hex 81) (hex 81) (hex 81) [make-reg-op (x86-/1) ..] n bin pos ..]
          [write-mi8-instr (hex 1F) (hex 80) (hex 83) (hex 83) (hex 83) [make-reg-op (x86-/1) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-and) (or
          [write-rm-instr (hex 1F) (hex 22) (hex 23) (hex 23) (hex 23) n bin pos ..]
          [write-mr-instr (hex 1F) (hex 20) (hex 21) (hex 21) (hex 21) n bin pos ..]
          [write-mm-instr (hex 1F) (hex 20) (hex 21) (hex 21) (hex 21) n bin pos ..]
          [write-mi-instr (hex 1F) (hex 80) (hex 81) (hex 81) (hex 81) [make-reg-op (x86-/4) ..] n bin pos ..]
          [write-mi8-instr (hex 1F) (hex 80) (hex 83) (hex 83) (hex 83) [make-reg-op (x86-/4) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-not) (or
          [write-m-instr (hex 1F) (hex F6) (hex F7) (hex F7) (hex F7) [make-reg-op (x86-/2) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-call) (or
          [write-m-instr (hex 1E) (ignore) (hex FF) (hex FF) (hex FF) [make-reg-op (x86-/2) ..] n bin pos ..]
          [write-d-instr (hex 16) (ignore) (hex E8) (hex E8) (ignore) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-je) (or
          [write-d-instr (hex 24) (ignore) (ignore) (hex 840F) (ignore) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-jnz) (or
          [write-d-instr (hex 24) (ignore) (ignore) (hex 850F) (ignore) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-jnc) (x86-jae) (or
          [write-d-instr (hex 24) (ignore) (ignore) (hex 830F) (ignore) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-jle) (or
          [write-d-instr (hex 24) (ignore) (ignore) (hex 8E0F) (ignore) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-shl) (or
          [write-mc-instr (hex 1F) (hex D2) (hex D3) (hex D3) (hex D3) [make-reg-op (x86-/4) ..] n bin pos ..]
          [write-mi8-instr (hex 1F) (hex C0) (hex C1) (hex C1) (hex C1) [make-reg-op (x86-/4) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-shr) (or
          [write-mc-instr (hex 1F) (hex D2) (hex D3) (hex D3) (hex D3) [make-reg-op (x86-/5) ..] n bin pos ..]
          [write-mi8-instr (hex 1F) (hex C0) (hex C1) (hex C1) (hex C1) [make-reg-op (x86-/5) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86-leave)
          [write-instr bin pos (hex C9) #1 [make-none-op ..] [make-none-op ..] [make-none-op ..] [make-none-op ..] ..])
        ((x86-ret)
          [write-instr bin pos (hex C3) #1 [make-none-op ..] [make-none-op ..] [make-none-op ..] [make-none-op ..] ..])
        
        ((x86-movzx) (or
          (bind-if (match-list-prefix
              (%(match-and
                (%[variable op1])
                (%(match-property (op-type (%[= (register-operand)]))))))
              (%(match-and
                (%[variable op2])
                (%(match-property (op-type (%(match-or (%[= (memory-operand)]) (%[= (register-operand)])))))))) (@ instr-operands n))
            (op1 op2)
              (if (and [= (@ op-size $op1) #2] [= (@ op-size $op2) #1])
                [write-instr bin pos (hex B60F) #2 [make-none-op ..] $op1 $op2 [make-none-op ..] ..]
              (if (and [= (@ op-size $op1) #4] [= (@ op-size $op2) #1])
                [write-instr bin pos (hex B60F) #2 [make-none-op ..] $op1 $op2 [make-none-op ..] ..]
              (if (and [= (@ op-size $op1) #8] [= (@ op-size $op2) #1])
                [write-instr bin pos (hex B60F) #2 [make-none-op ..] $op1 $op2 [make-none-op ..] ..]
              (if (and [= (@ op-size $op1) #4] [= (@ op-size $op2) #2])
                [write-instr bin pos (hex B70F) #2 [make-none-op ..] $op1 $op2 [make-none-op ..] ..]
              (if (and [= (@ op-size $op1) #8] [= (@ op-size $op2) #2])
                [write-instr bin pos (hex B70F) #2 [make-none-op ..] $op1 $op2 [make-none-op ..] ..]
              (if (and [= (@ op-size $op1) #8] [= (@ op-size $op2) #4])
                [write-instr bin pos (hex 8B) #1 [make-none-op ..] [op-lower-32 $op1 ..] $op2 [make-none-op ..] ..]
                (false))))))) (false))
          (bind-if (match-list-prefix
              (%(match-and
                (%[variable op1])
                (%(match-property (op-type (%[= (memory-operand)]))))))
              (%(match-and
                (%[variable op2])
                (%(match-property (op-type (%(match-or (%[= (memory-operand)]) (%[= (register-operand)]))))))))
              (%[variable op3]) (@ instr-operands n))
            (op1 op2 op3)
              (if (and [= (@ op-size $op1) #2] [= (@ op-size $op2) #1]) (do
                [write-instr bin pos (hex B60F) #2 [make-none-op ..] $op3 $op2 [make-none-op ..] ..]
                [write-instr bin pos (hex 89) #1 [make-none-op ..] $op3 $op1 [make-none-op ..] ..])
              (if (and [= (@ op-size $op1) #4] [= (@ op-size $op2) #1]) (do
                [write-instr bin pos (hex B60F) #2 [make-none-op ..] $op3 $op2 [make-none-op ..] ..]
                [write-instr bin pos (hex 89) #1 [make-none-op ..] $op3 $op1 [make-none-op ..] ..])
              (if (and [= (@ op-size $op1) #8] [= (@ op-size $op2) #1]) (do
                [write-instr bin pos (hex B60F) #2 [make-none-op ..] $op3 $op2 [make-none-op ..] ..]
                [write-instr bin pos (hex 89) #1 [make-none-op ..] $op3 $op1 [make-none-op ..] ..])
              (if (and [= (@ op-size $op1) #4] [= (@ op-size $op2) #2]) (do
                [write-instr bin pos (hex B70F) #2 [make-none-op ..] $op3 $op2 [make-none-op ..] ..]
                [write-instr bin pos (hex 89) #1 [make-none-op ..] $op3 $op1 [make-none-op ..] ..])
              (if (and [= (@ op-size $op1) #8] [= (@ op-size $op2) #2]) (do
                [write-instr bin pos (hex B70F) #2 [make-none-op ..] $op3 $op2 [make-none-op ..] ..]
                [write-instr bin pos (hex 89) #1 [make-none-op ..] $op3 $op1 [make-none-op ..] ..])
              (if (and [= (@ op-size $op1) #8] [= (@ op-size $op2) #4]) (do
                [write-instr bin pos (hex 8B) #1 [make-none-op ..] [op-lower-32 $op3 ..] $op2 [make-none-op ..] ..]
                [write-instr bin pos (hex 89) #1 [make-none-op ..] $op3 $op1 [make-none-op ..] ..])
                (false))))))) (false))
          {handler (storage _ unsupported-instruction-error n)}))
        
        ((x86-mov) (or
          [write-nm-instr n bin pos ..]
          [write-mr-instr (hex 1F) (hex 88) (hex 89) (hex 89) (hex 89) n bin pos ..]
          [write-rm-instr (hex 1F) (hex 8A) (hex 8B) (hex 8B) (hex 8B) n bin pos ..]
          [write-mm-instr (hex 1F) (hex 88) (hex 89) (hex 89) (hex 89) n bin pos ..]
          [write-mi-instr (hex 1F) (hex C6) (hex C7) (hex C7) (hex C7) [make-reg-op (x86-/0) ..] n bin pos ..]
          (bind-if (match-list-prefix
              (%(match-and (%[variable op1]) (%(match-property (op-type (%[= (register-operand)]))))))
              (%(match-and (%[variable op2]) (%(match-property (op-type (%[= (immediate-operand)])))))) (@ instr-operands n))
            (op1 op2) (if (and [= (@ op-size $op1) #8] [= (@ op-size $op2) #8])
              [write-instr bin pos (hex B8) #1 $op1 [make-none-op ..] [make-none-op ..] $op2 ..] (false)) (false))
          (bind-if (match-list-prefix
              (%(match-and (%[variable op1]) (%(match-property (op-type (%[= (memory-operand)]))))))
              (%(match-and (%[variable op2]) (%(match-property (op-type (%[= (immediate-operand)]))))))
              (%[variable op3]) (@ instr-operands n))
            (op1 op2 op3) (if (and [= (@ op-size $op1) #8] [= (@ op-size $op2) #8]) (do
              [write-instr bin pos (hex B8) #1 $op3 [make-none-op ..] [make-none-op ..] $op2 ..]
              [write-instr bin pos (hex 89) #1 [make-none-op ..] $op3 $op1 [make-none-op ..] ..]) (false)) (false))
          {handler (storage _ unsupported-instruction-error n)}))
        
        ((x86-lea) (or
          [write-nm-instr n bin pos ..]
          (bind-if (match-list-prefix
              (%(match-and
                (%[variable op1])
                (%(match-property (op-type (%[= (register-operand)]))))))
              (%(match-and
                (%[variable op2])
                (%(match-property (op-type (%[= (memory-operand)])))))) (@ instr-operands n))
            (op1 op2)
              (if (and [= (@ op-size $op1) #2])
                [write-instr bin pos (hex 8D) #1 [make-none-op ..] $op1 $op2 [make-none-op ..] ..]
              (if (and [= (@ op-size $op1) #4])
                [write-instr bin pos (hex 8D) #1 [make-none-op ..] $op1 $op2 [make-none-op ..] ..]
              (if (and [= (@ op-size $op1) #8])
                [write-instr bin pos (hex 8D) #1 [make-none-op ..] $op1 $op2 [make-none-op ..] ..]
                (false)))) (false))
          (bind-if (match-list-prefix
              (%(match-and
                (%[variable op1])
                (%(match-property (op-type (%[= (memory-operand)]))))))
              (%(match-and
                (%[variable op2])
                (%(match-property (op-type (%[= (memory-operand)]))))))
              (%[variable op3]) (@ instr-operands n))
            (op1 op2 op3)
              (if (and [= (@ op-size $op1) #2]) (do
                [write-instr bin pos (hex 8D) #1 [make-none-op ..] $op3 $op2 [make-none-op ..] ..]
                [write-instr bin pos (hex 89) #1 [make-none-op ..] $op3 $op1 [make-none-op ..] ..])
              (if (and [= (@ op-size $op1) #4]) (do
                [write-instr bin pos (hex 8D) #1 [make-none-op ..] $op3 $op2 [make-none-op ..] ..]
                [write-instr bin pos (hex 89) #1 [make-none-op ..] $op3 $op1 [make-none-op ..] ..])
              (if (and [= (@ op-size $op1) #8]) (do
                [write-instr bin pos (hex 8D) #1 [make-none-op ..] $op3 $op2 [make-none-op ..] ..]
                [write-instr bin pos (hex 89) #1 [make-none-op ..] $op3 $op1 [make-none-op ..] ..])
                (false)))) (false))
          {handler (storage _ unsupported-instruction-error n)}))
        
        {handler (storage _ unsupported-instruction-error n)})))
    (values (use-storage ret-val) bin $pos)))))))

(constrain make-function-text-section
  (\ r (with-vars (a) (`(function ((list instr) string linked-elf64-e linked-elf64-sh linked-elf64-sh buffer ,a) linked-elf64-sh)r)r)))

(function make-function-text-section (instrs text-name-str lkd-ehdr lkd-strtab-shdr lkd-symtab-shdr temp-buf cleanup)
  (let (text-name [make-lkdstrt text-name-str temp-buf cleanup])
  (let (lkd-text-shdr [make-lkds text-name (@ lkde-undef lkd-ehdr) temp-buf cleanup])
  (let (text-shdr (@ lkdsh-raw lkd-text-shdr)) (do
  [append text-name (& lkdsh-strtab (@ lkde-shstr lkd-ehdr)) temp-buf cleanup]
  (setf sh-type text-shdr (sht-progbits))
  (setf sh-flags text-shdr [bor (shf-alloc) (shf-execinstr)])
  (setf sh-addr text-shdr #0)
  (setf sh-info text-shdr #0)
  (setf sh-addralign text-shdr #1)
  (setf sh-entsize text-shdr #0)
  [append lkd-text-shdr (& lkde-sh lkd-ehdr) temp-buf cleanup]
  
  (foreach (e instrs)
    (let (instr-bndg (@ instr-binding e))
      (if [not= instr-bndg null-binding]
        (let (sym-name (if [not= (@ bndg-name instr-bndg) null-string]
            (let (sym-name [make-lkdstrt (@ bndg-name instr-bndg) temp-buf cleanup])
              (do [append sym-name (& lkdsh-strtab lkd-strtab-shdr) temp-buf cleanup] sym-name))
            [@car (@ lkdsh-strtab lkd-strtab-shdr)]))
          (let (lkd-sym [make-lkdst sym-name lkd-text-shdr temp-buf cleanup])
          (let (sym (@ lkdst-raw lkd-sym)) (do
          (setf st-value sym #0)
          (setf st-size sym #0)
          (setf st-info sym (elf64-st-info
            (switch = (@ bndg-scope instr-bndg)
              ((local-scope)(stb-local))
              ((global-scope)(stb-global))
              (ignore)) (stt-notype)))
          (setf st-other sym #0)
          (setf bndg-other instr-bndg lkd-sym)
          [append lkd-sym (& lkdsh-symtab lkd-symtab-shdr) temp-buf cleanup]))))
        (ignore))))
        
  (bind (text text-len) [assemble instrs bind temp-buf cleanup] (do
  (setf sh-size (@ lkdsh-raw lkd-text-shdr) text-len)
  (setf lkdsh-offset lkd-text-shdr text)
  
  lkd-text-shdr)))))))

(constrain make-function-relocation-section
  (\ r (with-vars (a) (`(function ((list reloc) string linked-elf64-e linked-elf64-sh linked-elf64-sh buffer ,a) linked-elf64-sh)r)r)))

(function make-function-relocation-section (relocations rela-name-str lkd-ehdr lkd-text-shdr lkd-symtab-shdr temp-buf cleanup)
  (let (rela-name [make-lkdstrt rela-name-str temp-buf cleanup])
  (let (lkd-rela-shdr [make-lkdrela rela-name lkd-symtab-shdr lkd-text-shdr nil temp-buf cleanup])
  (let (rela-shdr (@ lkdsh-raw lkd-rela-shdr)) (do
  [append rela-name (& lkdsh-strtab (@ lkde-shstr lkd-ehdr)) temp-buf cleanup]
  (setf sh-type rela-shdr (sht-rela))
  (setf sh-flags rela-shdr #0)
  (setf sh-addr rela-shdr #0)
  (setf sh-addralign rela-shdr #0)
  (setf sh-entsize rela-shdr (elf64-rela))
  [append lkd-rela-shdr (& lkde-sh lkd-ehdr) temp-buf cleanup]

  (foreach (reloc relocations)
    (foreach (loca (@ op-locations (@ reloc-operand reloc)))
      (bind (operand-pos operand-size instr-pos instr-size) loca
        (let (lkd-rela [make-lkdr (@ bndg-other(@ reloc-binding reloc)) temp-buf cleanup])
        (let (rela (@ lkdr-raw lkd-rela)) (do
        (setf r-offset rela operand-pos)
        (setf r-info rela (elf64-r-info (ignore) (@ reloc-type reloc)))
        (setf r-addend rela
          [(@ reloc-addend-func reloc) (@ reloc-context reloc) operand-pos operand-size instr-pos instr-size])
        [append lkd-rela (& lkdsh-rela lkd-rela-shdr) temp-buf cleanup]))))))
  
  lkd-rela-shdr)))))

(ignore
  The following functions are for ensuring that truncating the outcome of a relocation
  computation preserves its value.)

(function assert-byte (val handler)
  (if [= val [band val (hex 00000000000000FF)]]
    val {handler (storage _ object-error)}))

(function assert-sbyte (val handler)
  (if (or [= val [band val (hex 000000000000007F)]] [= val [bor val (hex FFFFFFFFFFFFFF80)]])
    val {handler (storage _ object-error)}))

(function assert-half (val handler)
  (if [= val [band val (hex 000000000000FFFF)]]
    val {handler (storage _ object-error)}))

(function assert-shalf (val handler)
  (if (or [= val [band val (hex 0000000000007FFF)]] [= val [bor val (hex FFFFFFFFFFFF8000)]])
    val {handler (storage _ object-error)}))

(function assert-word (val handler)
  (if [= val [band val (hex 00000000FFFFFFFF)]]
    val {handler (storage _ object-error)}))

(function assert-sword (val handler)
  (if (or [= val [band val (hex 000000007FFFFFFF)]] [= val [bor val (hex FFFFFFFF80000000)]])
    val {handler (storage _ object-error)}))

(constrain do-relocation (\ r (with-vars (a b c d) (`(function (,d elf64-rela elf64-sym ,a ,b) ,c)r)r)))

(function do-relocation (target rela sym addend handler)
	(switch = (elf64-r-type (@ r-info rela))
    ((r-x86-64-none) (ignore))
    ((r-x86-64-64) [memcpy target (storage _[+(@ st-value sym)addend]) #8])
    ((r-x86-64-pc32) [memcpy target (storage _[assert-sword [-[+(@ st-value sym)addend](@ r-offset rela)] handler]) #4])
    ((r-x86-64-glob-dat) [memcpy target (storage _(@ st-value sym)) #8])
    ((r-x86-64-jump-slot) [memcpy target (storage _(@ st-value sym)) #8])
    ((r-x86-64-32) [memcpy target (storage _[assert-word [+(@ st-value sym) addend] handler]) #4])
    ((r-x86-64-32s) [memcpy target (storage _[assert-sword [+(@ st-value sym) addend] handler]) #4])
    ((r-x86-64-16) [memcpy target (storage _[assert-half [+(@ st-value sym) addend] handler]) #2])
    ((r-x86-64-pc16) [memcpy target (storage _[assert-shalf [-[+(@ st-value sym)addend](@ r-offset rela)] handler])#2])
    ((r-x86-64-8) [memcpy target (storage _[assert-byte [+(@ st-value sym)addend] handler]) #1])
    ((r-x86-64-pc8) [memcpy target (storage _[assert-sbyte [-[+(@ st-value sym)addend](@ r-offset rela)] handler])#1])
    ((r-x86-64-size32) [memcpy target (storage _[+(@ st-size sym)addend]) #4])
    ((r-x86-64-size64) [memcpy target (storage _[+(@ st-size sym)addend]) #8])
    {handler (storage _ object-error)}))

(ignore
  Takes assembly code and a list of symbols as constructs an object file.
  instrs is a list of assembly expressions. symbols is a list of the static
  symbols used in the assembly expressions. reg is the buffer into which the generated
  object code should be put. Returns a pair containing a reference to the generated object
  code and the size of the generated object code.)

(constrain write-elf
  (\ r (with-vars (a b c d) (`(function ((list instr) (list reloc) (list (values string (list instr) (list reloc)))
    (list bndg-aug) (list bndg-aug) ,a buffer buffer ,c) (values ,b ,d))r)r)))

(function write-elf (instrs relocations function-sections undefined-bindings static-bindings outs rgn1 rgn2 handler)
  (with-buffer rgn2 (do
    (let (lkd-ehdr [make-lkde nil nil (ignore) (ignore) rgn2 handler])
    (let (ehdr (@ lkde-raw lkd-ehdr)) (do
    (setf ei-mag0 (& e-ident ehdr) (elfmag0))
    (setf ei-mag1 (& e-ident ehdr) (elfmag1))
    (setf ei-mag2 (& e-ident ehdr) (elfmag2))
    (setf ei-mag3 (& e-ident ehdr) (elfmag3))
    (setf ei-class (& e-ident ehdr) (elfclass64))
    (setf ei-data (& e-ident ehdr) (elfdata2lsb))
    (setf ei-version (& e-ident ehdr) #1)
    (setf ei-osabi (& e-ident ehdr) (elfosabi-sysv))
    (setf ei-abiversion (& e-ident ehdr) #0)

    (until (i #7) [= i (ei-nident)] [+ i #1] [setb (loc(byte)i(& e-ident ehdr)) #0])

    (setf e-type ehdr (et-rel))
    (setf e-machine ehdr (em-x86-64))
    (setf e-version ehdr #1)
    (setf e-entry ehdr #0)
    (setf e-phoff ehdr #0)
    (setf e-shoff ehdr (elf64-ehdr))
    (setf e-flags ehdr #0)
    (setf e-ehsize ehdr (elf64-ehdr))
    (setf e-phentsize ehdr #0)
    (setf e-phnum ehdr #0)
    (setf e-shentsize ehdr (elf64-shdr))
    (setf e-shnum ehdr (write-elf-sh-count))
    (setf e-shstrndx ehdr #1)
    
    (let (shstrtab-name [make-lkdstrt (" .shstrtab) rgn2 handler])
    (let (lkd-shstrtab-shdr [make-lkdstrtab shstrtab-name (ignore) nil rgn2 handler])
    (let (shstrtab-shdr (@ lkdsh-raw lkd-shstrtab-shdr)) (do
    [append shstrtab-name (& lkdsh-strtab lkd-shstrtab-shdr) rgn2 handler]
    (setf sh-type shstrtab-shdr (sht-strtab))
    (setf sh-flags shstrtab-shdr #0)
    (setf sh-addr shstrtab-shdr #0)
    (setf sh-info shstrtab-shdr #0)
    (setf sh-addralign shstrtab-shdr #0)
    (setf sh-entsize shstrtab-shdr #0)
    [append lkd-shstrtab-shdr (& lkde-sh lkd-ehdr) rgn2 handler]
    (setf lkde-shstr lkd-ehdr lkd-shstrtab-shdr)
    
    (ignore Mandatory undefined section)
    (let (shstrtab-null-name [make-lkdstrt (" ) rgn2 handler])
    (let (lkd-undef-shdr [make-lkds shstrtab-null-name (ignore) rgn2 handler])
    (let (undef-shdr (@ lkdsh-raw lkd-undef-shdr)) (do
    [prepend shstrtab-null-name (& lkdsh-strtab lkd-shstrtab-shdr) rgn2 handler]
    (setf lkdsh-link lkd-undef-shdr lkd-undef-shdr)
    (setf sh-name undef-shdr #0)
    (setf sh-type undef-shdr (sht-null))
    (setf sh-flags undef-shdr #0)
    (setf sh-addr undef-shdr #0)
    (setf sh-offset undef-shdr #0)
    (setf sh-size undef-shdr #0)
    (setf sh-info undef-shdr #0)
    (setf sh-addralign undef-shdr #0)
    (setf sh-entsize undef-shdr #0)
    (setf lkde-undef lkd-ehdr lkd-undef-shdr)
    (setf lkdsh-link lkd-shstrtab-shdr lkd-undef-shdr)
    
    (let (strtab-name [make-lkdstrt (" .strtab) rgn2 handler])
    (let (lkd-strtab-shdr [make-lkdstrtab strtab-name lkd-undef-shdr nil rgn2 handler])
    (let (strtab-shdr (@ lkdsh-raw lkd-strtab-shdr)) (do
    [append strtab-name (& lkdsh-strtab lkd-shstrtab-shdr) rgn2 handler]
    (setf sh-type strtab-shdr (sht-strtab))
    (setf sh-flags strtab-shdr #0)
    (setf sh-addr strtab-shdr #0)
    (setf sh-link strtab-shdr (shn-undef))
    (setf sh-info strtab-shdr #0)
    (setf sh-addralign strtab-shdr #0)
    (setf sh-entsize strtab-shdr #0)
    [append lkd-strtab-shdr (& lkde-sh lkd-ehdr) rgn2 handler]
    
    (let (symtab-name [make-lkdstrt (" .symtab) rgn2 handler])
    (let (lkd-symtab-shdr [make-lkdsymtab symtab-name lkd-strtab-shdr nil rgn2 handler])
    (let (symtab-shdr (@ lkdsh-raw lkd-symtab-shdr)) (do
    [append symtab-name (& lkdsh-strtab lkd-shstrtab-shdr) rgn2 handler]
    (setf sh-type symtab-shdr (sht-symtab))
    (setf sh-flags symtab-shdr #0)
    (setf sh-addr symtab-shdr #0)
    (setf sh-addralign symtab-shdr #0)
    (setf sh-entsize symtab-shdr (elf64-sym))
    [append lkd-symtab-shdr (& lkde-sh lkd-ehdr) rgn2 handler]
    
    (let (bss-extent
      (fold (bss-extent [- #0 (word-size)]) (bndg static-bindings)
        [min bss-extent (@ bndg-offset bndg)])) (do
    
    (let (bss-name [make-lkdstrt (" .bss) rgn2 handler])
    (let (lkd-bss-shdr [make-lkds bss-name lkd-undef-shdr rgn2 handler])
    (let (bss-shdr (@ lkdsh-raw lkd-bss-shdr)) (do
    [append bss-name (& lkdsh-strtab lkd-shstrtab-shdr) rgn2 handler]
    (setf sh-type bss-shdr (sht-nobits))
    (setf sh-flags bss-shdr [bor (shf-write) (shf-alloc)])
    (setf sh-addr bss-shdr #0)
    (setf sh-size bss-shdr [- #0 bss-extent])
    (setf sh-info bss-shdr #0)
    (setf sh-addralign bss-shdr (word-size))
    (setf sh-entsize bss-shdr #0)
    [append lkd-bss-shdr (& lkde-sh lkd-ehdr) rgn2 handler]
    
    (let (strtab-null-name [make-lkdstrt (" ) rgn2 handler])
    (let (lkd-und-sym [make-lkdst strtab-null-name lkd-undef-shdr rgn2 handler])
    (let (und-sym (@ lkdst-raw lkd-und-sym)) (do
    (ignore Mandatory undefined symbol)
    [append strtab-null-name (& lkdsh-strtab lkd-strtab-shdr) rgn2 handler]
    (setf st-name und-sym #0)
    (setf st-value und-sym #0)
    (setf st-size und-sym #0)
    (setf st-info und-sym #0)
    (setf st-other und-sym #0)
    [prepend lkd-und-sym (& lkdsh-symtab lkd-symtab-shdr) rgn2 handler]
    
    (let (lkd-bss-sym [make-lkdst strtab-null-name lkd-bss-shdr rgn2 handler])
    (let (bss-sym (@ lkdst-raw lkd-bss-sym)) (do
    (setf st-value bss-sym #0)
    (setf st-size bss-sym [- #0 bss-extent])
    (setf st-info bss-sym (elf64-st-info (stb-local) (stt-notype)))
    (setf st-other bss-sym #0)
    [append lkd-bss-sym (& lkdsh-symtab lkd-symtab-shdr) rgn2 handler]
    
    (foreach (bndg static-bindings)
      (if [= (@ bndg-state bndg) (defined-state)]
        (let (sym-name (if [not= (@ bndg-name bndg) null-string]
            (let (sym-name [make-lkdstrt (@ bndg-name bndg) rgn2 handler])
              (do [append sym-name (& lkdsh-strtab lkd-strtab-shdr) rgn2 handler] sym-name))
            strtab-null-name))
          (let (lkd-sym [make-lkdst sym-name lkd-bss-shdr rgn2 handler])
          (let (sym (@ lkdst-raw lkd-sym)) (do
          [set- (& bndg-offset bndg) bss-extent]
          (setf st-value sym (@ bndg-offset bndg))
          (setf st-size sym (@ bndg-size bndg))
          (setf st-info sym (elf64-st-info
            (switch = (@ bndg-scope bndg)
              ((local-scope)(stb-local))
              ((global-scope)(stb-global))
              (ignore)) (stt-notype)))
          (setf st-other sym #0)
          (setf bndg-other bndg lkd-sym)
          [append lkd-sym (& lkdsh-symtab lkd-symtab-shdr) rgn2 handler]))))
        (ignore)))
    
    (foreach (bndg undefined-bindings)
      (if (and [= (@ bndg-scope bndg) (global-scope)] [= (@ bndg-state bndg) (undefined-state)])
        (let (sym-name (if [not= (@ bndg-name bndg) null-string]
            (let (sym-name [make-lkdstrt (@ bndg-name bndg) rgn2 handler])
                (do [append sym-name (& lkdsh-strtab lkd-strtab-shdr) rgn2 handler] sym-name))
            strtab-null-name))
          (let (lkd-sym [make-lkdst sym-name lkd-undef-shdr rgn2 handler])
          (let (sym (@ lkdst-raw lkd-sym)) (do
          (setf st-value sym #0)
          (setf st-size sym #0)
          (setf st-info sym (elf64-st-info (stb-global) (stt-notype)))
          (setf st-other sym #0)
          (setf bndg-other bndg lkd-sym)
          [append lkd-sym (& lkdsh-symtab lkd-symtab-shdr) rgn2 handler]))))
        (ignore)))
    
    (let (main-text-sec [make-function-text-section instrs (" .text) lkd-ehdr lkd-strtab-shdr lkd-symtab-shdr rgn2 handler])
    
    (let (func-text-secs (map (func-sec function-sections)
      (bind (name instrs relocs) func-sec
        [make-function-text-section instrs [rstrcat (" .text.) name rgn2 handler]
          lkd-ehdr lkd-strtab-shdr lkd-symtab-shdr rgn2 handler]) rgn2 handler)) (do
    
    [make-function-relocation-section relocations (" .rela.text) lkd-ehdr main-text-sec lkd-symtab-shdr rgn2 handler]
    
    (foreach (func-sec function-sections) (func-text-sec func-text-secs)
      (bind (name instrs relocs) func-sec
        [make-function-relocation-section relocs [rstrcat (" .rela.text.) name rgn2 handler]
          lkd-ehdr func-text-sec lkd-symtab-shdr rgn2 handler])))))
    
    (ignore Mark every symbol as false in preparation for the usage analysis.)
    
    (foreach (sec (@ lkde-sh lkd-ehdr))
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-symtab)]
        (foreach (sym (@ lkdsh-symtab sec))
          (setf lkdst-other sym (false))) (ignore)))
    
    (ignore
      Find relocations such that their symbol's section matches the target section,
      apply them, and remove them from the relocations list. For the relocations that
      remain, mark the symbols that they refer to.)
    
    (foreach (sec (@ lkde-sh lkd-ehdr))
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-rela)]
        (filter (lkd-rela (& lkdsh-rela sec))
          (let (rela (@ lkdr-raw lkd-rela))
          (let (addend (@ r-addend rela))
          (let (sym (@ lkdst-raw (@ lkdr-info-sym lkd-rela)))
          (if [= (@ lkdst-sh (@ lkdr-info-sym lkd-rela)) (@ lkdsh-rela-info sec)]
            (let (target [+ (@ r-offset rela) (@ lkdsh-offset (@ lkdsh-rela-info sec))]) (do
              [do-relocation target rela sym addend handler]
              (false)))
          (if [= (@ lkdst-sh (@ lkdr-info-sym lkd-rela)) lkd-bss-shdr]
            (do
              (setf r-addend rela [+ (@ st-value sym) addend])
              (setf lkdr-info-sym lkd-rela lkd-bss-sym)
              (true))
            (do
              (setf lkdst-other (@ lkdr-info-sym lkd-rela) (true))
              (true))))))))
        (ignore)))
    
    (ignore
      Filter all the symbol tables keeping only the symbols that are referred to
      in relocations or have non-local binding.)
    
    (setf lkdst-other lkd-und-sym (true))
    (setf lkdst-other lkd-bss-sym (true))
    
    (foreach (sec (@ lkde-sh lkd-ehdr))
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-symtab)]
        (filter (sym (& lkdsh-symtab sec))
          (or
            (@ lkdst-other sym)
            [not= (elf64-st-bind (@ st-info (@ lkdst-raw sym))) (stb-local)])) (ignore)))
    
    (ignore Assign the strings in the string table indicies.)
    
    (foreach (sec (@ lkde-sh lkd-ehdr))
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-strtab)]
        (fold (acc #0) (str (@ lkdsh-strtab sec)) (do
          (setf lkdstrt-ndx str acc)
          [+ acc [+ #1 [strlen (@ lkdstrt-raw str)]]])) (ignore)))
    
    (ignore Give each section an index.)
    
    (fold (idx #0) (sec (storage-cons lkd-undef-shdr (@ lkde-sh lkd-ehdr)))
      (do (setf lkdsh-ndx sec idx) [+ idx #1]))
    
    (ignore Substitute into ELF Section sh-names and sh-links, and sh-infos if possible.)
    
    (foreach (sec (@ lkde-sh lkd-ehdr)) (do
      (setf sh-link (@ lkdsh-raw sec) (@ lkdsh-ndx (@ lkdsh-link sec)))
      (setf sh-name (@ lkdsh-raw sec) (@ lkdstrt-ndx (@ lkdsh-name sec)))
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-rela)]
        (setf sh-info (@ lkdsh-raw sec) (@ lkdsh-ndx (@ lkdsh-rela-info sec)))
        (ignore))))
    
    (ignore Substitute into ELF Header e-shstrndx, e-shnum, and e-shoff)
    
    (setf e-shstrndx (@ lkde-raw lkd-ehdr) (@ lkdsh-ndx (@ lkde-shstr lkd-ehdr)))
    (setf e-shnum (@ lkde-raw lkd-ehdr) [+ [length (@ lkde-sh lkd-ehdr)] #1])
    (setf e-shoff (@ lkde-raw lkd-ehdr) (elf64-ehdr))
    
    (ignore Assign the symbols in each symbol table consecutive indicies.)
    
    (foreach (sec (@ lkde-sh lkd-ehdr))
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-symtab)]
        (let (local-end-idx
            (fold (acc #0) (sym (@ lkdsh-symtab sec))
              (if [= (elf64-st-bind (@ st-info (@ lkdst-raw sym))) (stb-local)]
                (do (setf lkdst-ndx sym acc) [+ acc #1])
                acc))) (do
          (setf sh-info (@ lkdsh-raw sec) local-end-idx)
          (fold (acc local-end-idx) (sym (@ lkdsh-symtab sec))
            (if [= (elf64-st-bind (@ st-info (@ lkdst-raw sym))) (stb-local)]
              acc
              (do (setf lkdst-ndx sym acc) [+ acc #1]))))) (ignore)))
    
    (ignore Calculate the sizes of the individual sections.)
    
    (foreach (sec (@ lkde-sh lkd-ehdr))
      (switch = (@ sh-type (@ lkdsh-raw sec))
        ((sht-symtab) (setf sh-size (@ lkdsh-raw sec)
          [* [length (@ lkdsh-symtab sec)] (elf64-sym)]))
        ((sht-rela) (setf sh-size (@ lkdsh-raw sec)
          [* [length (@ lkdsh-rela sec)] (elf64-rela)]))
        ((sht-strtab) (setf sh-size (@ lkdsh-raw sec)
          (fold (acc #0) (str (@ lkdsh-strtab sec))
            [+ acc [+ #1 [strlen (@ lkdstrt-raw str)]]])))
        (ignore)))
    
    (ignore Substitute into symbol table entry shndxs and names.)
    
    (foreach (sec (@ lkde-sh lkd-ehdr))
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-symtab)] (do
        (foreach (sym (@ lkdsh-symtab sec)) (do
          (setf st-shndx (@ lkdst-raw sym) (@ lkdsh-ndx (@ lkdst-sh sym)))
          (setf st-name (@ lkdst-raw sym) (@ lkdstrt-ndx (@ lkdst-name sym)))))) (ignore)))
    
    (ignore Substitute into relocation r-info.syms.)
    
    (foreach (sec (@ lkde-sh lkd-ehdr))
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-rela)]
        (foreach (rela (@ lkdsh-rela sec))
          (setf r-info (@ lkdr-raw rela) (elf64-r-info
            (@ lkdst-ndx (@ lkdr-info-sym rela))
            (elf64-r-type (@ r-info (@ lkdr-raw rela)))))) (ignore)))
    
    (ignore Assign an offset to each section and record ELF size.)
    
    (let (elf-size [pad-size (fold (offset [+ (elf64-ehdr) [* (elf64-shdr) [+ [length (@ lkde-sh lkd-ehdr)] #1]]])
        (sec (@ lkde-sh lkd-ehdr)) (do
      (setf sh-offset (@ lkdsh-raw sec) offset)
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-nobits)]
        offset
        [+ offset [pad-size (@ sh-size (@ lkdsh-raw sec)) (write-elf-alignment)]]))) (write-elf-alignment)]) (do
    
    (ignore Write out the ELF file.)
    
    (let (pos (storage _ #0))
    (let (bin [buffer-alloc elf-size rgn1 handler]) (do
    [mem-write bin pos (@ lkde-raw lkd-ehdr) (elf64-ehdr)]
    (foreach (sec (storage-cons lkd-undef-shdr (@ lkde-sh lkd-ehdr)))
      [mem-write bin pos (@ lkdsh-raw sec) (elf64-shdr)])
    (foreach (sec (@ lkde-sh lkd-ehdr)) (do
      (switch = (@ sh-type (@ lkdsh-raw sec))
        ((sht-symtab) (do
          (foreach (sym (@ lkdsh-symtab sec))
            (if [= (elf64-st-bind (@ st-info (@ lkdst-raw sym))) (stb-local)]
              [mem-write bin pos (@ lkdst-raw sym) (elf64-sym)] (ignore)))
          (foreach (sym (@ lkdsh-symtab sec))
            (if [= (elf64-st-bind (@ st-info (@ lkdst-raw sym))) (stb-local)] (ignore)
              [mem-write bin pos (@ lkdst-raw sym) (elf64-sym)]))))
        ((sht-rela)
          (foreach (rela (@ lkdsh-rela sec))
            [mem-write bin pos (@ lkdr-raw rela) (elf64-rela)]))
        ((sht-strtab)
          (foreach (str (@ lkdsh-strtab sec))
            [mem-write bin pos (@ lkdstrt-raw str) [+ [strlen (@ lkdstrt-raw str)] #1]]))
        ((sht-nobits) (ignore))
        [mem-write bin pos (@ lkdsh-offset sec) (@ sh-size (@ lkdsh-raw sec))])
      [set pos [pad-size $pos (write-elf-alignment)]]))
    
    (values (use-storage outs) bin $pos)))))))))))))))))))))))))))))))))))))))))

(ignore
  Converts the offsets of the static bindings associated with L2 source code that has now
  been loaded into addresses. asms is a list of assembly expressions containing bindings
  that need to be converted. bindings is a list of augmented bindings corresponding to the
  assembly expressions that also need to be converted.)

(constrain binding-offsets-to-addresses
  (\ r (with-vars (a) (`(function ((list instr) (list (values string (list instr) (list reloc))) (list bndg-aug) obj buffer ,a) ())r)r)))

(function binding-offsets-to-addresses (asms function-sections static-bindings obj reg hdl)
  (with-buffer reg (do
    (foreach (sym static-bindings)
      (if (and [= (@ bndg-storage sym) (absolute-storage)] [= (@ bndg-state sym) (defined-state)])
        [set+ (& bndg-offset sym) [segment obj (" .bss)]]
        (ignore)))
    
    (foreach (l asms)
      (let (instr-bndg (@ instr-binding l))
        (if [not= instr-bndg null-binding]
          [set+ (& bndg-offset instr-bndg) [segment obj (" .text)]]
          (ignore))))
    
    (foreach (func-sec function-sections)
      (bind (name instrs relocs) func-sec
        (foreach (l instrs)
          (let (instr-bndg (@ instr-binding l))
            (if [not= instr-bndg null-binding]
              [set+ (& bndg-offset instr-bndg) [segment obj [rstrcat (" .text.) name reg hdl]]]
              (ignore)))))))))
