(ignore A complete description for bindings that will be put into generated object files.)

  (function binding-aug (l r) [=# #80 r])

  (function bndg-name (l r) [property #0 #8 (\ r (`(; static~ string bndg-aug)r)) l r])

  (function bndg-offset (l r) [property #8 #8 (\ r (with-vars (a) (`(; static~ ,a bndg-aug)r)r)) l r])

  (function bndg-size (l r) [property #16 #8 (\ r (with-vars (a) (`(; static~ ,a bndg-aug)r)r)) l r])

  (function bndg-expression (l r) [property #24 #8 (\ r (with-vars (a) (`(; static~ (expr ,a) bndg-aug)r)r)) l r])

  (function bndg-other (l r) [property #32 #8 (\ r (with-vars (a) (`(; static~ ,a bndg-aug)r)r)) l r])
  
  (function bndg-propagate (l r) [property #40 #8 (\ r (with-vars (a) (`(; static~ (expr ,a) bndg-aug)r)r)) l r])
  
  (function bndg-signature (l r) [property #48 #8 (\ r (`(; static~ frag bndg-aug)r)) l r])
  
  (function bndg-preferred-offset (l r) [property #56 #8 (\ r (with-vars (a) (`(; static~ ,a bndg-aug)r)r)) l r])
  
  (function bndg-condition-jump (l r) [property #64 #8 (\ r (`(; static~ instr-code bndg-aug)r)) l r])

  (function bndg-storage (l r) [property #72 #1 (\ r (`(; static~ bndg-storage bndg-aug)r)) l r])

  (function bndg-scope (l r) [property #73 #1 (\ r (`(; static~ bndg-scope bndg-aug)r)) l r])

  (function bndg-state (l r) [property #74 #1 (\ r (`(; static~ bndg-state bndg-aug)r)) l r])
  
  (function bndg-context (l r) [property #75 #1 (\ r (`(; static~ bndg-context bndg-aug)r)) l r])
  
  (function bndg-preferred-storage (l r) [property #76 #1 (\ r (`(; static~ bndg-storage bndg-aug)r)) l r])
  
  (function bndg-mode (l r) [property #77 #1 (\ r (`(; static~ bndg-mode bndg-aug)r)) l r])
  
  (function bndg-is-read (l r) [property #78 #1 (\ r (with-vars (a) (`(; static~ ,a bndg-aug)r)r)) l r])
  
  (function bndg-is-condition (l r) [property #79 #1 (\ r (with-vars (a) (`(; static~ ,a bndg-aug)r)r)) l r])

(ignore Valid values for bndg-storage)

  (function absolute-storage (l r) [=## #0 (\ r (` bndg-storage r)) r])

  (function frame-relative-storage (l r) [=## #1 (\ r (` bndg-storage r)) r])
  
  (function register-storage (l r) [=## #2 (\ r (` bndg-storage r)) r])

  (function nil-storage (l r) [=## #3 (\ r (` bndg-storage r)) r])

(ignore Valid values for bndg-scope)

  (function local-scope (l r) [=## #0 (\ r (` bndg-scope r)) r])

  (function global-scope (l r) [=## #1 (\ r (` bndg-scope r)) r])

(ignore Valid values for bndg-state)

  (function undefined-state (l r) [=## #0 (\ r (` bndg-state r)) r])

  (function defined-state (l r) [=## #1 (\ r (` bndg-state r)) r])

(ignore Valid values for bndg-context)

  (function intra-function-context (l r) [=## #0 (\ r (` bndg-context r)) r])

  (function extra-function-context (l r) [=## #1 (\ r (` bndg-context r)) r])

(ignore Valid values for bndg-mode)

  (function value-mode (l r) [=## #0 (\ r (` bndg-mode r)) r])

  (function reference-mode (l r) [=## #1 (\ r (` bndg-mode r)) r])

(ignore A complete representation for L2 expressions as they are found in L2 source files.)

  (function expression (l r) [=# #120 r])
  
  (function expr-new (l r) [property #0 #0 (\ r (with-vars (a) (`(; dynamic~ (expr ,a) (expr ()))r)r)) l r])

  (function expr-type (l r) [property #0 #8 (\ r (with-vars (a) (`(; static~ expr-type (expr ,a))r)r)) l r])

  (function expr-fragment (l r) [property #8 #8 (\ r (with-vars (a) (`(; static~ frag (expr ,a))r)r)) l r])

  (function expr-meta (l r) [property #16 #8 (\ r (with-vars (a) (`(; static~ (expr ,a) (expr ,a))r)r)) l r])

  (function expr-lowlink (l r) [property #32 #8 (\ r (with-vars (a b) (`(; static~ ,b (expr ,a))r)r)) l r])

  (function expr-dependencies (l r) [property #40 #8 (\ r (with-vars (a) (`(; static~ (list (expr ,a)) (expr ,a))r)r)) l r])
  
  (function expr-binding-aug (l r) [property #48 #8 (\ r (with-vars (a) (`(; static~ bndg-aug (expr ,a))r)r)) l r])
  
  (function expr-generator (l r) [property #56 #8 (\ r (with-vars (a) (`(; static~ generator (expr ,a))r)r)) l r])
  
  (function expr-depth (l r) [property #64 #8 (\ r (with-vars (a b) (`(; static~ ,a (expr ,b))r)r)) l r])

(ignore Only for type(s) (-storage-) (-invoke-) (-jump-))

  (function expr-arguments (l r) [property #80 #8 (\ r (with-vars (a) (`(; static~ (list (expr ,a)) (expr ,a))r)r)) l r])

(ignore Only for type(s) (-storage-) (-function-) (-continuation-) (-with-) (-symbol-))

  (function expr-reference (l r) [property #72 #8 (\ r (with-vars (a) (`(; static~ bndg-aug (expr ,a))r)r)) l r])

(ignore Only for type(s) (-invoke-) (-jump-) (-meta-) (-constrain-))

  (function expr-target (l r) [property #72 #8 (\ r (with-vars (a) (`(; static~ (expr ,a) (expr ,a))r)r)) l r])

(ignore Only for type(s) (-jump-))

  (function expr-short-circuit (l r) [property #104 #8 (\ r (with-vars (a b) (`(; static~ ,a (expr ,b))r)r)) l r])

(ignore Only for type(s) (-if-))

  (function expr-condition (l r) [property #72 #8 (\ r (with-vars (a) (`(; static~ (expr ,a) (expr ,a))r)r)) l r])

  (function expr-consequent (l r) [property #80 #8 (\ r (with-vars (a) (`(; static~ (expr ,a) (expr ,a))r)r)) l r])

  (function expr-alternate (l r) [property #88 #8 (\ r (with-vars (a) (`(; static~ (expr ,a) (expr ,a))r)r)) l r])

(ignore Only for type(s) (-literal-))

  (function expr-value (l r) [property #72 #8 (\ r (with-vars (a b) (`(; static~ ,a (expr ,b))r)r)) l r])

(ignore Only for type(s) (-function-) (-continuation-) (-with-) (-constrain-))

  (function expr-expression (l r) [property #80 #8 (\ r (with-vars (a) (`(; static~ (expr ,a) (expr ,a))r)r)) l r])

(ignore Only for type(s) (-function-) (-continuation-) (-with-))

  (function expr-parameters (l r) [property #88 #8 (\ r (with-vars (a) (`(; static~ (list bndg-aug) (expr ,a))r)r)) l r])

(ignore Only for type(s) (-function-))
  
  (function expr-frame-size (l r) [property #96 #8 (\ r (with-vars (a b) (`(; static~ ,a (expr ,b))r)r)) l r])
  
  (function expr-registers-used (l r) [property #104 #8 (\ r (with-vars (a) (`(; static~ reg-use-vec (expr ,a))r)r)) l r])

(ignore Only for type(s) (-continuation-) (-with-))

  (function expr-cont-instr-bndg (l r) [property #96 #8 (\ r (with-vars (a b) (`(; static~ ,a (expr ,b))r)r)) l r])

  (function expr-escapes (l r) [property #104 #8 (\ r (with-vars (a b) (`(; static~ ,a (expr ,b))r)r)) l r])
  
  (function expr-jumps (l r) [property #112 #8 (\ r (with-vars (a) (`(; static~ (list (expr ,a)) (expr ,a))r)r)) l r])

(ignore Only for type(s) (-symbol-))

  (function expr-name (l r) [property #80 #8 (\ r (with-vars (a) (`(; static~ string (expr ,a))r)r)) l r])

(ignore Valid values for expr-type.)

  (function -storage- (l r) [=## #0 (\ r (` expr-type r)) r])

  (function -function- (l r) [=## #1 (\ r (` expr-type r)) r])

  (function -with- (l r) [=## #2 (\ r (` expr-type r)) r])

  (function -invoke- (l r) [=## #3 (\ r (` expr-type r)) r])

  (function -if- (l r) [=## #4 (\ r (` expr-type r)) r])

  (function -literal- (l r) [=## #6 (\ r (` expr-type r)) r])

  (function -symbol- (l r) [=## #7 (\ r (` expr-type r)) r])

  (function -jump- (l r) [=## #8 (\ r (` expr-type r)) r])

  (function -continuation- (l r) [=## #9 (\ r (` expr-type r)) r])

  (function -meta- (l r) [=## #11 (\ r (` expr-type r)) r])

  (function -constrain- (l r) [=## #12 (\ r (` expr-type r)) r])

(ignore
  Convenience functions for making L2 expressions. They save you from having
  to construct parameter and argument lists separately from the construction of
  the expression.)

(ignore Usage (make-functionN ref-expr (param-exprs ...) expr frag meta buf handler))

(function make-functionN (l r)
  [lllllst (` invoke r) (` make-function r) [@fst l] [list [lst [@frst l] [@rrrrrst l] r] r]
    [@frrst l] [@rrrst l] r])

(ignore Analogous to above.)

(function make-continuationN (l r)
  [lllllst (` invoke r) (` make-continuation r) [@fst l] [list [lst [@frst l] [@rrrrrst l] r] r]
    [@frrst l] [@rrrst l] r])

(ignore Usage (make-jumpN ref-expr (arg-exprs ...) frag meta buf handler))

(function make-jumpN (l r)
  [llllst (` invoke r) (` make-jump r) [@fst l] [list [lst [@frst l] [@rrrrst l] r] r] [@rrst l] r])

(ignore Analogous to above.)

(function make-invokeN (l r)
  [llllst (` invoke r) (` make-invoke r) [@fst l] [list [lst [@frst l] [@rrrrst l] r] r] [@rrst l] r])

(ignore Constant against which the length of a literal expression is checked.)

(function build-expression-literal-len (l r) [=# #64 r])

(constrain null-expr (\ r (with-vars (a) (` (expr ,a) r)r)))

(storage null-expr (ignore))

(storage null-binding (ignore))

(constrain make-binding-aug
  (\ r (with-vars (a b) (`(function (bndg-mode bndg-context bndg-storage bndg-scope bndg-state string frag (expr ,b) region ,a) bndg-aug)r)r)))

(function make-binding-aug (mode context stg scope state name sig expression r handler)
  (substitute (.. r handler)
    (record (_[region-alloc (binding-aug) ..])
      (bndg-context context)
      (bndg-storage stg)
      (bndg-scope scope)
      (bndg-state state)
      (bndg-name name)
      (bndg-signature sig)
      (bndg-expression expression)
      (bndg-propagate null-expr)
      (bndg-preferred-storage (nil-storage))
      (bndg-is-read (false))
      (bndg-mode mode)
      (bndg-is-condition (false))
      (bndg-condition-jump (x86-nop)))))

(constrain set-expr-is-read (\ r (with-vars (a b) (`(function ((expr ,b) ,a) ())r)r)))

(function set-expr-is-read (expr val) (do
  (setf bndg-is-read (@ expr-binding-aug expr) val)
  (ignore)))

(constrain bndg-depth (\ r (with-vars (a) (`(function (bndg-aug) ,a)r)r)))

(function bndg-depth (bndg) (@ expr-depth (@ bndg-expression bndg)))

(constrain expr-binding-depth (\ r (with-vars (a b) (`(function ((expr ,b)) ,a)r)r)))

(function expr-binding-depth (expr) [bndg-depth (@ expr-binding-aug expr)])

(constrain make-literal (\ r (with-vars (a b c) (`(function (,a frag (expr ,c) region ,b) (expr ()))r)r)))

(function make-literal (value frag meta reg handler)
  (substitute (.. reg handler)
    (record (t [region-alloc (expression) ..])
      (expr-type (-literal-))
      (expr-fragment frag)
      (expr-meta meta)
      (expr-lowlink #0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] t ..])
      (expr-value value))))

(constrain make-symbol (\ r (with-vars (a b) (`(function (string frag (expr ,a) region ,b) (expr ()))r)r)))

(function make-symbol (name frag meta reg handler)
  (substitute (.. reg handler)
    (record (sym [region-alloc (expression) ..])
      (expr-type (-symbol-))
      (expr-fragment frag)
      (expr-meta meta)
      (expr-lowlink #0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] sym ..])
      (expr-name name)
      (expr-reference null-binding))))

(ignore
  Makes an undefined binding with the given name. Internally, a storage expression is made
  to be the target of the symbol so as to enable type inferencing on symbols using this
  binding.)

(constrain make-undefined-binding (\ r (with-vars (b) (`(function (string region ,b) bndg-aug)r)r)))

(function make-undefined-binding (name r handler)
  (substitute (.. r handler)
    (let (stg [make-storage name nil null-fragment null-expr ..])
    (record (bndg (@ expr-reference stg))
      (bndg-context (extra-function-context))
      (bndg-storage (absolute-storage))
      (bndg-scope (global-scope))
      (bndg-state (undefined-state))))))

(constrain expr-signature (\ r (with-vars (a) (`(function ((expr ,a)) frag)r)r)))

(function expr-signature (expr) (@ bndg-signature (@ expr-binding-aug expr)))

(constrain make-function (\ r (with-vars (a b) (`(function (string (list string) (expr ,a) frag (expr ,a) region ,b) (expr ()))r)r)))

(function make-function (ref params expr frag meta reg handler)
  (substitute (.. reg handler)
    (record (func [region-alloc (expression) ..])
      (expr-type (-function-))
      (expr-fragment frag)
      (expr-meta meta)
      (expr-lowlink #0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] func ..])
      (expr-reference
        [make-binding-aug (reference-mode) (extra-function-context) (absolute-storage) (local-scope)
          (defined-state) ref [vbl->frag [vbl ..]] func ..])
      (expr-parameters
        (map (param params)
          [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
            (defined-state) param [vbl->frag [vbl ..]] func ..] ..))
      (expr-expression expr))))

(constrain make-continuation (\ r (with-vars (a b) (`(function (string (list string) (expr ,a) frag (expr ,a) region ,b) (expr ()))r)r)))

(function make-continuation (ref params expr frag meta reg handler)
  (substitute (.. reg handler)
    (record (cont [region-alloc (expression) ..])
      (expr-type (-continuation-))
      (expr-fragment frag)
      (expr-meta meta)
      (expr-lowlink #0)
      (expr-dependencies nil)
      (expr-jumps nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] cont ..])
      (expr-cont-instr-bndg
        [make-binding-aug (reference-mode) (extra-function-context) (absolute-storage) (local-scope)
          (defined-state) empty-string null-fragment null-expr ..])
      (expr-reference
        [make-binding-aug (reference-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) ref [vbl->frag [vbl ..]] cont ..])
      (expr-parameters
        (map (param params)
          [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
            (defined-state) param [vbl->frag [vbl ..]] cont ..] ..))
      (expr-escapes (false))
      (expr-expression expr))))

(constrain make-with (\ r (with-vars (a b) (`(function (string (expr ,a) frag (expr ,a) region ,b) (expr ()))r)r)))

(function make-with (ref expr frag meta reg handler)
  (substitute (.. reg handler)
    (record (wth [region-alloc (expression) ..])
      (expr-type (-with-))
      (expr-fragment frag)
      (expr-meta meta)
      (expr-lowlink #0)
      (expr-dependencies nil)
      (expr-jumps nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] wth ..])
      (expr-cont-instr-bndg
        [make-binding-aug (reference-mode) (extra-function-context) (absolute-storage) (local-scope)
          (defined-state) empty-string null-fragment null-expr ..])
      (expr-reference
        [make-binding-aug (reference-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) ref [vbl->frag [vbl ..]] wth ..])
      (expr-parameters [cons
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] wth ..] nil ..])
      (expr-escapes (false))
      (expr-expression expr))))

(constrain make-jump (\ r (with-vars (a b) (`(function ((expr ,a) (list (expr ,a)) frag (expr ,a) region ,b) (expr ()))r)r)))

(function make-jump (ref args frag meta reg handler)
  (substitute (.. reg handler)
    (record (u [region-alloc (expression) ..])
      (expr-type (-jump-))
      (expr-fragment frag)
      (expr-meta meta)
      (expr-lowlink #0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] u ..])
      (expr-short-circuit null-expr)
      (expr-target ref)
      (expr-arguments args))))

(constrain make-storage (\ r (with-vars (a b) (`(function (string (list (expr ,a)) frag (expr ,a) region ,b) (expr ()))r)r)))

(function make-storage (ref args frag meta reg handler)
  (substitute (.. reg handler)
    (record (u [region-alloc (expression) ..])
      (expr-type (-storage-))
      (expr-fragment frag)
      (expr-meta meta)
      (expr-lowlink #0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] u ..])
      (expr-reference
        [make-binding-aug (reference-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) ref [vbl->frag [vbl ..]] u ..])
      (expr-arguments args))))

(constrain make-meta (\ r (with-vars (a b) (`(function ((expr ,a) frag (expr ,a) region ,b) (expr ()))r)r)))

(function make-meta (ref frag meta reg handler)
  (substitute (.. reg handler)
    (record (u [region-alloc (expression) ..])
      (expr-type (-meta-))
      (expr-meta meta)
      (expr-lowlink #0)
      (expr-dependencies nil)
      (expr-binding-aug null-binding)
      (expr-target ref)
      (expr-fragment frag))))

(constrain make-constrain (\ r (with-vars (a b) (`(function ((expr ,a) (expr ,a) frag (expr ,a) region ,b) (expr ()))r)r)))

(function make-constrain (expr ref frag meta reg handler)
  (substitute (.. reg handler)
    (record (u [region-alloc (expression) ..])
      (expr-type (-constrain-))
      (expr-fragment frag)
      (expr-meta meta)
      (expr-lowlink #0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] u ..])
      (expr-target ref)
      (expr-expression expr))))

(constrain make-if (\ r (with-vars (a b) (`(function ((expr ,a) (expr ,a) (expr ,a) frag (expr ,a) region ,b) (expr ()))r)r)))

(function make-if (condition consequent alternate frag meta reg handler)
  (substitute (.. reg handler)
    (record (u [region-alloc (expression) ..])
      (expr-type (-if-))
      (expr-fragment frag)
      (expr-meta meta)
      (expr-lowlink #0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] u ..])
      (expr-condition condition)
      (expr-consequent consequent)
      (expr-alternate alternate))))

(constrain make-invoke (\ r (with-vars (a b) (`(function ((expr ,a) (list (expr ,a)) frag (expr ,a) region ,b) (expr ()))r)r)))

(function make-invoke (ref args frag meta reg handler)
  (substitute (.. reg handler)
    (record (u [region-alloc (expression) ..])
      (expr-type (-invoke-))
      (expr-fragment frag)
      (expr-meta meta)
      (expr-lowlink #0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] u ..])
      (expr-target ref)
      (expr-arguments args))))

(ignore Prints the given expression as it would be written in an L2 source file. s is an expression.)

(function print-binding (bndg hdl) (substitute (.. hdl)
  (if [getb (@ bndg-name bndg)]
    [print-str (stdout) (@ bndg-name bndg) ..]
    (do
      [print-str (stdout) (" (lparen)binding(space)) ..]
      [print-uint (stdout) bndg ..]
      [print-str (stdout) (" (rparen)) ..]))))

(constrain print-expression (\ r (with-vars (a b) (`(function ((expr ,b) ,a) ())r)r)))

(function print-expression (s hdl) (substitute (.. hdl)
  (switch = (@ expr-type s)
    ((-with-) (do
      [print-str (stdout) (" (lparen)with(space)) ..]
      [print-binding (@ expr-reference s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-expression s) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-storage-) (do
      [print-str (stdout) (" (lparen)storage(space)) ..]
      [print-binding (@ expr-reference s) ..]
      [print-str (stdout) (" (space)) ..]
      (foreach (t (@ expr-arguments s)) (do
        [print-expression t ..]
        [print-str (stdout) (" (space)) ..]))
      [print-str (stdout) (" (bs)) ..]
      [print-str (stdout) (switch = (@ expr-type s)
        ((-invoke-) (" (rbracket)))
        ((-jump-) (" (rbrace)))
        (" (rbracket))) ..]))
    
    ((-invoke-) (-jump-) (do
      [print-str (stdout) (switch = (@ expr-type s)
        ((-invoke-) (" (lbracket)))
        ((-jump-) (" (lbrace)))
        (ignore)) ..]
      [print-expression (@ expr-target s) ..]
      [print-str (stdout) (" (space)) ..]
      (foreach (t (@ expr-arguments s)) (do
        [print-expression t ..]
        [print-str (stdout) (" (space)) ..]))
      [print-str (stdout) (" (bs)) ..]
      [print-str (stdout) (switch = (@ expr-type s)
        ((-invoke-) (" (rbracket)))
        ((-jump-) (" (rbrace)))
        (" (rbracket))) ..]))
    
    ((-function-) (-continuation-) (do
      [print-str (stdout) (" (lparen)) ..]
      [print-str (stdout) (switch = (@ expr-type s)
        ((-function-) (" function))
        ((-continuation-) (" continuation))
        (ignore)) ..]
      [print-str (stdout) (" (space)) ..]
      [print-binding (@ expr-reference s) ..]
      [print-str (stdout) (" (space)(lparen)(space)) ..]
      (foreach (t (@ expr-parameters s)) (do
        [print-binding t ..]
        [print-str (stdout) (" (space)) ..]))
      [print-str (stdout) (" (rparen)(space)) ..]
      [print-expression (@ expr-expression s) ..]
      [print-str (stdout) (" (rparen)) ..]))
      
    ((-if-) (do
      [print-str (stdout) (" (lparen)if(space)) ..]
      [print-expression (@ expr-condition s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-consequent s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-alternate s) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-constrain-) (do
      [print-str (stdout) (" (lparen)constrain(space)) ..]
      [print-expression (@ expr-expression s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-fragment (@ bndg-signature (@ expr-binding-aug s)) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-symbol-)
      (if [getb (@ expr-name s)]
        [print-str (stdout) (@ expr-name s) ..]
        [print-binding (@ expr-reference s) ..]))
          
    ((-literal-) (do
      [print-str (stdout) (" (lparen)literal(space)) ..]
      [print-uint (stdout) (@ expr-value s) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-meta-) [print-fragment (@ expr-fragment s) ..])
      
    (ignore))))

(storage special-form-error (ignore))

(ignore
  Builds an expression from a given program fragment. d is the program fragment.
  reg is the region into which the built expressions will be put. The return value
  is the constructed expression. The continuation handler will be followed with the
  tuple (special-form-error, ...) in the event of a malformed expression.)

(constrain build-expression (\ r (with-vars (a b) (`(function (frag (expr ,b) region ,a) (expr ()))r)r)))

(function build-expression (frag meta reg handler) (substitute (.. reg handler)
  (if [i/f:token? frag] [make-symbol [to-string [fragment->token frag] ..] frag meta ..]
  (let (d [frag->list frag])
    (if [= [length d] #0] {handler (storage _ special-form-error d null-fragment)}
    (switch str= [to-string [fragment->token [@car d]] ..]
      ((" with)
        (if (not [= [length d] #3])
          {handler (storage _ special-form-error d null-fragment)}
        (if (not [i/f:token? [@cadr d]])
          {handler (storage _ special-form-error d [@cadr d])}
          [make-with [to-string [fragment->token [@cadr d]] ..] [build-expression [@caddr d] meta ..] frag meta ..])))
      
      ((" if)
        (if (not [= [length d] #4])
          {handler (storage _ special-form-error d null-fragment)}
          [make-if [build-expression [@cadr d] meta ..] [build-expression [@caddr d] meta ..]
            [build-expression [@cadddr d] meta ..] frag meta ..]))
      
      ((" function) (" continuation)
        (if (not [= [length d] #4])
          {handler (storage _ special-form-error d null-fragment)}
        (if (not [i/f:token? [@cadr d]])
          {handler (storage _ special-form-error d [@cadr d])}
        (if [i/f:token? [@caddr d]]
          {handler (storage _ special-form-error d [@caddr d])}
          (let (parameters (map (v [frag->list [@caddr d]])
              (if [i/f:token? v]
                [to-string [fragment->token v] ..]
                {handler (storage _ special-form-error d v)}) ..))
                
            [(switch str= [to-string [fragment->token [@car d]] ..]
                ((" function) make-function)
                ((" continuation) make-continuation)
                (ignore))
              [to-string [fragment->token [@cadr d]] ..] parameters [build-expression [@cadddr d] meta ..] frag meta ..])))))
      
      ((" storage)
        (if [= [length d] #1]
          {handler (storage _ special-form-error d null-fragment)}
        (if (cand [str= [to-string [fragment->token [@car d]] ..] (" storage)] (not [i/f:token? [@cadr d]]))
          {handler (storage _ special-form-error d [@cadr d])}
          [make-storage
            [to-string [fragment->token [@cadr d]] ..] (map (v [@cddr d]) [build-expression v meta ..] ..) frag meta ..])))
      
      ((" invoke) (" jump)
        (if [= [length d] #1]
          {handler (storage _ special-form-error d null-fragment)}
        (if (cand [str= [to-string [fragment->token [@car d]] ..] (" storage)] (not [i/f:token? [@cadr d]]))
          {handler (storage _ special-form-error d [@cadr d])}
          [(switch str= [to-string [fragment->token [@car d]] ..]
              ((" invoke) make-invoke)
              ((" jump) make-jump)
              (ignore))
            [build-expression [@cadr d] meta ..] (map (v [@cddr d]) [build-expression v meta ..] ..) frag meta ..])))
      
      ((" literal)
        (if (not [= [length d] #2])
          {handler (storage _ special-form-error d null-fragment)}
        (if (cor (not [i/f:token? [@cadr d]]) (not [= [length [frag->list [@cadr d]]] (build-expression-literal-len)]))
          {handler (storage _ special-form-error d [@cadr d])}
          [make-literal
            (loop build-num (str [to-string [fragment->token [@cadr d]] ..]) (i (build-expression-literal-len)) (value #0)
              (if [= i #0]
                value
              (if [= [getb str] (char 1)]
                {build-num [+ str #1] [- i #1] [+ [<< value #1] #1]}
              (if [= [getb str] (char 0)]
                {build-num [+ str #1] [- i #1] [<< value #1]}
                {handler (storage _ special-form-error d [@cadr d])})))) frag meta ..])))
      
      ((" constrain)
        (if (not [= [length d] #3])
          {handler (storage _ special-form-error d null-fragment)}
          [make-constrain [build-expression [@cadr d] meta ..] [build-expression [@caddr d] meta ..] frag meta ..]))
      
      [make-meta [build-expression [@car d] meta ..] frag meta ..]))))))

(ignore
  Make a unary function with the given name that calls an undefined function of the same
  name with the same arguments that it received. The idea is that the intrinsic generators
  will replace the function call with inline assembly.)

(constrain make-unary-intrinsic (\ r (with-vars (a b) (`(function (string region ,a) (expr ,b))r)r)))

(function make-unary-intrinsic (name buf handler)
  (substitute (.. buf handler)
    (let (callee-symbol [make-symbol empty-string null-fragment null-expr ..])
        (arg-a [make-symbol empty-string null-fragment null-expr ..])
      (let (func (make-functionN name (empty-string)
          (make-invokeN callee-symbol (arg-a) null-fragment null-expr ..) null-fragment null-expr ..)) (do
        (setf expr-reference callee-symbol [make-undefined-binding name ..])
        (setf expr-reference arg-a [@car (@ expr-parameters func)])
        func)))))

(ignore Performs actions analogous to make-unary-intrinsic, but for binary functions.)

(constrain make-binary-intrinsic (\ r (with-vars (a b) (`(function (string region ,a) (expr ,b))r)r)))

(function make-binary-intrinsic (name buf handler)
  (substitute (.. buf handler)
    (let (callee-symbol [make-symbol empty-string null-fragment null-expr ..])
        (arg-a [make-symbol empty-string null-fragment null-expr ..])
        (arg-b [make-symbol empty-string null-fragment null-expr ..])
      (let (func (make-functionN name (empty-string empty-string)
          (make-invokeN callee-symbol (arg-a arg-b) null-fragment null-expr ..) null-fragment null-expr ..)) (do
        (setf expr-reference callee-symbol [make-undefined-binding name ..])
        (setf expr-reference arg-a [@car (@ expr-parameters func)])
        (setf expr-reference arg-b [@cadr (@ expr-parameters func)])
        func)))))

