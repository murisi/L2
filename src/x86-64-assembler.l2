(-- The constants to be used in x86-64-assembler.l2)

(constant write-elf-sh-count #:7 \:r:[var r])

(constant write-elf-alignment #:8 \:r:[var r])

(constant write-elf-max-instr-len #:15 \:r:[var r])

(-- A representation of an object code relocation.)

  (constant relocation #:40 \:r:[var r])

  (property reloc-type #:0 #:8 (\ r (`(! static~ reloc-type reloc)r)))

  (property reloc-operand #:8 #:8 (\ r (`(! static~ operand reloc)r)))

  (property reloc-binding #:16 #:8 (\ r (`(! static~ bndg-aug reloc)r)))
  
  (property reloc-context #:24 #:8 (\ r (`(! static~ (,[var r]) reloc)r)))
  
  (-- reloc-addend-func takes as its arguments context, operand location, operand size,
    instruction location, instruction size, and computes an addend for the relocation.)
    
  (property reloc-addend-func #:32 #:8 (\ r (?(a b c d e f) (`(! static~ (function (,:f ,:b ,:c ,:d ,:e) ,:a) reloc)r)r)))

(define x86 (++ (sub (X x86) (module

  (-- A representation of an instruction.)

    (instruction (constant instruction #:24 \:r:[var r]))

    (instr-code (property instr-code #:0 #:8 (\ r (`(! static~ instr-code instr)r))))
    
    (instr-operands (property instr-operands #:8 #:8 (\ r (`(! static~ (list operand) instr)r))))
    
    (instr-binding (property instr-binding #:16 #:8 (\ r (`(! static~ bndg-aug instr)r))))

  (-- x86-64 instruction codes.)
    
    (label (constant label #:33 \:r:(` instr-code r)))

    (lea (constant x86-lea #:17 \:r:(` instr-code r)))

    (mov (constant x86-mov #:18 \:r:(` instr-code r)))

    (jmp (constant x86-jmp #:19 \:r:(` instr-code r)))
    
    (movzx (constant x86-movzx #:20 \:r:(` instr-code r)))

    (push (constant x86-push #:21 \:r:(` instr-code r)))

    (sub (constant x86-sub #:23 \:r:(` instr-code r)))

    (add (constant x86-add #:24 \:r:(` instr-code r)))

    (pop (constant x86-pop #:25 \:r:(` instr-code r)))

    (leave (constant x86-leave #:26 \:r:(` instr-code r)))

    (ret (constant x86-ret #:27 \:r:(` instr-code r)))

    (or (constant x86-or #:30 \:r:(` instr-code r)))

    (call (constant x86-call #:32 \:r:(` instr-code r)))
    
    (mul (constant x86-mul #:38 \:r:(` instr-code r)))
    
    (shl (constant x86-shl #:39 \:r:(` instr-code r)))
    
    (shr (constant x86-shr #:40 \:r:(` instr-code r)))
    
    (and (constant x86-and #:41 \:r:(` instr-code r)))
    
    (not (constant x86-not #:42 \:r:(` instr-code r)))
    
    (xor (constant x86-xor #:44 \:r:(` instr-code r)))
    
    (div (constant x86-div #:47 \:r:(` instr-code r)))
    
    (setz (constant x86-setz #:48 \:r:(` instr-code r)))
    
    (setc (constant x86-setc #:49 \:r:(` instr-code r)))
    
    (setb (constant x86-setb #:49 \:r:(` instr-code r)))
    
    (nop (constant x86-nop #:50 \:r:(` instr-code r)))
    
    (cmp (constant x86-cmp #:51 \:r:(` instr-code r)))
    
    (je (constant x86-je #:29 \:r:(` instr-code r)))
    
    (jz (constant x86-jz #:29 \:r:(` instr-code r)))
    
    (jnz (constant x86-jnz #:52 \:r:(` instr-code r)))
    
    (jne (constant x86-jne #:52 \:r:(` instr-code r)))
    
    (jnc (constant x86-jnc #:53 \:r:(` instr-code r)))
    
    (jae (constant x86-jae #:53 \:r:(` instr-code r)))
    
    (jnb (constant x86-jnb #:53 \:r:(` instr-code r)))
    
    (seta (constant x86-seta #:54 \:r:(` instr-code r)))
    
    (jbe (constant x86-jbe #:55 \:r:(` instr-code r)))
    
    (jna (constant x86-jna #:55 \:r:(` instr-code r)))
    
    (jnae (constant x86-jnae #:56 \:r:(` instr-code r)))
    
    (jb (constant x86-jb #:56 \:r:(` instr-code r)))
    
    (jc (constant x86-jc #:56 \:r:(` instr-code r)))
    
    (jnbe (constant x86-jnbe #:57 \:r:(` instr-code r)))
    
    (ja (constant x86-ja #:57 \:r:(` instr-code r)))

  (-- A representation of an operand.)
    
    (operand (constant operand #:64 \:r:[var r]))
    
    (op-type (property op-type #:0 #:8 (\ r (`(! static~ operand-type operand)r))))
    
    (op-size (property op-size #:8 #:8 (\ r (`(! static~ (,[var r]) operand)r))))
    
    (op-locations (property op-locations #:16 #:8 (\ r (?(a b c d) (`(! static~ (list (values ,:a ,:b ,:c ,:d)) operand)r)r))))

  (-- Only for type(s) (register-operand))

    (op-register (property op-register #:24 #:8 (\ r (`(! static~ register operand)r))))

  (-- Only for type(s) (immediate-operand))

    (op-immediate (property op-immediate #:24 #:8 (\ r (`(! static~ (,[var r]) operand)r))))

  (-- Only for type(s) (memory-operand))

    (op-base (property op-base #:24 #:8 \:r:(`(! static~ register operand)r)))
    
    (op-index (property op-index #:32 #:8 \:r:(`(! static~ register operand)r)))
    
    (op-scale (property op-scale #:40 #:8 \:r:(`(! static~ ,:[var r] operand)r)))
    
    (op-disp (property op-disp #:48 #:8 \:r:(`(! static~ ,:[var r] operand)r)))
    
    (op-disp-size (property op-disp-size #:56 #:8 \:r:(`(! static~ ,:[var r] operand)r)))

  (-- x86-64 operand types.)

    (register-operand (constant register-operand #:0 (\ r (` operand-type r))))
    
    (immediate-operand (constant immediate-operand #:1 (\ r (` operand-type r))))
    
    (memory-operand (constant memory-operand #:2 (\ r (` operand-type r))))
    
    (none-operand (constant none-operand #:3 (\ r (` operand-type r))))

  (-- x86-64 registers.)
    
    (r/m8 (constant r/m8 [<< #:1 #:5] \:r:[var r]))
    
    (r/m16 (constant r/m16 [<< #:1 #:6] \:r:[var r]))
    
    (r/m32 (constant r/m32 [<< #:1 #:7] \:r:[var r]))
    
    (r/m64 (constant r/m64 [<< #:1 #:8] \:r:[var r]))
    
    (w/rex (constant w/rex [<< #:1 #:9] \:r:[var r]))
    
    (w/orex (constant w/orex [<< #:1 #:10] \:r:[var r]))
    
    (none (constant none #:17 \:r:(` register r)))
    
    (/0 (constant x86-/0 [bor #:0(X:r/m32)] \:r:(` register r)))

    (/1 (constant x86-/1 [bor #:1(X:r/m32)] \:r:(` register r)))

    (/2 (constant x86-/2 [bor #:2(X:r/m32)] \:r:(` register r)))

    (/3 (constant x86-/3 [bor #:3(X:r/m32)] \:r:(` register r)))

    (/4 (constant x86-/4 [bor #:4(X:r/m32)] \:r:(` register r)))

    (/5 (constant x86-/5 [bor #:5(X:r/m32)] \:r:(` register r)))

    (/6 (constant x86-/6 [bor #:6(X:r/m32)] \:r:(` register r)))

    (/7 (constant x86-/7 [bor #:7(X:r/m32)] \:r:(` register r)))

    (al (constant al [bor #:0(X:r/m8)] \:r:(` register r)))

    (cl (constant cl [bor #:1(X:r/m8)] \:r:(` register r)))

    (dl (constant dl [bor #:2(X:r/m8)] \:r:(` register r)))

    (bl (constant bl [bor #:3(X:r/m8)] \:r:(` register r)))

    (ah (constant ah [bor #:4(X:r/m8)] \:r:(` register r)))

    (ch (constant ch [bor #:5(X:r/m8)] \:r:(` register r)))

    (dh (constant dh [bor #:6(X:r/m8)] \:r:(` register r)))

    (bh (constant bh [bor #:7(X:r/m8)] \:r:(` register r)))
    
    (spl (constant spl [bor [bor #:4(X:r/m8)] (X:w/rex)] \:r:(` register r)))

    (bpl (constant bpl [bor [bor #:5(X:r/m8)] (X:w/rex)] \:r:(` register r)))

    (sil (constant sil [bor [bor #:6(X:r/m8)] (X:w/rex)] \:r:(` register r)))

    (dil (constant dil [bor [bor #:7(X:r/m8)] (X:w/rex)] \:r:(` register r)))

    (r8l (constant r8l [bor [bor #:8(X:r/m8)] (X:w/rex)] \:r:(` register r)))

    (r9l (constant r9l [bor [bor #:9(X:r/m8)] (X:w/rex)] \:r:(` register r)))

    (r10l (constant r10l [bor [bor #:10(X:r/m8)] (X:w/rex)] \:r:(` register r)))

    (r11l (constant r11l [bor [bor #:11(X:r/m8)] (X:w/rex)] \:r:(` register r)))

    (r12l (constant r12l [bor [bor #:12(X:r/m8)] (X:w/rex)] \:r:(` register r)))

    (r13l (constant r13l [bor [bor #:13(X:r/m8)] (X:w/rex)] \:r:(` register r)))

    (r14l (constant r14l [bor [bor #:14(X:r/m8)] (X:w/rex)] \:r:(` register r)))

    (r15l (constant r15l [bor [bor #:15(X:r/m8)] (X:w/rex)] \:r:(` register r)))
    
    (ax (constant ax [bor #:0(X:r/m16)] \:r:(` register r)))

    (cx (constant cx [bor #:1(X:r/m16)] \:r:(` register r)))

    (dx (constant dx [bor #:2(X:r/m16)] \:r:(` register r)))

    (bx (constant bx [bor #:3(X:r/m16)] \:r:(` register r)))

    (sp (constant sp [bor #:4(X:r/m16)] \:r:(` register r)))

    (bp (constant bp [bor #:5(X:r/m16)] \:r:(` register r)))

    (si (constant si [bor #:6(X:r/m16)] \:r:(` register r)))

    (di (constant di [bor #:7(X:r/m16)] \:r:(` register r)))
    
    (r8w (constant r8w [bor [bor #:8(X:r/m16)] (X:w/rex)] \:r:(` register r)))

    (r9w (constant r9w [bor [bor #:9(X:r/m16)] (X:w/rex)] \:r:(` register r)))

    (r10w (constant r10w [bor [bor #:10(X:r/m16)] (X:w/rex)] \:r:(` register r)))

    (r11w (constant r11w [bor [bor #:11(X:r/m16)] (X:w/rex)] \:r:(` register r)))

    (r12w (constant r12w [bor [bor #:12(X:r/m16)] (X:w/rex)] \:r:(` register r)))

    (r13w (constant r13w [bor [bor #:13(X:r/m16)] (X:w/rex)] \:r:(` register r)))

    (r14w (constant r14w [bor [bor #:14(X:r/m16)] (X:w/rex)] \:r:(` register r)))

    (r15w (constant r15w [bor [bor #:15(X:r/m16)] (X:w/rex)] \:r:(` register r)))
    
    (eax (constant eax [bor #:0(X:r/m32)] \:r:(` register r)))

    (ecx (constant ecx [bor #:1(X:r/m32)] \:r:(` register r)))

    (edx (constant edx [bor #:2(X:r/m32)] \:r:(` register r)))

    (ebx (constant ebx [bor #:3(X:r/m32)] \:r:(` register r)))

    (esp (constant esp [bor #:4(X:r/m32)] \:r:(` register r)))

    (ebp (constant ebp [bor #:5(X:r/m32)] \:r:(` register r)))

    (esi (constant esi [bor #:6(X:r/m32)] \:r:(` register r)))

    (edi (constant edi [bor #:7(X:r/m32)] \:r:(` register r)))
    
    (r8d (constant r8d [bor [bor #:8(X:r/m32)] (X:w/rex)] \:r:(` register r)))

    (r9d (constant r9d [bor [bor #:9(X:r/m32)] (X:w/rex)] \:r:(` register r)))

    (r10d (constant r10d [bor [bor #:10(X:r/m32)] (X:w/rex)] \:r:(` register r)))

    (r11d (constant r11d [bor [bor #:11(X:r/m32)] (X:w/rex)] \:r:(` register r)))

    (r12d (constant r12d [bor [bor #:12(X:r/m32)] (X:w/rex)] \:r:(` register r)))

    (r13d (constant r13d [bor [bor #:13(X:r/m32)] (X:w/rex)] \:r:(` register r)))

    (r14d (constant r14d [bor [bor #:14(X:r/m32)] (X:w/rex)] \:r:(` register r)))

    (r15d (constant r15d [bor [bor #:15(X:r/m32)] (X:w/rex)] \:r:(` register r)))
    
    (rax (constant rax [bor [bor #:0(X:r/m64)] (X:w/rex)] \:r:(` register r)))

    (rcx (constant rcx [bor [bor #:1(X:r/m64)] (X:w/rex)] \:r:(` register r)))

    (rdx (constant rdx [bor [bor #:2(X:r/m64)] (X:w/rex)] \:r:(` register r)))

    (rbx (constant rbx [bor [bor #:3(X:r/m64)] (X:w/rex)] \:r:(` register r)))

    (rsp (constant rsp [bor [bor #:4(X:r/m64)] (X:w/rex)] \:r:(` register r)))

    (rbp (constant rbp [bor [bor #:5(X:r/m64)] (X:w/rex)] \:r:(` register r)))

    (rsi (constant rsi [bor [bor #:6(X:r/m64)] (X:w/rex)] \:r:(` register r)))

    (rdi (constant rdi [bor [bor #:7(X:r/m64)] (X:w/rex)] \:r:(` register r)))

    (r8 (constant r8 [bor [bor #:8(X:r/m64)] (X:w/rex)] \:r:(` register r)))

    (r9 (constant r9 [bor [bor #:9(X:r/m64)] (X:w/rex)] \:r:(` register r)))

    (r10 (constant r10 [bor [bor #:10(X:r/m64)] (X:w/rex)] \:r:(` register r)))

    (r11 (constant r11 [bor [bor #:11(X:r/m64)] (X:w/rex)] \:r:(` register r)))

    (r12 (constant r12 [bor [bor #:12(X:r/m64)] (X:w/rex)] \:r:(` register r)))

    (r13 (constant r13 [bor [bor #:13(X:r/m64)] (X:w/rex)] \:r:(` register r)))

    (r14 (constant r14 [bor [bor #:14(X:r/m64)] (X:w/rex)] \:r:(` register r)))

    (r15 (constant r15 [bor [bor #:15(X:r/m64)] (X:w/rex)] \:r:(` register r)))
    
    (rip (constant rip [bor [bor #:16(X:r/m64)] (X:w/rex)] \:r:(` register r)))))))

(-- Defined to enable the x64 registers to be indexed dynamically.)

(sub (X x86) (storage x64-r64s
  (X:rax)(X:rcx)(X:rdx)(X:rbx)(X:rsp)(X:rbp)(X:rsi)(X:rdi)(X:r8)(X:r9)(X:r10)(X:r11)(X:r12)(X:r13)(X:r14)(X:r15)))

(-- Usage (make-instrN opcode (ops ...) buf handler))

(function make-instrN (l r)
  `:[make-instruction ,:[@fst l] (list ,:[@rrst l] , [@frst l]) , [@rrst l]]:r)

(constrain make-instruction (\ r (?(b) (`(function (instr-code (list operand) region ,:b) instr)r)r)))

(function make-instruction (code operands reg handler)
  (sub (X x86)
    (let (u [region-alloc (X:instruction) reg handler]) (do
      (setf X:instr-code u code)
      (setf X:instr-operands u operands)
      (setf X:instr-binding u null-binding)
      u))))

(constrain make-relocation (\ r (?(a b c) (`(function (reloc-type operand bndg-aug ,:c ,:a region ,:b) reloc)r)r)))

(function make-relocation (type operand binding ctx addend-func buf handler)
  (sub (.. buf handler)
    (let (r [region-alloc (relocation) ..]) (do
      (setf reloc-type r type)
      (setf reloc-operand r operand)
      (setf reloc-binding r binding)
      (setf reloc-context r ctx)
      (setf reloc-addend-func r addend-func)
      r))))

(constrain register-size (\ r (?(a) (`(function (register) ,:a)r)r)))

(function register-size (reg)
  (sub (X x86)
    (if [band reg(X:r/m8)] #:1
    (if [band reg(X:r/m16)] #:2
    (if [band reg(X:r/m32)] #:4
    (if [band reg(X:r/m64)] #:8
      (~)))))))

(constrain make-reg-op (\ r (?(a) (`(function (register region ,:a) operand)r)r)))

(function make-reg-op (reg buf handler)
  (sub (X x86) (.. buf handler)
    (let (op [region-alloc (X:operand) ..]) (do
      (setf X:op-type op (X:register-operand))
      (setf X:op-size op [register-size reg])
      (setf X:op-register op reg)
      (setf X:op-locations op nil)
      op))))

(constrain make-imm-op (\ r (?(a b c) (`(function (,:b ,:c region ,:a) operand)r)r)))

(function make-imm-op (op-size imm buf handler)
  (sub (X x86) (.. buf handler)
    (let (op [region-alloc (X:operand) ..]) (do
      (setf X:op-type op (X:immediate-operand))
      (setf X:op-size op op-size)
      (setf X:op-immediate op imm)
      (setf X:op-locations op nil)
      op))))

(constrain make-none-op (\ r (?(a) (`(function (region ,:a) operand)r)r)))

(function make-none-op (buf handler)
  (sub (X x86) (.. buf handler)
    (let (op [region-alloc (X:operand) ..]) (do
      (setf X:op-type op (X:none-operand))
      (setf X:op-size op #:0)
      op))))

(constrain make-mem-op (\ r (?(a b c d e) (`(function (,:a register register ,:b ,:c ,:d region ,:e) operand)r)r)))

(function make-mem-op (op-size base index scale disp disp-size buf handler)
  (sub (X x86) (.. buf handler)
    (let (op [region-alloc (X:operand) ..]) (do
      (setf X:op-type op (X:memory-operand))
      (setf X:op-size op op-size)
      (setf X:op-base op base)
      (setf X:op-index op index)
      (setf X:op-scale op scale)
      (setf X:op-disp op disp)
      (setf X:op-disp-size op disp-size)
      (setf X:op-locations op nil)
      op))))

(constrain reg-lower-8 (\ r (`(function (register) register)r)))

(function reg-lower-8 (reg) (sub (X x86) (switch = reg
  ((X:ah)(X:ah)) ((X:bh)(X:bh)) ((X:ch)(X:ch)) ((X:dh)(X:dh)) ((X:al)(X:al)) ((X:bl)(X:bl)) ((X:cl)(X:cl)) ((X:dl)(X:dl))
  ((X:dil)(X:dil)) ((X:sil)(X:sil)) ((X:bpl) (X:bpl)) ((X:spl)(X:spl)) ((X:r8l)(X:r8l)) ((X:r9l)(X:r9l)) ((X:r10l)(X:r10l))
  ((X:r11l)(X:r11l)) ((X:r12l)(X:r12l)) ((X:r13l)(X:r13l)) ((X:r14l)(X:r14l)) ((X:r15l)(X:r15l)) ((X:ax)(X:al))
  ((X:bx)(X:bl)) ((X:cx)(X:cl)) ((X:dx)(X:dl)) ((X:di)(X:dil)) ((X:si)(X:sil)) ((X:bp)(X:bpl)) ((X:sp)(X:spl)) ((X:r8w)(X:r8l))
  ((X:r9w)(X:r9l)) ((X:r10w)(X:r10l)) ((X:r11w)(X:r11l)) ((X:r12w)(X:r12l)) ((X:r13w)(X:r13l)) ((X:r14w)(X:r14l))
  ((X:r15w)(X:r15l)) ((X:eax)(X:al)) ((X:ebx)(X:bl)) ((X:ecx)(X:cl)) ((X:edx)(X:dl)) ((X:edi)(X:dl)) ((X:esi)(X:sil))
  ((X:ebp)(X:bpl)) ((X:esp)(X:spl)) ((X:r8d)(X:r8l)) ((X:r9d)(X:r9l)) ((X:r10d)(X:r10l)) ((X:r11d)(X:r11l))
  ((X:r12d)(X:r12l)) ((X:r13d)(X:r13l)) ((X:r14d)(X:r14l)) ((X:r15d)(X:r15l)) ((X:rax)(X:al)) ((X:rbx)(X:bl))
  ((X:rcx)(X:cl)) ((X:rdx)(X:dl)) ((X:rdi)(X:dil)) ((X:rsi)(X:sil)) ((X:rbp)(X:bpl)) ((X:rsp)(X:spl)) ((X:r8)(X:r8l))
  ((X:r9)(X:r9l)) ((X:r10)(X:r10l)) ((X:r11)(X:r11l)) ((X:r12)(X:r12l)) ((X:r13)(X:r13l)) ((X:r14)(X:r14l))
  ((X:r15)(X:r15l)) (~))))

(constrain op-lower-8 (\ r (?(a) (`(function (operand region ,:a) operand)r)r)))

(function op-lower-8 (op buf handler)
  (sub (X x86) (.. buf handler)
    (switch = (@ X:op-type op)
      ((X:register-operand) [make-reg-op [reg-lower-8 (@ X:op-register op)] ..])
      ((X:immediate-operand) [make-imm-op #:1 (@ X:op-immediate op) ..])
      ((X:memory-operand) [make-mem-op #:1 (@ X:op-base op) (@ X:op-index op) (@ X:op-scale op)
        (@ X:op-disp op) (@ X:op-disp-size op) ..])
      (~))))

(constrain reg-lower-16 (\ r (`(function (register) register)r)))

(function reg-lower-16 (reg) (sub (X x86) (switch = reg
  ((X:ax)(X:ax)) ((X:bx)(X:bx)) ((X:cx)(X:cx)) ((X:dx)(X:dx)) ((X:di)(X:di)) ((X:si)(X:si)) ((X:bp)(X:bp)) ((X:sp)(X:sp))
  ((X:r8w)(X:r8w)) ((X:r9w)(X:r9w)) ((X:r10w)(X:r10w)) ((X:r11w)(X:r11w)) ((X:r12w)(X:r12w)) ((X:r13w)(X:r13w))
  ((X:r14w)(X:r14w)) ((X:r15w)(X:r15w)) ((X:eax)(X:ax)) ((X:ebx)(X:bx)) ((X:ecx)(X:cx)) ((X:edx)(X:dx)) ((X:edi)(X:di))
  ((X:esi)(X:si)) ((X:ebp)(X:bp)) ((X:esp)(X:sp)) ((X:r8d)(X:r8w)) ((X:r9d)(X:r9w)) ((X:r10d)(X:r10w)) ((X:r11d)(X:r11w))
  ((X:r12d)(X:r12w)) ((X:r13d)(X:r13w)) ((X:r14d)(X:r14w)) ((X:r15d)(X:r15w)) ((X:rax)(X:ax)) ((X:rbx)(X:bx))
  ((X:rcx)(X:cx)) ((X:rdx)(X:dx)) ((X:rdi)(X:di)) ((X:rsi)(X:si)) ((X:rbp)(X:bp)) ((X:rsp)(X:sp)) ((X:r8)(X:r8w))
  ((X:r9)(X:r9w)) ((X:r10)(X:r10w)) ((X:r11)(X:r11w)) ((X:r12)(X:r12w)) ((X:r13)(X:r13w)) ((X:r14)(X:r14w))
  ((X:r15)(X:r15w)) (~))))

(constrain op-lower-16 (\ r (?(a) (`(function (operand region ,:a) operand)r)r)))

(function op-lower-16 (op buf handler)
  (sub (X x86) (.. buf handler)
    (switch = (@ X:op-type op)
      ((X:register-operand) [make-reg-op [reg-lower-16 (@ X:op-register op)] ..])
      ((X:immediate-operand) [make-imm-op #:2 (@ X:op-immediate op) ..])
      ((X:memory-operand) [make-mem-op #:2 (@ X:op-base op) (@ X:op-index op) (@ X:op-scale op)
        (@ X:op-disp op) (@ X:op-disp-size op) ..])
      (~))))

(constrain reg-lower-32 (\ r (`(function (register) register)r)))

(function reg-lower-32 (reg) (sub (X x86) (switch = reg
  ((X:eax)(X:eax)) ((X:ebx)(X:ebx)) ((X:ecx)(X:ecx)) ((X:edx)(X:edx)) ((X:edi)(X:edi)) ((X:esi)(X:esi)) ((X:ebp)(X:ebp))
  ((X:esp)(X:esp)) ((X:r8d)(X:r8d)) ((X:r9d)(X:r9d)) ((X:r10d)(X:r10d)) ((X:r11d)(X:r11d)) ((X:r12d)(X:r12d))
  ((X:r13d)(X:r13d)) ((X:r14d)(X:r14d)) ((X:r15d)(X:r15d)) ((X:rax)(X:eax)) ((X:rbx)(X:ebx)) ((X:rcx)(X:ecx))
  ((X:rdx)(X:edx)) ((X:rdi)(X:edi)) ((X:rsi)(X:esi)) ((X:rbp)(X:ebp)) ((X:rsp)(X:esp)) ((X:r8)(X:r8d)) ((X:r9)(X:r9d))
  ((X:r10)(X:r10d)) ((X:r11)(X:r11d)) ((X:r12)(X:r12d)) ((X:r13)(X:r13d)) ((X:r14)(X:r14d)) ((X:r15)(X:r15d))
  (~))))

(constrain op-lower-32 (\ r (?(a) (`(function (operand region ,:a) operand)r)r)))

(function op-lower-32 (op buf handler)
  (sub (X x86) (.. buf handler)
    (switch = (@ X:op-type op)
      ((X:register-operand) [make-reg-op [reg-lower-32 (@ X:op-register op)] ..])
      ((X:immediate-operand) [make-imm-op #:4 (@ X:op-immediate op) ..])
      ((X:memory-operand) [make-mem-op #:4 (@ X:op-base op) (@ X:op-index op) (@ X:op-scale op)
        (@ X:op-disp op) (@ X:op-disp-size op) ..])
      (~))))

(constrain reg-lower-64 (\ r (`(function (register) register)r)))

(function reg-lower-64 (reg) (sub (X x86) (switch = reg
  ((X:rax)(X:rax)) ((X:rbx)(X:rbx)) ((X:rcx)(X:rcx)) ((X:rdx)(X:rdx)) ((X:rdi)(X:rdi)) ((X:rsi)(X:rsi)) ((X:rbp)(X:rbp))
  ((X:rsp)(X:rsp)) ((X:r8)(X:r8)) ((X:r9)(X:r9)) ((X:r10)(X:r10)) ((X:r11)(X:r11)) ((X:r12)(X:r12)) ((X:r13)(X:r13))
  ((X:r14)(X:r14)) ((X:r15)(X:r15)) (~))))

(constrain op-lower-64 (\ r (?(a) (`(function (operand region ,:a) operand)r)r)))

(function op-lower-64 (op buf handler)
  (sub (X x86) (.. buf handler)
    (switch = (@ X:op-type op)
      ((X:register-operand) [make-reg-op [reg-lower-64 (@ X:op-register op)] ..])
      ((X:immediate-operand) [make-imm-op #:8 (@ X:op-immediate op) ..])
      ((X:memory-operand) [make-mem-op #:8 (@ X:op-base op) (@ X:op-index op) (@ X:op-scale op)
        (@ X:op-disp op) (@ X:op-disp-size op) ..])
      (~))))

(constrain print-instr-code (\ r (?(a) (`(function (instr-code ,:a) ())r)r)))

(function print-instr-code (code handler)
  [print-str (stdout) (switch = code
    ((x86:label) (" label)) ((x86:lea) (" lea)) ((x86:mov) (" mov)) ((x86:jmp) (" jmp))
    ((x86:movzx) (" movzx)) ((x86:push) (" push)) ((x86:sub) (" sub)) ((x86:add) (" add))
    ((x86:pop) (" pop)) ((x86:leave) (" leave)) ((x86:ret) (" ret)) ((x86:je) (" je))
    ((x86:or) (" or)) ((x86:call) (" call)) ((x86:mul) (" mul)) ((x86:shl) (" shl))
    ((x86:shr) (" shr)) ((x86:and) (" and)) ((x86:not) (" not)) ((x86:xor) (" xor))
    ((x86:div) (" div)) ((x86:setz) (" setz)) ((x86:setc) (" setc)) ((x86:jae) (" jae))
    ((x86:jne) (" jne)) ((x86:cmp) (" cmp)) ((x86:seta) (" seta)) ((x86:jbe) (" jbe))
    ((x86:ja) (" ja)) ((x86:jb) (" jb)) (~)) handler])

(constrain print-register (\ r (?(a) (`(function (register ,:a) ())r)r)))

(function print-register (reg handler) (sub (X x86)
  [print-str (stdout) (switch = reg
    ((X:none)(" (lparen)none(rparen))) ((X:al)(" al)) ((X:cl)(" cl)) ((X:dl)(" dl)) ((X:bl)(" bl))
    ((X:ah)(" ah)) ((X:ch)(" ch)) ((X:dh)(" dh)) ((X:bh)(" bh)) ((X:spl)(" spl)) ((X:bpl)(" bpl))
    ((X:sil)(" sil)) ((X:dil)(" dil)) ((X:r8l)(" r8l)) ((X:r9l)(" r9l)) ((X:r10l)(" r10l))
    ((X:r11l)(" r11l)) ((X:r12l)(" r12l)) ((X:r13l)(" r13l)) ((X:r14l)(" r14l)) ((X:r15l)(" r15l))  
    ((X:ax)(" ax)) ((X:cx)(" cx)) ((X:dx)(" dx)) ((X:bx)(" bx)) ((X:sp)(" sp)) ((X:bp)(" bp))
    ((X:si)(" si)) ((X:di)(" di)) ((X:r8w)(" r8w)) ((X:r9w)(" r9w)) ((X:r10w)(" r10w)) ((X:r11w)(" r11w))
    ((X:r12w)(" r12w)) ((X:r13w)(" r13w)) ((X:r14w)(" r14w)) ((X:r15w)(" r15w)) ((X:eax)(" eax))
    ((X:ecx)(" ecx)) ((X:edx)(" edx)) ((X:ebx)(" ebx)) ((X:esp)(" esp)) ((X:ebp)(" ebp))
    ((X:esi)(" esi)) ((X:edi)(" edi)) ((X:r8d)(" r8d)) ((X:r9d)(" r9d)) ((X:r10d)(" r10d))
    ((X:r11d)(" r11d)) ((X:r12d)(" r12d)) ((X:r13d)(" r13d)) ((X:r14d)(" r14d)) ((X:r15d)(" r15d))  
    ((X:rax)(" rax)) ((X:rcx)(" rcx)) ((X:rdx)(" rdx)) ((X:rbx)(" rbx)) ((X:rsp)(" rsp))
    ((X:rbp)(" rbp)) ((X:rsi)(" rsi)) ((X:rdi)(" rdi)) ((X:r8)(" r8)) ((X:r9)(" r9)) ((X:r10)(" r10))
    ((X:r11)(" r11)) ((X:r12)(" r12)) ((X:r13)(" r13)) ((X:r14)(" r14)) ((X:r15)(" r15))  
    ((X:rip)(" rip)) (~)) handler]))

(constrain print-operand (\ r (?(a) (`(function (operand ,:a) ())r)r)))

(function print-operand (op handler)
  (sub (X x86) (switch = (@ X:op-type op)
    ((X:register-operand)
      [print-register (@ X:op-register op) handler])
    ((X:immediate-operand)
      [print-uint (stdout) (@ X:op-immediate op) handler])
    ((X:memory-operand) (do
      [print-char (stdout) (lbracket) handler]
      (if [not= (@ X:op-base op) (X:none)]
        [print-register (@ X:op-base op) handler]
        (~))
      (if (and [not= (@ X:op-base op) (X:none)] [not= (@ X:op-index op) (X:none)])
        [print-str (stdout) ("(space)+(space)) handler]
        (~))
      (if [not= (@ X:op-index op) (X:none)] (do
        [print-register (@ X:op-index op) handler]
        [print-str (stdout) (" *) handler]
        [print-uint (stdout) (@ X:op-scale op) handler])
        (~))
      (if (and (or [not= (@ X:op-base op) (X:none)] [not= (@ X:op-index op) (X:none)])
          [not= (@ X:op-disp-size op) #:0])
        [print-str (stdout) ("(space)+(space)) handler]
        (~))
      (if [not= (@ X:op-disp-size op) #:0]
        [print-uint (stdout) (@ X:op-disp op) handler]
        (~))
      [print-char (stdout) (rbracket) handler]))
    ((X:none-operand)
      [print-str (stdout) ("(lparen)none(rparen)) handler])
    (~))))

(constrain print-instr (\ r (?(a) (`(function (instr ,:a) ())r)r)))

(function print-instr (instr handler)
  (sub (X x86) (do
    [print-instr-code (@ X:instr-code instr) handler]
    (if [nil? (@ X:instr-operands instr)] (~) (do
      [print-str (stdout) ("(space)) handler]
      [print-operand [@car (@ X:instr-operands instr)] handler]
      (for (op (%:list-iter [@cdr (@ X:instr-operands instr)])) (~) (do
        [print-str (stdout) (" ,(space)) handler]
        [print-operand op handler])))))))

(constrain mem-write (\ r (?(a b c d) (`(function (,:a !:Ref:,;b ,:c ,:d) ())r)r)))

(function mem-write (mem idx bytes cnt)
  (let (end [+ $:idx cnt])
  (loop write-bytes (bytes bytes)
    (if [= $:idx end] (~) (do
      [setb [+ mem $:idx] [getb bytes]]
      [set+ idx #:1]
      {write-bytes [+ bytes #:1]})))))

(constrain write-instr
  (\ r (?(a b c d e f) (`(function (,:a !:Ref:,;b ,:c ,:d operand operand operand operand region ,:f) ,:e)r)r)))

(function write-instr (bin pos opcode opcode-size opcode.reg-op modrm.reg-op modrm.rm-op imm-op buf handler)
  (sub (X x86) (.. buf handler)
    (let (modrm.rm-op-code [band
      (if [= (@ X:op-type modrm.rm-op) (X:register-operand)] (@ X:op-register modrm.rm-op)
      (if [= (@ X:op-type modrm.rm-op) (X:memory-operand)] (@ X:op-base modrm.rm-op) (~))) #:7])
    
    (let (modrm.reg-op-code [band (@ X:op-register modrm.reg-op) #:7])
    
    (let (opcode [+ opcode
      (if [= (@ X:op-type opcode.reg-op) (X:register-operand)] [band (@ X:op-register opcode.reg-op) #:7] #:0)])
    
    (let (has-modrm? (or [not= (@ X:op-type modrm.reg-op) (X:none-operand)] [not= (@ X:op-type modrm.rm-op) (X:none-operand)]))
    
    (let (modrm.mod
      (if [= (@ X:op-type modrm.rm-op) (X:register-operand)] #:3
      (if (or [= (@ X:op-disp-size modrm.rm-op) #:0] [= (@ X:op-base modrm.rm-op) (X:none)] [= (@ X:op-base modrm.rm-op) (X:rip)]) #:0
      (if [= (@ X:op-disp-size modrm.rm-op) #:1] #:1
      (if [= (@ X:op-disp-size modrm.rm-op) #:4] #:2 (~))))))
    
    (let (has-sib? (and [= (@ X:op-type modrm.rm-op) (X:memory-operand)]
      (or [not= (@ X:op-index modrm.rm-op) (X:none)] [= modrm.rm-op-code [band (X:rsp) #:7]]
        (and [= modrm.rm-op-code [band (X:rbp) #:7]] [= (@ X:op-disp-size modrm.rm-op) #:0]))))
    
    (let (modrm.rm
      (if [= (@ X:op-type modrm.rm-op) (X:register-operand)] modrm.rm-op-code
      (if has-sib? #:4
      (if [= (@ X:op-base modrm.rm-op) (X:none)] #:5
      (if [= (@ X:op-base modrm.rm-op) (X:rip)] #:5
        modrm.rm-op-code)))))
    
    (let (modrm.reg modrm.reg-op-code)
            
    (let (sib.scale (switch = (@ X:op-scale modrm.rm-op) (#:1 #:0) (#:2 #:1) (#:4 #:2) (#:8 #:3) (~)))
    
    (let (sib.index (if [= (@ X:op-index modrm.rm-op) (X:none)] #:4 (@ X:op-index modrm.rm-op)))
    
    (let (sib.base (if (or [= (@ X:op-base modrm.rm-op) (X:none)]) #:5 modrm.rm-op-code))
    
    (let (has-rex? (or [band [bor (@ X:op-register modrm.reg-op) [bor (@ X:op-register modrm.rm-op) (@ X:op-register opcode.reg-op)]] (X:w/rex)]
      (and [= (@ X:op-type modrm.rm-op) (X:memory-operand)] (or
        (and [not= (@ X:op-base modrm.rm-op) (X:none)] [= [register-size (@ X:op-base modrm.rm-op)] #:8])
        (and [not= (@ X:op-index modrm.rm-op) (X:none)] [= [register-size (@ X:op-index modrm.rm-op)] #:8])
        [= (@ X:op-disp-size modrm.rm-op) #:8]))))
    
    (let (rex.w (if (or [= (@ X:op-size modrm.reg-op) #:8] [= (@ X:op-size modrm.rm-op) #:8] [= (@ X:op-size opcode.reg-op) #:8]) #:1 #:0))
    
    (let (rex.r (if (and [= (@ X:op-type modrm.reg-op) (X:register-operand)] [band (@ X:op-register modrm.reg-op) #:8]) #:1 #:0))
    
    (let (rex.x (if (and [= (@ X:op-type modrm.rm-op) (X:memory-operand)] [not= (@ X:op-index modrm.rm-op) (X:none)]
      [band (@ X:op-index modrm.rm-op) #:8]) #:1 #:0))
    
    (let (rex.b (if (or (and [= (@ X:op-type modrm.rm-op) (X:memory-operand)] [not= (@ X:op-base modrm.rm-op) (X:none)]
      [band (@ X:op-base modrm.rm-op) #:8]) (and [= (@ X:op-type modrm.rm-op) (X:register-operand)] [not= (@ X:op-register modrm.rm-op) (X:none)]
      [band (@ X:op-register modrm.rm-op) #:8]) (and [= (@ X:op-type opcode.reg-op) (X:register-operand)]
      [not= (@ X:op-register opcode.reg-op) (X:none)] [band (@ X:op-register opcode.reg-op) #:8])) #:1 #:0))
    
    (let (has-oso? [= [max (@ X:op-size modrm.reg-op) (@ X:op-size modrm.rm-op)] #:2])
    
    (let (has-aso? (and [= (@ X:op-type modrm.rm-op) (X:memory-operand)] (or
        (and [not= (@ X:op-base modrm.rm-op) (X:none)] [= [register-size (@ X:op-base modrm.rm-op)] #:2])
        (and [not= (@ X:op-index modrm.rm-op) (X:none)] [= [register-size (@ X:op-index modrm.rm-op)] #:2])
        [= (@ X:op-disp-size modrm.rm-op) #:2])))
    
    (let (instr-start-pos $:pos) (do
    
    (if has-oso? [mem-write bin pos (storage _ 0x:66) #:1] (~))
    
    (if has-aso? [mem-write bin pos (storage _ 0x:67) #:1] (~))
    
    (if has-rex?
      [mem-write bin pos (storage _
        [bor [<< #:4 #:4]
        [bor [<< rex.w #:3]
        [bor [<< rex.r #:2]
        [bor [<< rex.x #:1]
        [bor [<< rex.b #:0]
          #:0]]]]]) #:1] (~))
          
    [mem-write bin pos (storage _ opcode) opcode-size]
    
    (if has-modrm? (do
      [mem-write bin pos (storage _
        [bor [<< modrm.mod #:6]
        [bor [<< modrm.reg #:3]
        [bor [<< modrm.rm #:0]
          #:0]]]) #:1]
      
      (if has-sib?
        [mem-write bin pos (storage _
          [bor [<< sib.scale #:6]
          [bor [<< sib.index #:3]
          [bor [<< sib.base #:0]
            #:0]]]) #:1] (~)))
            
      (~))
    
    (let (disp-pos $:pos) (do
    
    (if [= (@ X:op-type modrm.rm-op) (X:memory-operand)]
      [mem-write bin pos (storage _ (@ X:op-disp modrm.rm-op)) (@ X:op-disp-size modrm.rm-op)]
      (~))
    
    (let (imm-pos $:pos) (do
    
    (if [= (@ X:op-type imm-op) (X:immediate-operand)]
      [mem-write bin pos (storage _ (@ X:op-immediate imm-op)) (@ X:op-size imm-op)]
      (~))
    
    (let (instr-size [- $:pos instr-start-pos]) (do
    
    (if [= (@ X:op-type modrm.rm-op) (X:memory-operand)]
      [prepend (values (region-storage ..) disp-pos (@ X:op-disp-size modrm.rm-op) instr-start-pos instr-size)
        (& X:op-locations modrm.rm-op) ..]
      (~))
    
    (if [= (@ X:op-type imm-op) (X:immediate-operand)]
      [prepend (values (region-storage ..) imm-pos (@ X:op-size imm-op) instr-start-pos instr-size) (& X:op-locations imm-op) ..]
      (~))
    
    (true)))))))))))))))))))))))))))))

(constrain write-nm-instr (\ r (?(f g h i) (`(function (instr ,:f !:Ref:,;g region ,:h) ,:i)r)r)))

(function write-nm-instr (n bin pos buf handler)
  (sub (X x86) (.. buf handler)
    ((list-prefix?
        (property? (X:op-type (|[= (X:none-operand)])))) (@ X:instr-operands n)
      (true) (false))))

(constrain write-mr-instr (\ r (?(a b c d e f g h i) (`(function (,:a ,:b ,:c ,:d ,:e instr ,:f !:Ref:,;g region ,:h) ,:i)r)r)))

(function write-mr-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 n bin pos buf handler)
  (sub (X x86) (.. buf handler)
    ((list-prefix?
        (and? .:op1 (property? (X:op-type (or? (|[= (X:memory-operand)]) (|[= (X:register-operand)])))))
        (and? .:op2 (property? (X:op-type (|[= (X:register-operand)])))))
      (@ X:instr-operands n)
        (if (and [band mask #:1] [= (@ X:op-size op1) #:1] [= (@ X:op-size op2) #:1])
          [write-instr bin pos opcode-8 [>> mask #:4] [make-none-op ..] op2 op1 [make-none-op ..] ..]
        (if (and [band mask #:2] [= (@ X:op-size op1) #:2] [= (@ X:op-size op2) #:2])
          [write-instr bin pos opcode-16 [>> mask #:4] [make-none-op ..] op2 op1 [make-none-op ..] ..]
        (if (and [band mask #:4] [= (@ X:op-size op1) #:4] [= (@ X:op-size op2) #:4])
          [write-instr bin pos opcode-32 [>> mask #:4] [make-none-op ..] op2 op1 [make-none-op ..] ..]
        (if (and [band mask #:8] [= (@ X:op-size op1) #:8] [= (@ X:op-size op2) #:8])
          [write-instr bin pos opcode-64 [>> mask #:4] [make-none-op ..] op2 op1 [make-none-op ..] ..]
          (false)))))
        (false))))

(constrain write-rm-instr (\ r (?(a b c d e f g h i) (`(function (,:a ,:b ,:c ,:d ,:e instr ,:f !:Ref:,;g region ,:h) ,:i)r)r)))

(function write-rm-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 n bin pos buf handler)
  (sub (X x86) (.. buf handler)
    ((list-prefix?
        (and? .:op1 (property? (X:op-type (|[= (X:register-operand)]))))
        (and? .:op2 (property? (X:op-type (or? (|[= (X:memory-operand)]) (|[= (X:register-operand)]))))))
      (@ X:instr-operands n)
        (if (and [band mask #:1] [= (@ X:op-size op1) #:1] [= (@ X:op-size op2) #:1])
          [write-instr bin pos opcode-8 [>> mask #:4] [make-none-op ..] op1 op2 [make-none-op ..] ..]
        (if (and [band mask #:2] [= (@ X:op-size op1) #:2] [= (@ X:op-size op2) #:2])
          [write-instr bin pos opcode-16 [>> mask #:4] [make-none-op ..] op1 op2 [make-none-op ..] ..]
        (if (and [band mask #:4] [= (@ X:op-size op1) #:4] [= (@ X:op-size op2) #:4])
          [write-instr bin pos opcode-32 [>> mask #:4] [make-none-op ..] op1 op2 [make-none-op ..] ..]
        (if (and [band mask #:8] [= (@ X:op-size op1) #:8] [= (@ X:op-size op2) #:8])
          [write-instr bin pos opcode-64 [>> mask #:4] [make-none-op ..] op1 op2 [make-none-op ..] ..]
          (false)))))
        (false))))

(constrain write-mi-instr (\ r (?(a b c d e f g h i) (`(function (,:a ,:b ,:c ,:d ,:e operand instr ,:f !:Ref:,;g region ,:h) ,:i)r)r)))

(function write-mi-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 opcode.reg-op n bin pos buf handler)
  (sub (X x86) (.. buf handler)
    ((list-prefix?
        (and? .:op1 (property? (X:op-type (or? (|[= (X:memory-operand)]) (|[= (X:register-operand)])))))
        (and? .:op2 (property? (X:op-type (|[= (X:immediate-operand)])))))
      (@ X:instr-operands n)
        (if (and [= (@ X:op-size op1) #:1] [= (@ X:op-size op2) #:1])
          [write-instr bin pos opcode-8 [>> mask #:4] [make-none-op ..] opcode.reg-op op1 op2 ..]
        (if (and [= (@ X:op-size op1) #:2] [= (@ X:op-size op2) #:2])
          [write-instr bin pos opcode-16 [>> mask #:4] [make-none-op ..] opcode.reg-op op1 op2 ..]
        (if (and [= (@ X:op-size op1) #:4] [= (@ X:op-size op2) #:4])
          [write-instr bin pos opcode-32 [>> mask #:4] [make-none-op ..] opcode.reg-op op1 op2 ..]
        (if (and [= (@ X:op-size op1) #:8] [= (@ X:op-size op2) #:4])
          [write-instr bin pos opcode-64 [>> mask #:4] [make-none-op ..] opcode.reg-op op1 op2 ..]
          (false)))))
        (false))))

(constrain write-mi8-instr (\ r (?(a b c d e f g h i) (`(function (,:a ,:b ,:c ,:d ,:e operand instr ,:f !:Ref:,;g region ,:h) ,:i)r)r)))

(function write-mi8-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 opcode.reg-op n bin pos buf handler)
  (sub (X x86) (.. buf handler)
    ((list-prefix?
        (and? .:op1 (property? (X:op-type (or? (|[= (X:memory-operand)]) (|[= (X:register-operand)])))))
        (and? .:op2 (property? (X:op-type (|[= (X:immediate-operand)])))))
      (@ X:instr-operands n)
        (if (and [band mask #:1] [= (@ X:op-size op1) #:1] [= (@ X:op-size op2) #:1])
          [write-instr bin pos opcode-8 [>> mask #:4] [make-none-op ..] opcode.reg-op op1 op2 ..]
        (if (and [band mask #:2] [= (@ X:op-size op1) #:2] [= (@ X:op-size op2) #:1])
          [write-instr bin pos opcode-16 [>> mask #:4] [make-none-op ..] opcode.reg-op op1 op2 ..]
        (if (and [band mask #:4] [= (@ X:op-size op1) #:4] [= (@ X:op-size op2) #:1])
          [write-instr bin pos opcode-32 [>> mask #:4] [make-none-op ..] opcode.reg-op op1 op2 ..]
        (if (and [band mask #:8] [= (@ X:op-size op1) #:8] [= (@ X:op-size op2) #:1])
          [write-instr bin pos opcode-64 [>> mask #:4] [make-none-op ..] opcode.reg-op op1 op2 ..]
          (false)))))
        (false))))

(constrain write-mm-instr (\ r (?(a b c d e f g h i) (`(function (,:a ,:b ,:c ,:d ,:e instr ,:f !:Ref:,;g region ,:h) ,:i)r)r)))

(function write-mm-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 n bin pos buf handler)
  (sub (X x86) (.. buf handler)
    ((list-prefix?
        (and? .:op1 (property? (X:op-type (|[= (X:memory-operand)]))))
        (and? .:op2 (property? (X:op-type (|[= (X:memory-operand)]))))
        .:op3)
      (@ X:instr-operands n)
        (if (and [band mask #:1] [= (@ X:op-size op1) #:1] [= (@ X:op-size op2) #:1]) (do
          [write-instr bin pos 0x:8A #:1 [make-none-op ..] op3 op2 [make-none-op ..] ..]
          [write-instr bin pos opcode-8 [>> mask #:4] [make-none-op ..] op3 op1 [make-none-op ..] ..])
        (if (and [band mask #:2] [= (@ X:op-size op1) #:2] [= (@ X:op-size op2) #:2]) (do
          [write-instr bin pos 0x:8B #:1 [make-none-op ..] op3 op2 [make-none-op ..] ..]
          [write-instr bin pos opcode-16 [>> mask #:4] [make-none-op ..] op3 op1 [make-none-op ..] ..])
        (if (and [band mask #:4] [= (@ X:op-size op1) #:4] [= (@ X:op-size op2) #:4]) (do
          [write-instr bin pos 0x:8B #:1 [make-none-op ..] op3 op2 [make-none-op ..] ..]
          [write-instr bin pos opcode-32 [>> mask #:4] [make-none-op ..] op3 op1 [make-none-op ..] ..])
        (if (and [band mask #:8] [= (@ X:op-size op1) #:8] [= (@ X:op-size op2) #:8]) (do
          [write-instr bin pos 0x:8B #:1 [make-none-op ..] op3 op2 [make-none-op ..] ..]
          [write-instr bin pos opcode-64 [>> mask #:4] [make-none-op ..] op3 op1 [make-none-op ..] ..])
          (false)))))
        (false))))

(constrain write-m-instr (\ r (?(a b c d e f g h i) (`(function (,:a ,:b ,:c ,:d ,:e operand instr ,:f !:Ref:,;g region ,:h) ,:i)r)r)))

(function write-m-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 opcode.reg-op n bin pos buf handler)
  (sub (X x86) (.. buf handler)
    ((list-prefix?
        (and? .:op1 (property? (X:op-type (or? (|[= (X:memory-operand)]) (|[= (X:register-operand)]))))))
      (@ X:instr-operands n)
        (if (and [band mask #:1] [= (@ X:op-size op1) #:1])
          [write-instr bin pos opcode-8 [>> mask #:4] [make-none-op ..] opcode.reg-op op1 [make-none-op ..] ..]
        (if (and [band mask #:2] [= (@ X:op-size op1) #:2])
          [write-instr bin pos opcode-16 [>> mask #:4] [make-none-op ..] opcode.reg-op op1 [make-none-op ..] ..]
        (if (and [band mask #:4] [= (@ X:op-size op1) #:4])
          [write-instr bin pos opcode-32 [>> mask #:4] [make-none-op ..] opcode.reg-op op1 [make-none-op ..] ..]
        (if (and [band mask #:8] [= (@ X:op-size op1) #:8])
          [write-instr bin pos opcode-64 [>> mask #:4] [make-none-op ..] opcode.reg-op op1 [make-none-op ..] ..]
          (false)))))
        (false))))

(constrain write-d-instr (\ r (?(a b c d e f g h i) (`(function (,:a ,:b ,:c ,:d ,:e instr ,:f !:Ref:,;g region ,:h) ,:i)r)r)))

(function write-d-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 n bin pos buf handler)
  (sub (X x86) (.. buf handler)
    ((list-prefix?
        (and? .:op1 (property? (X:op-type (|[= (X:immediate-operand)])))))
      (@ X:instr-operands n)
        (if (and [band mask #:1] [= (@ X:op-size op1) #:1])
          [write-instr bin pos opcode-8 [>> mask #:4] [make-none-op ..] [make-none-op ..] [make-none-op ..] op1 ..]
        (if (and [band mask #:2] [= (@ X:op-size op1) #:2])
          [write-instr bin pos opcode-16 [>> mask #:4] [make-none-op ..] [make-none-op ..] [make-none-op ..] op1 ..]
        (if (and [band mask #:4] [= (@ X:op-size op1) #:4])
          [write-instr bin pos opcode-32 [>> mask #:4] [make-none-op ..] [make-none-op ..] [make-none-op ..] op1 ..]
        (if (and [band mask #:8] [= (@ X:op-size op1) #:8])
          [write-instr bin pos opcode-64 [>> mask #:4] [make-none-op ..] [make-none-op ..] [make-none-op ..] op1 ..]
          (false)))))
        (false))))

(constrain write-mc-instr (\ r (?(a b c d e f g h i) (`(function (,:a ,:b ,:c ,:d ,:e operand instr ,:f !:Ref:,;g region ,:h) ,:i)r)r)))

(function write-mc-instr (mask opcode-8 opcode-16 opcode-32 opcode-64 opcode.reg-op n bin pos buf handler)
  (sub (X x86) (.. buf handler)
    ((list-prefix?
        (and? .:op1 (property? (X:op-type (or? (|[= (X:memory-operand)]) (|[= (X:register-operand)])))))
        (property? (X:op-type (|[= (X:register-operand)])) (X:op-register (|[= (X:cl)]))))
      (@ X:instr-operands n)
        (if (and [band mask #:1] [= (@ X:op-size op1) #:1])
          [write-instr bin pos opcode-8 [>> mask #:4] [make-none-op ..] opcode.reg-op op1 [make-none-op ..] ..]
        (if (and [band mask #:2] [= (@ X:op-size op1) #:2])
          [write-instr bin pos opcode-16 [>> mask #:4] [make-none-op ..] opcode.reg-op op1 [make-none-op ..] ..]
        (if (and [band mask #:4] [= (@ X:op-size op1) #:4])
          [write-instr bin pos opcode-32 [>> mask #:4] [make-none-op ..] opcode.reg-op op1 [make-none-op ..] ..]
        (if (and [band mask #:8] [= (@ X:op-size op1) #:8])
          [write-instr bin pos opcode-64 [>> mask #:4] [make-none-op ..] opcode.reg-op op1 [make-none-op ..] ..]
          (false)))))
        (false))))

(storage unsupported-instruction-error (~))

(constrain assemble (\ r (?(a b c e) (`(function ((list instr) ,:a region ,:e) (values ,:b ,:c))r)r)))

(function assemble (instrs ret-val buf handler)
  (sub (X x86) (.. buf handler)
    (let (pos (storage _ #:0))
    (let (max-text-sec-len [pad-size [* (write-elf-max-instr-len) [length instrs]] (write-elf-alignment)])
    (let (bin [region-alloc max-text-sec-len ..]) (do
    (for (n (%:list-iter instrs)) (~) (do
      (let (instr-bndg (@ X:instr-binding n))
        (if [not= instr-bndg null-binding] (do
          (setf bndg-storage instr-bndg (absolute-storage))
          (setf bndg-offset instr-bndg $:pos)
          (setf st-value (@ lkdst-raw (@ bndg-other instr-bndg)) $:pos))
          (~)))
      
      (switch = (@ X:instr-code n)
        ((X:label) (~))
        ((x86:nop)
          [write-instr bin pos 0x:90 #:1 [make-none-op ..] [make-none-op ..] [make-none-op ..] [make-none-op ..] ..])
        ((x86:push) (or
          [write-m-instr 0x:1E (~) 0x:FF 0x:FF 0x:FF [make-reg-op (x86:/6) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:pop) (or
          [write-m-instr 0x:1E (~) 0x:8F 0x:8F 0x:8F [make-reg-op (x86:/0) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:xor) (or
          [write-mi-instr 0x:1F 0x:80 0x:81 0x:81 0x:81 [make-reg-op (x86:/6) ..] n bin pos ..]
          [write-mr-instr 0x:1F 0x:30 0x:31 0x:31 0x:31 n bin pos ..]
          [write-rm-instr 0x:1F 0x:32 0x:33 0x:33 0x:33 n bin pos ..]
          [write-mm-instr 0x:1F 0x:30 0x:31 0x:31 0x:31 n bin pos ..]
          [write-mi8-instr 0x:1F 0x:80 0x:83 0x:83 0x:83 [make-reg-op (x86:/6) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:setz) (or
          [write-m-instr 0x:21 0x:940F (~) (~) (~) [make-none-op ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:setc) (or
          [write-m-instr 0x:21 0x:920F (~) (~) (~) [make-none-op ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:seta) (or
          [write-m-instr 0x:21 0x:970F (~) (~) (~) [make-none-op ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:mul) (or
          [write-m-instr 0x:1F 0x:F6 0x:F7 0x:F7 0x:F7 [make-reg-op (x86:/4) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:div) (or
          [write-m-instr 0x:1F 0x:F6 0x:F7 0x:F7 0x:F7 [make-reg-op (x86:/6) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:jmp) (or
          [write-m-instr 0x:1E (~) 0x:FF 0x:FF 0x:FF [make-reg-op (x86:/4) ..] n bin pos ..]
          [write-d-instr 0x:17 0x:EB 0x:E9 0x:E9 (~) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:sub) (or
          [write-rm-instr 0x:1F 0x:2A 0x:2B 0x:2B 0x:2B n bin pos ..]
          [write-mr-instr 0x:1F 0x:28 0x:29 0x:29 0x:29 n bin pos ..]
          [write-mi-instr 0x:1F 0x:80 0x:81 0x:81 0x:81 [make-reg-op (x86:/5) ..] n bin pos ..]
          [write-mm-instr 0x:1F 0x:28 0x:29 0x:29 0x:29 n bin pos ..]
          [write-mi8-instr 0x:1E (~) 0x:83 0x:83 0x:83 [make-reg-op (x86:/5) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:cmp) (or
          [write-rm-instr 0x:1F 0x:3A 0x:3B 0x:3B 0x:3B n bin pos ..]
          [write-mr-instr 0x:1F 0x:38 0x:39 0x:39 0x:39 n bin pos ..]
          [write-mi-instr 0x:1F 0x:80 0x:81 0x:81 0x:81 [make-reg-op (x86:/7) ..] n bin pos ..]
          [write-mm-instr 0x:1F 0x:38 0x:39 0x:39 0x:39 n bin pos ..]
          [write-mi8-instr 0x:1E (~) 0x:83 0x:83 0x:83 [make-reg-op (x86:/7) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:add) (or
          [write-rm-instr 0x:1F 0x:02 0x:03 0x:03 0x:03 n bin pos ..]
          [write-mr-instr 0x:1F 0x:00 0x:01 0x:01 0x:01 n bin pos ..]
          [write-mi-instr 0x:1F 0x:80 0x:81 0x:81 0x:81 [make-reg-op (x86:/0) ..] n bin pos ..]
          [write-mm-instr 0x:1F 0x:00 0x:01 0x:01 0x:01 n bin pos ..]
          [write-mi8-instr 0x:1E (~) 0x:83 0x:83 0x:83 [make-reg-op (x86:/0) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:or) (or
          [write-rm-instr 0x:1F 0x:0A 0x:0B 0x:0B 0x:0B n bin pos ..]
          [write-mr-instr 0x:1F 0x:08 0x:09 0x:09 0x:09 n bin pos ..]
          [write-mm-instr 0x:1F 0x:08 0x:09 0x:09 0x:09 n bin pos ..]
          [write-mi-instr 0x:1F 0x:80 0x:81 0x:81 0x:81 [make-reg-op (x86:/1) ..] n bin pos ..]
          [write-mi8-instr 0x:1F 0x:80 0x:83 0x:83 0x:83 [make-reg-op (x86:/1) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:and) (or
          [write-rm-instr 0x:1F 0x:22 0x:23 0x:23 0x:23 n bin pos ..]
          [write-mr-instr 0x:1F 0x:20 0x:21 0x:21 0x:21 n bin pos ..]
          [write-mm-instr 0x:1F 0x:20 0x:21 0x:21 0x:21 n bin pos ..]
          [write-mi-instr 0x:1F 0x:80 0x:81 0x:81 0x:81 [make-reg-op (x86:/4) ..] n bin pos ..]
          [write-mi8-instr 0x:1F 0x:80 0x:83 0x:83 0x:83 [make-reg-op (x86:/4) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:not) (or
          [write-m-instr 0x:1F 0x:F6 0x:F7 0x:F7 0x:F7 [make-reg-op (x86:/2) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:call) (or
          [write-m-instr 0x:1E (~) 0x:FF 0x:FF 0x:FF [make-reg-op (x86:/2) ..] n bin pos ..]
          [write-d-instr 0x:16 (~) 0x:E8 0x:E8 (~) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:je) (x86:jz) (or
          [write-d-instr 0x:24 (~) (~) 0x:840F (~) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:jnz) (x86:jne) (or
          [write-d-instr 0x:24 (~) (~) 0x:850F (~) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:jnc) (x86:jnb) (x86:jae) (or
          [write-d-instr 0x:24 (~) (~) 0x:830F (~) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:jbe) (x86:jna) (or
          [write-d-instr 0x:24 (~) (~) 0x:860F (~) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:jnbe) (x86:ja) (or
          [write-d-instr 0x:24 (~) (~) 0x:870F (~) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:jnae) (x86:jb) (x86:jc) (or
          [write-d-instr 0x:24 (~) (~) 0x:820F (~) n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:shl) (or
          [write-mc-instr 0x:1F 0x:D2 0x:D3 0x:D3 0x:D3 [make-reg-op (x86:/4) ..] n bin pos ..]
          [write-mi8-instr 0x:1F 0x:C0 0x:C1 0x:C1 0x:C1 [make-reg-op (x86:/4) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:shr) (or
          [write-mc-instr 0x:1F 0x:D2 0x:D3 0x:D3 0x:D3 [make-reg-op (x86:/5) ..] n bin pos ..]
          [write-mi8-instr 0x:1F 0x:C0 0x:C1 0x:C1 0x:C1 [make-reg-op (x86:/5) ..] n bin pos ..]
          {handler (storage _ unsupported-instruction-error n)}))
        ((x86:leave)
          [write-instr bin pos 0x:C9 #:1 [make-none-op ..] [make-none-op ..] [make-none-op ..] [make-none-op ..] ..])
        ((x86:ret)
          [write-instr bin pos 0x:C3 #:1 [make-none-op ..] [make-none-op ..] [make-none-op ..] [make-none-op ..] ..])
        
        ((x86:movzx) (or
          ((list-prefix?
              (and? .:op1 (property? (X:op-type (|[= (X:register-operand)]))))
              (and? .:op2 (property? (X:op-type (or? (|[= (X:memory-operand)]) (|[= (X:register-operand)]))))))
            (@ X:instr-operands n)
              (if (and [= (@ X:op-size op1) #:2] [= (@ X:op-size op2) #:1])
                [write-instr bin pos 0x:B60F #:2 [make-none-op ..] op1 op2 [make-none-op ..] ..]
              (if (and [= (@ X:op-size op1) #:4] [= (@ X:op-size op2) #:1])
                [write-instr bin pos 0x:B60F #:2 [make-none-op ..] op1 op2 [make-none-op ..] ..]
              (if (and [= (@ X:op-size op1) #:8] [= (@ X:op-size op2) #:1])
                [write-instr bin pos 0x:B60F #:2 [make-none-op ..] op1 op2 [make-none-op ..] ..]
              (if (and [= (@ X:op-size op1) #:4] [= (@ X:op-size op2) #:2])
                [write-instr bin pos 0x:B70F #:2 [make-none-op ..] op1 op2 [make-none-op ..] ..]
              (if (and [= (@ X:op-size op1) #:8] [= (@ X:op-size op2) #:2])
                [write-instr bin pos 0x:B70F #:2 [make-none-op ..] op1 op2 [make-none-op ..] ..]
              (if (and [= (@ X:op-size op1) #:8] [= (@ X:op-size op2) #:4])
                [write-instr bin pos 0x:8B #:1 [make-none-op ..] [op-lower-32 op1 ..] op2 [make-none-op ..] ..]
                (false))))))) (false))
          ((list-prefix?
              (and? .:op1 (property? (X:op-type (|[= (X:memory-operand)]))))
              (and? .:op2 (property? (X:op-type (or? (|[= (X:memory-operand)]) (|[= (X:register-operand)])))))
              .:op3)
            (@ X:instr-operands n)
              (if (and [= (@ X:op-size op1) #:2] [= (@ X:op-size op2) #:1]) (do
                [write-instr bin pos 0x:B60F #:2 [make-none-op ..] op3 op2 [make-none-op ..] ..]
                [write-instr bin pos 0x:89 #:1 [make-none-op ..] op3 op1 [make-none-op ..] ..])
              (if (and [= (@ X:op-size op1) #:4] [= (@ X:op-size op2) #:1]) (do
                [write-instr bin pos 0x:B60F #:2 [make-none-op ..] op3 op2 [make-none-op ..] ..]
                [write-instr bin pos 0x:89 #:1 [make-none-op ..] op3 op1 [make-none-op ..] ..])
              (if (and [= (@ X:op-size op1) #:8] [= (@ X:op-size op2) #:1]) (do
                [write-instr bin pos 0x:B60F #:2 [make-none-op ..] op3 op2 [make-none-op ..] ..]
                [write-instr bin pos 0x:89 #:1 [make-none-op ..] op3 op1 [make-none-op ..] ..])
              (if (and [= (@ X:op-size op1) #:4] [= (@ X:op-size op2) #:2]) (do
                [write-instr bin pos 0x:B70F #:2 [make-none-op ..] op3 op2 [make-none-op ..] ..]
                [write-instr bin pos 0x:89 #:1 [make-none-op ..] op3 op1 [make-none-op ..] ..])
              (if (and [= (@ X:op-size op1) #:8] [= (@ X:op-size op2) #:2]) (do
                [write-instr bin pos 0x:B70F #:2 [make-none-op ..] op3 op2 [make-none-op ..] ..]
                [write-instr bin pos 0x:89 #:1 [make-none-op ..] op3 op1 [make-none-op ..] ..])
              (if (and [= (@ X:op-size op1) #:8] [= (@ X:op-size op2) #:4]) (do
                [write-instr bin pos 0x:8B #:1 [make-none-op ..] [op-lower-32 op3 ..] op2 [make-none-op ..] ..]
                [write-instr bin pos 0x:89 #:1 [make-none-op ..] op3 op1 [make-none-op ..] ..])
                (false))))))) (false))
          {handler (storage _ unsupported-instruction-error n)}))
        
        ((x86:mov) (or
          [write-nm-instr n bin pos ..]
          [write-mr-instr 0x:1F 0x:88 0x:89 0x:89 0x:89 n bin pos ..]
          [write-rm-instr 0x:1F 0x:8A 0x:8B 0x:8B 0x:8B n bin pos ..]
          [write-mm-instr 0x:1F 0x:88 0x:89 0x:89 0x:89 n bin pos ..]
          [write-mi-instr 0x:1F 0x:C6 0x:C7 0x:C7 0x:C7 [make-reg-op (x86:/0) ..] n bin pos ..]
          ((list-prefix?
              (and? .:op1 (property?
                (X:op-type (|[= (X:register-operand)]))
                (X:op-size (|[= #:8]))))
              (and? .:op2 (property?
                (X:op-type (|[= (X:immediate-operand)]))
                (X:op-size (|[= #:8]))))) (@ X:instr-operands n)
            [write-instr bin pos 0x:B8 #:1 op1 [make-none-op ..] [make-none-op ..] op2 ..] (false))
          ((list-prefix?
              (and? .:op1 (property? (X:op-type (|[= (X:memory-operand)])) (X:op-size (|[= #:8]))))
              (and? .:op2 (property? (X:op-type (|[= (X:immediate-operand)])) (X:op-size (|[= #:8]))))
              .:op3) (@ X:instr-operands n) (do
            [write-instr bin pos 0x:B8 #:1 op3 [make-none-op ..] [make-none-op ..] op2 ..]
            [write-instr bin pos 0x:89 #:1 [make-none-op ..] op3 op1 [make-none-op ..] ..]) (false))
          {handler (storage _ unsupported-instruction-error n)}))
        
        ((x86:lea) (or
          [write-nm-instr n bin pos ..]
          ((list-prefix?
              (and? .:op1 (property? (X:op-type (|[= (X:register-operand)]))))
              (and? .:op2 (property? (X:op-type (|[= (X:memory-operand)])))))
            (@ X:instr-operands n)
              (if (and [= (@ X:op-size op1) #:2])
                [write-instr bin pos 0x:8D #:1 [make-none-op ..] op1 op2 [make-none-op ..] ..]
              (if (and [= (@ X:op-size op1) #:4])
                [write-instr bin pos 0x:8D #:1 [make-none-op ..] op1 op2 [make-none-op ..] ..]
              (if (and [= (@ X:op-size op1) #:8])
                [write-instr bin pos 0x:8D #:1 [make-none-op ..] op1 op2 [make-none-op ..] ..]
                (false)))) (false))
          ((list-prefix?
              (and? .:op1 (property? (X:op-type (|[= (X:memory-operand)]))))
              (and? .:op2 (property? (X:op-type (|[= (X:memory-operand)]))))
              .:op3)
            (@ X:instr-operands n)
              (if (and [= (@ X:op-size op1) #:2]) (do
                [write-instr bin pos 0x:8D #:1 [make-none-op ..] op3 op2 [make-none-op ..] ..]
                [write-instr bin pos 0x:89 #:1 [make-none-op ..] op3 op1 [make-none-op ..] ..])
              (if (and [= (@ X:op-size op1) #:4]) (do
                [write-instr bin pos 0x:8D #:1 [make-none-op ..] op3 op2 [make-none-op ..] ..]
                [write-instr bin pos 0x:89 #:1 [make-none-op ..] op3 op1 [make-none-op ..] ..])
              (if (and [= (@ X:op-size op1) #:8]) (do
                [write-instr bin pos 0x:8D #:1 [make-none-op ..] op3 op2 [make-none-op ..] ..]
                [write-instr bin pos 0x:89 #:1 [make-none-op ..] op3 op1 [make-none-op ..] ..])
                (false)))) (false))
          {handler (storage _ unsupported-instruction-error n)}))
        
        {handler (storage _ unsupported-instruction-error n)})))
    (values (use-storage ret-val) bin $:pos)))))))

(constrain make-function-text-section
  (\ r (?(a) (`(function ((list instr) string linked-elf64-e linked-elf64-sh linked-elf64-sh region ,:a) linked-elf64-sh)r)r)))

(function make-function-text-section (instrs text-name-str lkd-ehdr lkd-strtab-shdr lkd-symtab-shdr temp-buf cleanup)
  (sub (X x86)
    (let (text-name [make-lkdstrt text-name-str temp-buf cleanup])
    (let (lkd-text-shdr [make-lkds text-name (@ lkde-undef lkd-ehdr) temp-buf cleanup])
    (let (text-shdr (@ lkdsh-raw lkd-text-shdr)) (do
    [append text-name (& lkdsh-strtab (@ lkde-shstr lkd-ehdr)) temp-buf cleanup]
    (setf sh-type text-shdr (sht-progbits))
    (setf sh-flags text-shdr [bor (shf-alloc) (shf-execinstr)])
    (setf sh-addr text-shdr #:0)
    (setf sh-info text-shdr #:0)
    (setf sh-addralign text-shdr #:1)
    (setf sh-entsize text-shdr #:0)
    [append lkd-text-shdr (& lkde-sh lkd-ehdr) temp-buf cleanup]
    
    (for (e (%:list-iter instrs)) (~)
      (let (instr-bndg (@ X:instr-binding e))
        (if [not= instr-bndg null-binding]
          (let (sym-name (if [getb (@ bndg-name instr-bndg)]
              (let (sym-name [make-lkdstrt (@ bndg-name instr-bndg) temp-buf cleanup])
                (do [append sym-name (& lkdsh-strtab lkd-strtab-shdr) temp-buf cleanup] sym-name))
              [@car (@ lkdsh-strtab lkd-strtab-shdr)]))
            (let (lkd-sym [make-lkdst sym-name lkd-text-shdr temp-buf cleanup])
            (let (sym (@ lkdst-raw lkd-sym)) (do
            (setf st-value sym #:0)
            (setf st-size sym #:0)
            (setf st-info sym (elf64-st-info
              (switch = (@ bndg-scope instr-bndg)
                ((local-scope)(stb-local))
                ((global-scope)(stb-global))
                (~)) (stt-notype)))
            (setf st-other sym #:0)
            (setf bndg-other instr-bndg lkd-sym)
            [append lkd-sym (& lkdsh-symtab lkd-symtab-shdr) temp-buf cleanup]))))
          (~))))
          
    ((values? .:text .:text-len) [assemble instrs bind temp-buf cleanup] (do
    (setf sh-size (@ lkdsh-raw lkd-text-shdr) text-len)
    (setf lkdsh-offset lkd-text-shdr text)
    
    lkd-text-shdr) (~))))))))

(constrain make-function-relocation-section
  (\ r (?(a) (`(function ((list reloc) string linked-elf64-e linked-elf64-sh linked-elf64-sh region ,:a) linked-elf64-sh)r)r)))

(function make-function-relocation-section (relocations rela-name-str lkd-ehdr lkd-text-shdr lkd-symtab-shdr temp-buf cleanup)
  (sub (X x86)
    (let (rela-name [make-lkdstrt rela-name-str temp-buf cleanup])
    (let (lkd-rela-shdr [make-lkdrela rela-name lkd-symtab-shdr lkd-text-shdr nil temp-buf cleanup])
    (let (rela-shdr (@ lkdsh-raw lkd-rela-shdr)) (do
    [append rela-name (& lkdsh-strtab (@ lkde-shstr lkd-ehdr)) temp-buf cleanup]
    (setf sh-type rela-shdr (sht-rela))
    (setf sh-flags rela-shdr #:0)
    (setf sh-addr rela-shdr #:0)
    (setf sh-addralign rela-shdr #:0)
    (setf sh-entsize rela-shdr (elf64-rela))
    [append lkd-rela-shdr (& lkde-sh lkd-ehdr) temp-buf cleanup]

    (for (reloc (%:list-iter relocations)) (~)
      (for (loca (%:list-iter (@ X:op-locations (@ reloc-operand reloc)))) (~)
        ((values? .:operand-pos .:operand-size .:instr-pos .:instr-size) loca
          (let (lkd-rela [make-lkdr (@ bndg-other(@ reloc-binding reloc)) temp-buf cleanup])
          (let (rela (@ lkdr-raw lkd-rela)) (do
          (setf r-offset rela operand-pos)
          (setf r-info rela (elf64-r-info (~) (@ reloc-type reloc)))
          (setf r-addend rela
            [(@ reloc-addend-func reloc) (@ reloc-context reloc) operand-pos operand-size instr-pos instr-size])
          [append lkd-rela (& lkdsh-rela lkd-rela-shdr) temp-buf cleanup]))) (~))))
    
    lkd-rela-shdr))))))

(-- The following functions are for ensuring that truncating the outcome of a relocation
  computation preserves its value.)

(function assert-byte (val handler)
  (if [= val [band val 0x:00000000000000FF]]
    val {handler (storage _ object-error)}))

(function assert-sbyte (val handler)
  (if (or [= val [band val 0x:000000000000007F]] [= val [bor val 0x:FFFFFFFFFFFFFF80]])
    val {handler (storage _ object-error)}))

(function assert-half (val handler)
  (if [= val [band val 0x:000000000000FFFF]]
    val {handler (storage _ object-error)}))

(function assert-shalf (val handler)
  (if (or [= val [band val 0x:0000000000007FFF]] [= val [bor val 0x:FFFFFFFFFFFF8000]])
    val {handler (storage _ object-error)}))

(function assert-word (val handler)
  (if [= val [band val 0x:00000000FFFFFFFF]]
    val {handler (storage _ object-error)}))

(function assert-sword (val handler)
  (if (or [= val [band val 0x:000000007FFFFFFF]] [= val [bor val 0x:FFFFFFFF80000000]])
    val {handler (storage _ object-error)}))

(constrain do-relocation (\ r (?(a b c d) (`(function (,:d elf64-rela elf64-sym ,:a ,:b) ,:c)r)r)))

(function do-relocation (target rela sym addend handler)
	(switch = (elf64-r-type (@ r-info rela))
    ((r-x86-64-none) (~))
    ((r-x86-64-64) [memcpy target (storage _[+(@ st-value sym)addend]) #:8])
    ((r-x86-64-pc32) [memcpy target (storage _[assert-sword [-[+(@ st-value sym)addend](@ r-offset rela)] handler]) #:4])
    ((r-x86-64-glob-dat) [memcpy target (storage _(@ st-value sym)) #:8])
    ((r-x86-64-jump-slot) [memcpy target (storage _(@ st-value sym)) #:8])
    ((r-x86-64-32) [memcpy target (storage _[assert-word [+(@ st-value sym) addend] handler]) #:4])
    ((r-x86-64-32s) [memcpy target (storage _[assert-sword [+(@ st-value sym) addend] handler]) #:4])
    ((r-x86-64-16) [memcpy target (storage _[assert-half [+(@ st-value sym) addend] handler]) #:2])
    ((r-x86-64-pc16) [memcpy target (storage _[assert-shalf [-[+(@ st-value sym)addend](@ r-offset rela)] handler])#:2])
    ((r-x86-64-8) [memcpy target (storage _[assert-byte [+(@ st-value sym)addend] handler]) #:1])
    ((r-x86-64-pc8) [memcpy target (storage _[assert-sbyte [-[+(@ st-value sym)addend](@ r-offset rela)] handler])#:1])
    ((r-x86-64-size32) [memcpy target (storage _[+(@ st-size sym)addend]) #:4])
    ((r-x86-64-size64) [memcpy target (storage _[+(@ st-size sym)addend]) #:8])
    {handler (storage _ object-error)}))

(-- Takes assembly code and a list of symbols as constructs an object file.
  instrs is a list of assembly expressions. symbols is a list of the static
  symbols used in the assembly expressions. reg is the region into which the generated
  object code should be put. Returns a pair containing a reference to the generated object
  code and the size of the generated object code.)

(constrain write-elf
  (\ r (?(a b c d) (`(function ((list instr) (list reloc) (list (values string (list instr) (list reloc)))
    (hash-table string bndg-aug) (list bndg-aug) ,:a region region ,:c) (values ,:b ,:d))r)r)))

(function write-elf (instrs relocations function-sections undefined-bindings static-bindings outs rgn1 rgn2 handler)
  (with-region rgn2 (do
    (let (lkd-ehdr [make-lkde nil nil (~) (~) rgn2 handler])
    (let (ehdr (@ lkde-raw lkd-ehdr)) (do
    (setf ei-mag0 (& e-ident ehdr) (elfmag0))
    (setf ei-mag1 (& e-ident ehdr) (elfmag1))
    (setf ei-mag2 (& e-ident ehdr) (elfmag2))
    (setf ei-mag3 (& e-ident ehdr) (elfmag3))
    (setf ei-class (& e-ident ehdr) (elfclass64))
    (setf ei-data (& e-ident ehdr) (elfdata2lsb))
    (setf ei-version (& e-ident ehdr) #:1)
    (setf ei-osabi (& e-ident ehdr) (elfosabi-sysv))
    (setf ei-abiversion (& e-ident ehdr) #:0)

    (for (i (%:range #:7 (ei-nident))) (~) [setb (loc(byte)i(& e-ident ehdr)) #:0])

    (setf e-type ehdr (et-rel))
    (setf e-machine ehdr (em-x86-64))
    (setf e-version ehdr #:1)
    (setf e-entry ehdr #:0)
    (setf e-phoff ehdr #:0)
    (setf e-shoff ehdr (elf64-ehdr))
    (setf e-flags ehdr #:0)
    (setf e-ehsize ehdr (elf64-ehdr))
    (setf e-phentsize ehdr #:0)
    (setf e-phnum ehdr #:0)
    (setf e-shentsize ehdr (elf64-shdr))
    (setf e-shnum ehdr (write-elf-sh-count))
    (setf e-shstrndx ehdr #:1)
    
    (let (shstrtab-name [make-lkdstrt (" .shstrtab) rgn2 handler])
    (let (lkd-shstrtab-shdr [make-lkdstrtab shstrtab-name (~) nil rgn2 handler])
    (let (shstrtab-shdr (@ lkdsh-raw lkd-shstrtab-shdr)) (do
    [append shstrtab-name (& lkdsh-strtab lkd-shstrtab-shdr) rgn2 handler]
    (setf sh-type shstrtab-shdr (sht-strtab))
    (setf sh-flags shstrtab-shdr #:0)
    (setf sh-addr shstrtab-shdr #:0)
    (setf sh-info shstrtab-shdr #:0)
    (setf sh-addralign shstrtab-shdr #:0)
    (setf sh-entsize shstrtab-shdr #:0)
    [append lkd-shstrtab-shdr (& lkde-sh lkd-ehdr) rgn2 handler]
    (setf lkde-shstr lkd-ehdr lkd-shstrtab-shdr)
    
    (-- Mandatory undefined section)
    (let (shstrtab-null-name [make-lkdstrt (" ) rgn2 handler])
    (let (lkd-undef-shdr [make-lkds shstrtab-null-name (~) rgn2 handler])
    (let (undef-shdr (@ lkdsh-raw lkd-undef-shdr)) (do
    [prepend shstrtab-null-name (& lkdsh-strtab lkd-shstrtab-shdr) rgn2 handler]
    (setf lkdsh-link lkd-undef-shdr lkd-undef-shdr)
    (setf sh-name undef-shdr #:0)
    (setf sh-type undef-shdr (sht-null))
    (setf sh-flags undef-shdr #:0)
    (setf sh-addr undef-shdr #:0)
    (setf sh-offset undef-shdr #:0)
    (setf sh-size undef-shdr #:0)
    (setf sh-info undef-shdr #:0)
    (setf sh-addralign undef-shdr #:0)
    (setf sh-entsize undef-shdr #:0)
    (setf lkde-undef lkd-ehdr lkd-undef-shdr)
    (setf lkdsh-link lkd-shstrtab-shdr lkd-undef-shdr)
    
    (let (strtab-name [make-lkdstrt (" .strtab) rgn2 handler])
    (let (lkd-strtab-shdr [make-lkdstrtab strtab-name lkd-undef-shdr nil rgn2 handler])
    (let (strtab-shdr (@ lkdsh-raw lkd-strtab-shdr)) (do
    [append strtab-name (& lkdsh-strtab lkd-shstrtab-shdr) rgn2 handler]
    (setf sh-type strtab-shdr (sht-strtab))
    (setf sh-flags strtab-shdr #:0)
    (setf sh-addr strtab-shdr #:0)
    (setf sh-link strtab-shdr (shn-undef))
    (setf sh-info strtab-shdr #:0)
    (setf sh-addralign strtab-shdr #:0)
    (setf sh-entsize strtab-shdr #:0)
    [append lkd-strtab-shdr (& lkde-sh lkd-ehdr) rgn2 handler]
    
    (let (symtab-name [make-lkdstrt (" .symtab) rgn2 handler])
    (let (lkd-symtab-shdr [make-lkdsymtab symtab-name lkd-strtab-shdr nil rgn2 handler])
    (let (symtab-shdr (@ lkdsh-raw lkd-symtab-shdr)) (do
    [append symtab-name (& lkdsh-strtab lkd-shstrtab-shdr) rgn2 handler]
    (setf sh-type symtab-shdr (sht-symtab))
    (setf sh-flags symtab-shdr #:0)
    (setf sh-addr symtab-shdr #:0)
    (setf sh-addralign symtab-shdr #:0)
    (setf sh-entsize symtab-shdr (elf64-sym))
    [append lkd-symtab-shdr (& lkde-sh lkd-ehdr) rgn2 handler]
    
    (let (bss-extent
      (fold (bss-extent [- #:0 (word-size)]) (bndg (%:list-iter static-bindings))
        [min bss-extent (@ bndg-offset bndg)])) (do
    
    (let (bss-name [make-lkdstrt (" .bss) rgn2 handler])
    (let (lkd-bss-shdr [make-lkds bss-name lkd-undef-shdr rgn2 handler])
    (let (bss-shdr (@ lkdsh-raw lkd-bss-shdr)) (do
    [append bss-name (& lkdsh-strtab lkd-shstrtab-shdr) rgn2 handler]
    (setf sh-type bss-shdr (sht-nobits))
    (setf sh-flags bss-shdr [bor (shf-write) (shf-alloc)])
    (setf sh-addr bss-shdr #:0)
    (setf sh-size bss-shdr [- #:0 bss-extent])
    (setf sh-info bss-shdr #:0)
    (setf sh-addralign bss-shdr (word-size))
    (setf sh-entsize bss-shdr #:0)
    [append lkd-bss-shdr (& lkde-sh lkd-ehdr) rgn2 handler]
    
    (let (strtab-null-name [make-lkdstrt (" ) rgn2 handler])
    (let (lkd-und-sym [make-lkdst strtab-null-name lkd-undef-shdr rgn2 handler])
    (let (und-sym (@ lkdst-raw lkd-und-sym)) (do
    (-- Mandatory undefined symbol)
    [append strtab-null-name (& lkdsh-strtab lkd-strtab-shdr) rgn2 handler]
    (setf st-name und-sym #:0)
    (setf st-value und-sym #:0)
    (setf st-size und-sym #:0)
    (setf st-info und-sym #:0)
    (setf st-other und-sym #:0)
    [prepend lkd-und-sym (& lkdsh-symtab lkd-symtab-shdr) rgn2 handler]
    
    (let (lkd-bss-sym [make-lkdst strtab-null-name lkd-bss-shdr rgn2 handler])
    (let (bss-sym (@ lkdst-raw lkd-bss-sym)) (do
    (setf st-value bss-sym #:0)
    (setf st-size bss-sym [- #:0 bss-extent])
    (setf st-info bss-sym (elf64-st-info (stb-local) (stt-notype)))
    (setf st-other bss-sym #:0)
    [append lkd-bss-sym (& lkdsh-symtab lkd-symtab-shdr) rgn2 handler]
    
    (for (bndg (%:list-iter static-bindings)) (~)
      (if [= (@ bndg-state bndg) (defined-state)]
        (let (sym-name (if [getb (@ bndg-name bndg)]
            (let (sym-name [make-lkdstrt (@ bndg-name bndg) rgn2 handler])
              (do [append sym-name (& lkdsh-strtab lkd-strtab-shdr) rgn2 handler] sym-name))
            strtab-null-name))
          (let (lkd-sym [make-lkdst sym-name lkd-bss-shdr rgn2 handler])
          (let (sym (@ lkdst-raw lkd-sym)) (do
          [set- (& bndg-offset bndg) bss-extent]
          (setf st-value sym (@ bndg-offset bndg))
          (setf st-size sym (@ bndg-size bndg))
          (setf st-info sym (elf64-st-info
            (switch = (@ bndg-scope bndg)
              ((local-scope)(stb-local))
              ((global-scope)(stb-global))
              (~)) (stt-notype)))
          (setf st-other sym #:0)
          (setf bndg-other bndg lkd-sym)
          [append lkd-sym (& lkdsh-symtab lkd-symtab-shdr) rgn2 handler]))))
        (~)))
    
    (select (tuple? .:bndg-name .:bndg) (%:ht-iter undefined-bindings) (~)
      (if (and [= (@ bndg-scope bndg) (global-scope)] [= (@ bndg-state bndg) (undefined-state)])
        (let (sym-name (if [getb (@ bndg-name bndg)]
            (let (sym-name [make-lkdstrt (@ bndg-name bndg) rgn2 handler])
                (do [append sym-name (& lkdsh-strtab lkd-strtab-shdr) rgn2 handler] sym-name))
            strtab-null-name))
          (let (lkd-sym [make-lkdst sym-name lkd-undef-shdr rgn2 handler])
          (let (sym (@ lkdst-raw lkd-sym)) (do
          (setf st-value sym #:0)
          (setf st-size sym #:0)
          (setf st-info sym (elf64-st-info (stb-global) (stt-notype)))
          (setf st-other sym #:0)
          (setf bndg-other bndg lkd-sym)
          [append lkd-sym (& lkdsh-symtab lkd-symtab-shdr) rgn2 handler]))))
        (~)))
    
    (let (main-text-sec [make-function-text-section instrs (" .text) lkd-ehdr lkd-strtab-shdr lkd-symtab-shdr rgn2 handler])
    
    (let (func-text-secs [collect-list (map (func-sec (%:list-iter function-sections))
      ((values? .:name .:instrs .:relocs) func-sec
        [make-function-text-section instrs [rstrcat (" .text.) name rgn2 handler]
          lkd-ehdr lkd-strtab-shdr lkd-symtab-shdr rgn2 handler] (~))) nil rgn2 handler]) (do
    
    [make-function-relocation-section relocations (" .rela.text) lkd-ehdr main-text-sec lkd-symtab-shdr rgn2 handler]
    
    (for (func-sec (%:list-iter function-sections)) (func-text-sec (%:list-iter func-text-secs)) (~)
      ((values? .:name .:instrs .:relocs) func-sec
        [make-function-relocation-section relocs [rstrcat (" .rela.text.) name rgn2 handler]
          lkd-ehdr func-text-sec lkd-symtab-shdr rgn2 handler] (~))))))
    
    (-- Mark every symbol as false in preparation for the usage analysis.)
    
    (for (sec (%:list-iter (@ lkde-sh lkd-ehdr))) (~)
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-symtab)]
        (for (sym (%:list-iter (@ lkdsh-symtab sec))) (~)
          (setf lkdst-other sym (false))) (~)))
    
    (-- Find relocations such that their symbol's section matches the target section,
      apply them, and remove them from the relocations list. For the relocations that
      remain, mark the symbols that they refer to.)
    
    (for (sec (%:list-iter (@ lkde-sh lkd-ehdr))) (~)
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-rela)]
        (filter (lkd-rela (& lkdsh-rela sec))
          (let (rela (@ lkdr-raw lkd-rela))
          (let (addend (@ r-addend rela))
          (let (sym (@ lkdst-raw (@ lkdr-info-sym lkd-rela)))
          (if [= (@ lkdst-sh (@ lkdr-info-sym lkd-rela)) (@ lkdsh-rela-info sec)]
            (let (target [+ (@ r-offset rela) (@ lkdsh-offset (@ lkdsh-rela-info sec))]) (do
              [do-relocation target rela sym addend handler]
              (false)))
          (if [= (@ lkdst-sh (@ lkdr-info-sym lkd-rela)) lkd-bss-shdr]
            (do
              (setf r-addend rela [+ (@ st-value sym) addend])
              (setf lkdr-info-sym lkd-rela lkd-bss-sym)
              (true))
            (do
              (setf lkdst-other (@ lkdr-info-sym lkd-rela) (true))
              (true))))))))
        (~)))
    
    (-- Filter all the symbol tables keeping only the symbols that are referred to
      in relocations or have non-local binding.)
    
    (setf lkdst-other lkd-und-sym (true))
    (setf lkdst-other lkd-bss-sym (true))
    
    (for (sec (%:list-iter (@ lkde-sh lkd-ehdr))) (~)
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-symtab)]
        (filter (sym (& lkdsh-symtab sec))
          (or
            (@ lkdst-other sym)
            [not= (elf64-st-bind (@ st-info (@ lkdst-raw sym))) (stb-local)])) (~)))
    
    (-- Assign the strings in the string table indicies.)
    
    (for (sec (%:list-iter (@ lkde-sh lkd-ehdr))) (~)
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-strtab)]
        (fold (acc #:0) (str (%:list-iter (@ lkdsh-strtab sec))) (do
          (setf lkdstrt-ndx str acc)
          [+ acc [+ #:1 [strlen (@ lkdstrt-raw str)]]])) (~)))
    
    (-- Give each section an index.)
    
    (fold (idx #:0) (sec (%:list-iter (storage-cons lkd-undef-shdr (@ lkde-sh lkd-ehdr))))
      (do (setf lkdsh-ndx sec idx) [+ idx #:1]))
    
    (-- Substitute into ELF Section sh-names and sh-links, and sh-infos if possible.)
    
    (for (sec (%:list-iter (@ lkde-sh lkd-ehdr))) (~) (do
      (setf sh-link (@ lkdsh-raw sec) (@ lkdsh-ndx (@ lkdsh-link sec)))
      (setf sh-name (@ lkdsh-raw sec) (@ lkdstrt-ndx (@ lkdsh-name sec)))
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-rela)]
        (setf sh-info (@ lkdsh-raw sec) (@ lkdsh-ndx (@ lkdsh-rela-info sec)))
        (~))))
    
    (-- Substitute into ELF Header e-shstrndx, e-shnum, and e-shoff)
    
    (setf e-shstrndx (@ lkde-raw lkd-ehdr) (@ lkdsh-ndx (@ lkde-shstr lkd-ehdr)))
    (setf e-shnum (@ lkde-raw lkd-ehdr) [+ [length (@ lkde-sh lkd-ehdr)] #:1])
    (setf e-shoff (@ lkde-raw lkd-ehdr) (elf64-ehdr))
    
    (-- Assign the symbols in each symbol table consecutive indicies.)
    
    (for (sec (%:list-iter (@ lkde-sh lkd-ehdr))) (~)
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-symtab)]
        (let (local-end-idx
            (fold (acc #:0) (sym (%:list-iter (@ lkdsh-symtab sec)))
              (if [= (elf64-st-bind (@ st-info (@ lkdst-raw sym))) (stb-local)]
                (do (setf lkdst-ndx sym acc) [+ acc #:1])
                acc))) (do
          (setf sh-info (@ lkdsh-raw sec) local-end-idx)
          (fold (acc local-end-idx) (sym (%:list-iter (@ lkdsh-symtab sec)))
            (if [= (elf64-st-bind (@ st-info (@ lkdst-raw sym))) (stb-local)]
              acc
              (do (setf lkdst-ndx sym acc) [+ acc #:1]))))) (~)))
    
    (-- Calculate the sizes of the individual sections.)
    
    (for (sec (%:list-iter (@ lkde-sh lkd-ehdr))) (~)
      (switch = (@ sh-type (@ lkdsh-raw sec))
        ((sht-symtab) (setf sh-size (@ lkdsh-raw sec)
          [* [length (@ lkdsh-symtab sec)] (elf64-sym)]))
        ((sht-rela) (setf sh-size (@ lkdsh-raw sec)
          [* [length (@ lkdsh-rela sec)] (elf64-rela)]))
        ((sht-strtab) (setf sh-size (@ lkdsh-raw sec)
          (fold (acc #:0) (str (%:list-iter (@ lkdsh-strtab sec)))
            [+ acc [+ #:1 [strlen (@ lkdstrt-raw str)]]])))
        (~)))
    
    (-- Substitute into symbol table entry shndxs and names.)
    
    (for (sec (%:list-iter (@ lkde-sh lkd-ehdr))) (~)
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-symtab)] (do
        (for (sym (%:list-iter (@ lkdsh-symtab sec))) (~) (do
          (setf st-shndx (@ lkdst-raw sym) (@ lkdsh-ndx (@ lkdst-sh sym)))
          (setf st-name (@ lkdst-raw sym) (@ lkdstrt-ndx (@ lkdst-name sym)))))) (~)))
    
    (-- Substitute into relocation r-info.syms.)
    
    (for (sec (%:list-iter (@ lkde-sh lkd-ehdr))) (~)
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-rela)]
        (for (rela (%:list-iter (@ lkdsh-rela sec))) (~)
          (setf r-info (@ lkdr-raw rela) (elf64-r-info
            (@ lkdst-ndx (@ lkdr-info-sym rela))
            (elf64-r-type (@ r-info (@ lkdr-raw rela)))))) (~)))
    
    (-- Assign an offset to each section and record ELF size.)
    
    (let (elf-size [pad-size (fold (offset [+ (elf64-ehdr) [* (elf64-shdr) [+ [length (@ lkde-sh lkd-ehdr)] #:1]]])
        (sec (%:list-iter (@ lkde-sh lkd-ehdr))) (do
      (setf sh-offset (@ lkdsh-raw sec) offset)
      (if [= (@ sh-type (@ lkdsh-raw sec)) (sht-nobits)]
        offset
        [+ offset [pad-size (@ sh-size (@ lkdsh-raw sec)) (write-elf-alignment)]]))) (write-elf-alignment)]) (do
    
    (-- Write out the ELF file.)
    
    (let (pos (storage _ #:0))
    (let (bin [region-alloc elf-size rgn1 handler]) (do
    [mem-write bin pos (@ lkde-raw lkd-ehdr) (elf64-ehdr)]
    (for (sec (%:list-iter (storage-cons lkd-undef-shdr (@ lkde-sh lkd-ehdr)))) (~)
      [mem-write bin pos (@ lkdsh-raw sec) (elf64-shdr)])
    (for (sec (%:list-iter (@ lkde-sh lkd-ehdr))) (~) (do
      (switch = (@ sh-type (@ lkdsh-raw sec))
        ((sht-symtab) (do
          (for (sym (%:list-iter (@ lkdsh-symtab sec))) (~)
            (if [= (elf64-st-bind (@ st-info (@ lkdst-raw sym))) (stb-local)]
              [mem-write bin pos (@ lkdst-raw sym) (elf64-sym)] (~)))
          (for (sym (%:list-iter (@ lkdsh-symtab sec))) (~)
            (if [= (elf64-st-bind (@ st-info (@ lkdst-raw sym))) (stb-local)] (~)
              [mem-write bin pos (@ lkdst-raw sym) (elf64-sym)]))))
        ((sht-rela)
          (for (rela (%:list-iter (@ lkdsh-rela sec))) (~)
            [mem-write bin pos (@ lkdr-raw rela) (elf64-rela)]))
        ((sht-strtab)
          (for (str (%:list-iter (@ lkdsh-strtab sec))) (~)
            [mem-write bin pos (@ lkdstrt-raw str) [+ [strlen (@ lkdstrt-raw str)] #:1]]))
        ((sht-nobits) (~))
        [mem-write bin pos (@ lkdsh-offset sec) (@ sh-size (@ lkdsh-raw sec))])
      [set pos [pad-size $:pos (write-elf-alignment)]]))
    
    (values (use-storage outs) bin $:pos)))))))))))))))))))))))))))))))))))))))))

(-- Converts the offsets of the static bindings associated with L2 source code that has now
  been loaded into addresses. asms is a list of assembly expressions containing bindings
  that need to be converted. bindings is a list of augmented bindings corresponding to the
  assembly expressions that also need to be converted.)

(constrain binding-offsets-to-addresses
  (\ r (?(a) (`(function ((list instr) (list (values string (list instr) (list reloc))) (list bndg-aug) obj region ,:a) ())r)r)))

(function binding-offsets-to-addresses (asms function-sections static-bindings obj reg hdl)
  (sub (X x86) (with-region reg (do
    (for (sym (%:list-iter static-bindings)) (~)
      (if (and [= (@ bndg-storage sym) (absolute-storage)] [= (@ bndg-state sym) (defined-state)])
        [set+ (& bndg-offset sym) [segment obj (" .bss)]]
        (~)))
    
    (for (l (%:list-iter asms)) (~)
      (let (instr-bndg (@ X:instr-binding l))
        (if [not= instr-bndg null-binding]
          [set+ (& bndg-offset instr-bndg) [segment obj (" .text)]]
          (~))))
    
    (for (func-sec (%:list-iter function-sections)) (~)
      ((values? .:name .:instrs .:relocs) func-sec
        (for (l (%:list-iter instrs)) (~)
          (let (instr-bndg (@ X:instr-binding l))
            (if [not= instr-bndg null-binding]
              [set+ (& bndg-offset instr-bndg) [segment obj [rstrcat (" .text.) name reg hdl]]]
              (~)))) (~)))))))
