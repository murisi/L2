(ignore
  The following functions are abbreviations of sequences of list operations that are
  frequently useful when working with s-expressions.)

(function @frst (l) [@fst [@rst l]])

(function @ffrst (l) [@fst [@frst l]])

(function @frfrst (l) [@fst [@rst [@frst l]]])

(function @rrst (l) [@rst [@rst l]])

(function @rrrst (l) [@rst [@rrst l]])

(function @rrrrst (l) [@rst [@rrrst l]])

(function @rrrrrst (l) [@rst [@rrrrst l]])

(function @rfst (l) [@rst [@fst l]])

(function @frfst (l) [@fst [@rfst l]])

(function @frrfst (l) [@fst [@rst [@rfst l]]])

(function @frrst (l) [@fst [@rst [@rst l]]])

(function @frrrst (l) [@fst [@rst [@rst [@rst l]]]])

(function @frrrrst (l) [@fst [@rst [@rst [@rst [@rst l]]]]])

(function @frrrrrst (l) [@fst [@rst [@rst [@rst [@rst [@rst l]]]]]])

(function @frrrrrrst (l) [@fst [@rst [@rst [@rst [@rst [@rst [@rst l]]]]]]])

(function @frrrrrrrst (l) [@fst [@rst [@rst [@rst [@rst [@rst [@rst [@rst l]]]]]]]])

(function @ffst (l) [@fst [@fst l]])

(function llst (a b c r) [lst a [lst b c r] r])

(function lllst (a b c d r) [lst a [llst b c d r] r])

(function llllst (a b c d e r) [lst a [lllst b c d e r] r])

(function lllllst (a b c d e f r) [lst a [llllst b c d e f r] r])

(function llllllst (a b c d e f g r) [lst a [lllllst b c d e f g r] r])

(function lllllllst (a b c d e f g h r) [lst a [llllllst b c d e f g h r] r])

(function llllllllst (a b c d e f g h i r) [lst a [lllllllst b c d e f g h i r] r])

(function lllllllllst (a b c d e f g h i j r) [lst a [llllllllst b c d e f g h i j r] r])

(ignore
  When bootstrapping macros, it is very inconvenient to manually use continuations to
  bind variables, hence the following transformations.)

(function meta.bind1 (tuple fun)
  [fun [@fst tuple]])

(function meta.bind4 (tuple fun)
  [fun [@fst tuple] [@frst tuple] [@frrst tuple] [@frrrst tuple]])

(function meta.bind5 (tuple fun)
  [fun [@fst tuple] [@frst tuple] [@frrst tuple] [@frrrst tuple] [@frrrrst tuple]])

(function meta.bind6 (tuple fun)
  [fun [@fst tuple] [@frst tuple] [@frrst tuple] [@frrrst tuple] [@frrrrst tuple] [@frrrrrst tuple]])

(ignore
  The following function provides an abbreviation for getting a value from a memory
  address. It implements the transformation $:a -> [get a].)

(function $ (var r) `:[get , var]:r)

(constrain get (\ r (?(a) `:(function ((ref ,:a)) ,:a):r r)))

(constrain set (\ r (?(a) `:(function ((ref ,:a) ,:a) ()):r r)))

(function meta.lookup-var (key map)
  (with return
    {(continuation lookup (map)
      (if [emt? map]
        {return emt}
      (if [var= key [@ffst map]]
        {return [@fst map]}
        {lookup [@rst map]}))) map}))

(function meta.map-values (map r)
  (with return
    {(continuation extract (map values)
      (if [emt? map]
        {return values}
        {extract [@rst map] [lst [@frfst map] values r]})) map emt}))

(ignore
  The following function generates the L2 code to generate a fragment corresponding to the
  supplied fragment. Known as backquote in other languages.)

(function bq-aux-aux (s t level map r)
  [meta.bind6
    [llst level s (if [token? s]
      [llllst [lllst --- [@fst s] --- emt r] t map r emt r]
      [bq-aux [@fst s] t level map r]) r]
    (function _(level s inner-s t map r)
      [meta.bind6 [llst s inner-s [bq-aux [@rst s] t level map r] r]
        (function _(s inner-s inner-s2 t map r)
          [llllst [lllllst [llllllst -i- -n- -v- -o- -k- -e- emt r]
            [lllst -l- -s- -t- emt r] inner-s inner-s2 t emt r] t map r emt r])])])

(function bq-aux (s t level map r)
  (if [emt? s] [llllst [lllst -e- -m- -t- emt r] t map r emt r]
  
  (if [var? s]
    [meta.bind6 [llllllst [llllllst -q- -u- -o- -t- -e- -.- [gentok r] r] [meta.lookup-var s map] s t map r emt r]
      (function _(state res s t map r)
        (if [emt? res]
          [llllst state t [lst [llst s state emt r] map r] r emt r]
          [llllst [@frst res] t map r emt r]))]
  
  (if (if [emt? s] #:0 (if [token? s] #:0 (if [token? [@fst s]]
    (if [char= [@ffst s] -`-] [emt? [@rfst s]] #:0) #:0)))
        [bq-aux-aux s t [+ level #:1] map r]
  
  (if (if [emt? s] #:0 (if [token? s] #:0 (if [token? [@fst s]]
    (if [char= [@ffst s] -,-] (if [emt? [@rfst s]] level #:0) #:0) #:0)))
        [bq-aux-aux s t [- level #:1] map r]
  
  (if (if [emt? s] #:0 (if [token? s] #:0 (if [token? [@fst s]]
    (if [char= [@ffst s] -,-] [emt? [@rfst s]] #:0) #:0)))
        [llllst [@frst s] t map r emt r]
  
  (if (if [emt? s] #:0 (if [token? s] #:0 (if [token? [@fst s]]
    (if [char= [@ffst s] -!-] [emt? [@rfst s]] #:0) #:0)))
        [meta.bind5 [lst s [bq-aux [@rrst s] t level map r] r]
          (function _(outer-s s t map r)
            [llllst [llllst [llllllst -i- -n- -v- -o- -k- -e- emt r]
              [@frst outer-s] s t emt r] t map r emt r])]

  [bq-aux-aux s t level map r])))))))

(ignore Quote macro that only works for fragments not containing variables.)

(function bq (l r)
  [@fst [bq-aux [@fst l] [@frst l] #:0 emt r]])

(ignore Quote macro that works for fragments containing variables.)

(function ` (l r)
  [meta.bind4 [bq-aux [@fst l] [@frst l] #:0 emt r]
    (function _(s t map r)
      bq:(with bq.return
        {(continuation bq.cont ,:[meta.map-values map r] {bq.return ,:s}),
          [meta.map3 map t r (function _(elt t r) bq:[var ,:t]:r) r]}):r)])

(function meta.bq (l buffer r) [`[llst l buffer emt r]r])

(function meta.bqbq (l buffer1 buffer2 r) [meta.bq [meta.bq l buffer1 r] buffer2 r])

(function meta.unquote (l r) [llst [lst -,- emt r] l emt r])

(ignore
  The following function generates code to create variables and bind them. It does the
  following transformation:
  
  (?(vars ...) expr region)
  ->
  (let (var0 [var region]) ... (varN [var region]) expr))

(function ?(l r)
  (let (bindings [meta.map3 [@fst l] [@frrst l] r (\ e s r (`(,:e [var ,:s])r)) r])
    [lst (` let r) [meta.reverse [lst [@frst l] [meta.reverse bindings r] r] r] r]))

(ignore The following function checks if the tokens a and b are equal.)

(function token= (a b)
  (loop check (a a) (b b)
    (if (and [emt? a] [emt? b])
      (true)
    (if (or [emt? a] [emt? b])
      (false)
    (if [char= [@fst a] [@fst b]]
      {check [@rst a] [@rst b]}
      (false))))))

(ignore
  The following function concatenates lists a and b. A part of the constructed list will
  lie in the region r.)

(function meta.concat (a b r)
  (loop do-prepend (rem-list [meta.reverse a r]) (constr b)
    (if [emt? rem-list]
      constr
      {do-prepend [@rst rem-list] [lst [@fst rem-list] constr r]})))

(ignore
  The following macro does the following transformation:
  (substitute (tkn1 repl1 ...) ... (tknN replN ...) frag)
  ->
  frag but with the fragments repl inserted in order at all the places that the token tkn
  occurred. An example usage is when the arguments a group of functions are called with
  have a common sublist.)

(function substitute (l r)
  (loop do-sub (subs [@rst [meta.reverse l r]]) (body [@fst [meta.reverse l r]])
    (if [emt? subs]
      body
      {do-sub [@rst subs] [(function aux (frag fnd repl r)
          (if (or [token? frag] [emt? frag])
            frag
            (if (and [token? [@fst frag]] [token= [@fst frag] fnd])
              [meta.concat repl [@rst frag] r]
              [lst [aux [@fst frag] fnd repl r] [aux [@rst frag] fnd repl r] r])))
        body [@ffst subs] [@rfst subs] r]})))

(ignore
  A set of macros to provide struct functionality in L2. The most naive way
  to do structs in L2 would be to create a getter function, setter function,
  and offset calculation function for every field where these functions
  simply access the desired memory locations. However this solution is
  untenable because of the amount of boilerplate that one would have to write.
  The approach taken in the below macros is to aggregate the offset, size,
  getter, and setter of each field into a higher-order macro that supplies
  this information into any macro that is passed to it. This way, generic
  getter, setter, address-of, offset-of, and sizeof functions can be defined
  once and used on any field.)

(ignore
  The following function is a macro for getting the offset of a field of a struct.
  The macro expands into a macro invocation of the supplied field (the second
  item in the fragment l), passing into it offset-aux (the macro that actually
  produces the offset of the field).)

(function offset-of (l r) (`((,[@fst l]) offset-of-aux)r))

(ignore
  This function is not to be called directly. It returns a fragment representing
  the offset of the field. That is, it returns the first item in the fragment l.)
  
(function offset-of-aux (l r) [@fst l])

(function size-of (l r) (`((,[@fst l]) size-of-aux)r))

(function size-of-aux (l r) [@frst l])

(function getter-of (l r) (`((,[@fst l]) getter-of-aux)r))

(function getter-of-aux (l r) [@frrst l])

(function setter-of (l r) (`((,[@fst l]) setter-of-aux)r))

(function setter-of-aux (l r) [@frrrst l])

(ignore
  The following function is a macro for getting the address of a field of a struct.
  The macro expands into a macro invocation of the supplied field (the second
  item in the fragment l), passing into it &-aux (the macro that will generate
  the actual invocation that calculates the address of the field) and the address of
  the struct (the first item in the fragment l).)

(function & (l r) (`((,[@fst l]) &-aux (,[@frst l]))r))

(ignore
  This function is not to be called directly. It generates the actual
  invocation to calculate the address of the field. When macro-called, it
  adds the offset (the first item in the fragment l) to the base
  (the fifth item in the fragment l).)

(function &-aux (l r)
  (`(with &-aux.ret
      (let (@-aux.obj (,[@frrrrrrst l]))
        {(constrain (constrain (continuation @-aux.cont (pseudo prop-ref obj) {&-aux.ret prop-ref})
            (\ &-aux.s (?(a b) (let ((,[@frrrrst l]) &-aux.s) (`(continuation ((,(,[@frrrrrst l])) ,:a ,:b))&-aux.s))&-aux.s)))
            (\ s (?(a b c d) (`(continuation ((@ ,:a ,:c ,:d ,:b) (ref ,:a) ,:b))s)s)))
          (ignore) [+ @-aux.obj (,[@fst l])] @-aux.obj}))r))

(ignore
  The following function is a macro for getting the field of a struct. The
  macro expands into a macro invocation of the supplied field (the second
  item in the fragment l), passing into it @-aux (the macro that will generate
  the actual invocation that gets the field) and the address of the struct (the
  first item in the fragment l).)
  
(function @ (l r) (`((,[@fst l]) @-aux (,[@frst l]))r))

(ignore
  This function is not to be called directly. It generates the actual
  invocation to get the field. When macro-called, it invokes the getter
  function (the fourth item in the fragment l) with an address formed by
  adding the offset (the first item in the fragment l) to the base
  (the fifth item in the fragment l).)

(function @-aux (l r)
  (`(with @-aux.ret
      (let (@-aux.obj (,[@frrrrrrst l]))
        {(constrain (constrain (continuation @-aux.cont (pseudo prop obj) {@-aux.ret prop})
            (\ @-aux.s (?(a b) (let ((,[@frrrrst l]) @-aux.s) (`(continuation ((,(,[@frrrrrst l])) ,:a ,:b))@-aux.s))@-aux.s)))
            (\ s (?(a b c d) (`(continuation ((@ ,:a ,:c ,:d ,:b) ,:a ,:b))s)s)))
          (ignore) [(,[@frrst l]) [+ @-aux.obj (,[@fst l])]] @-aux.obj}))r))

(ignore
  The following function is a macro for setting the field of a struct. The
  macro expands into a macro invocation of the supplied field (the second
  item in the fragment l), passing into it setf-aux (the macro that will generate
  the actual invocation that sets the field), the address of the struct (the
  first item in the fragment l), and the new value of the field (the third
  item in the fragment l).)

(function setf (l r) (`((,[@fst l]) setf-aux (,[@frst l]) (,[@frrst l]))r))

(ignore
  This function is not to be called directly. It generates the actual
  invocation to set the field. When macro-called, it invokes the setter
  function (the fourth item in the fragment l) with an address formed by
  adding the offset (the first item in the fragment l) to the base
  (the fifth item in the fragment l) and a value (the sixth item in the
  fragment l).)

(function setf-aux (l r)
  (`(with setf-aux.ret
      (let (setf-aux.obj (,[@frrrrrrst l]))
        {(constrain (constrain (continuation setf-aux.cont (pseudo prop obj obj-casted)
              {setf-aux.ret (do [(,[@frrrst l]) [+ obj (,[@fst l])] prop] obj-casted)})
            (\ setf-aux.s (?(setf-aux.a setf-aux.b setf-aux.c) (let ((,[@frrrrst l]) setf-aux.s) (`(continuation ((,(,[@frrrrrst l])) ,:setf-aux.a ,:setf-aux.b ,:setf-aux.c))setf-aux.s))setf-aux.s)))
            (\ s (?(a b c d) (`(continuation ((@ ,:a ,:b ,:c ,:d) ,:a ,:b ,:c))s)s)))
          (ignore) (,[@frrrrrrrst l]) setf-aux.obj [cast setf-aux.obj]}))r))

(ignore
  This function initializes/updates the values of a record and returns the
  record with the correct type. Note that fields may have to be initialized
  in a certain order for type checking to pass. This macro does the following
  transformation:
  (record (id obj) (f1 v1) (f2 v2) ... (fN vN))
  ->
  (let (id obj) (setf fN (... (setf f2 (setf f1 id v1) v2) ...) vN)))

(function record (l r)
  (`(let (,[@fst l])
    (,(loop layer-set (acc [@ffst l]) (props [@rst l])
        (if [emt? props]
          acc
          {layer-set (`(setf (,[@ffst props]) ,:acc (,[@frfst props]))r) [@rst props]}))))r))

(ignore
  The following function is a helper function for generating the fields of
  structs. All that it does is create a macro invocation on the first token
  in the fragment l supplying to it the offset, size, getter, and setter of
  the field in addition to the rest of the fragment l.)

(function property-aux (l r offset size sig)
  [lllllllst [@fst l] [=# offset r] [=# size r]
    (switch = size (#:0 (` get0b r)) (#:1 (` get1b r)) (#:2 (` get2b r)) (#:4 (` get4b r)) (#:8 (` get8b r)) (`(ignore)r))
    (switch = size (#:0 (` set0b r)) (#:1 (` set1b r)) (#:2 (` set2b r)) (#:4 (` set4b r)) (#:8 (` set8b r)) (`(ignore)r))
    (` property-aux.buf r) [`[llst [sig r] (` property-aux.buf r) emt r]r] [@rst l] r])

(ignore
  The following function is another helper function for creating properties.
  Performs the following transformation:
  (property name args ...)
  ->
  (function name (property.l property.r) [property-aux property.l property.r args ...]))

(function property (l r)
  (`(function (,[@fst l]) (property.l property.r) [property-aux property.l property.r , [@rst l]])r))

(ignore A basic property's getter and setter operate on exactly the same type.)

(function static~ (l r) (`(@ (,[@fst l]) (,[@frst l]) (,[@frst l]) (,[@frst l]))r))

(ignore A dynamic property's setter changes its type. Its getter shouldn't be used.)

(function dynamic~ (l r) (`(@ (,[var r]) (,[@fst l]) (,[@frst l]) (,[var r]))r))

(ignore
  The following function provides a method for ignoring L2 code. It is being used for this
  comment to work.)

(function ignore (l r) [=# 0x:DEADBEEF r])

(ignore Takes a list and produces a list of unique tokens that are prefixed by the given prefix.)

(function meta.label (list prefix r)
  (with return
    {(continuation aux (labels list)
      (if [emt? list]
        {return labels}
        {aux [lst [meta.concat prefix [gentok r] r] labels r] [@rst list]})) emt list}))

(ignore
  Does the transformation (values storer arg1 arg2 ...) -> (storer values.stor arg1 arg2 ...).
  (values storer arg1 arg2 ...) has the type (values sig1 sig2 ...) where sigj is the signature
  of argj.)

(function values (l r)
  (let (storer [@fst l]) (args [@rst l])
  (let (params [meta.label args `:values.param.:r r])
        (vars [meta.label args `:values.var.:r r])
  (let (unquoted-vars [meta.map2 vars r meta.unquote r])
    `:(with values.return
        ,:[llst `:jump:r [llllst `:continuation:r `:values.eval:r params [lllst `:jump:r `:(constrain
            (continuation values.func ,:[lst `:values.storage:r params r]
              {values.return values.storage})
            (\ values.r (? ,:vars
              `:(continuation ,:[lst
                  [lst `:values:values.r ,:[meta.bq unquoted-vars `:values.r:r r] values.r]
                  ,:[`[llst unquoted-vars `:values.r:r emt r]r] values.r]):values.r values.r))):r
          [llst storer `:values.stor:r params r] params r] emt r] args r]):r))))

(ignore
  Binds values bound by values. I.e. evaluating (bind (param1 param2 ...) x expr) where
  x is (values storer arg1 arg2 ...) is the same as evaluating expr in an environment where
  paramj is argj for each j.)

(function bind (l r)
  (let (identifiers [@fst l]) (param [@frst l]) (body [@frrst l])
  (let (bind-storage [llst (` storage r) (` bind r) [meta.map2 identifiers r (\ l r (`(ignore)r)) r] r])
  (let (vars [meta.label identifiers `:values.var:r r])
  (let (unquoted-vars [meta.map2 vars r (\ l r [llst [lst -,- emt r] l emt r]) r])
  (let (param-parts (loop make-set (identifiers identifiers) (offset #:0) (params emt)
      (if [emt? identifiers]
        [meta.reverse params r]
        {make-set [@rst identifiers] [+ offset (unit)]
          [lst (`[get [+ bind.param (,[=# offset r])]]r) params r]})))
    (`(with bind.return
        (let (bind.param (let (bind ,:bind-storage) ,:param))
          (,[lllst (` jump r) (`(constrain (continuation bind.func (,[lst (` bind.param r) identifiers r])
                {bind.return ,:body})
              (\ bind.r (? ,:vars
                [llst (` continuation bind.r) [lst [lst (` values bind.r) (,[`[llst unquoted-vars (` bind.r r) emt r]r]) bind.r]
                  (,[`[llst unquoted-vars (` bind.r r) emt r]r]) bind.r] emt bind.r] bind.r)))r)
            (` bind.param r) param-parts r])))r)))))))

(ignore
  The following macro implements the following transformation:
  ((use-storage stor) use-stor arg1 arg2 ... argN)
  ->
  (let (use-stor stor) (do
    [set [+ use-stor [* #:0(unit)]] arg1]
    [set [+ use-stor [* #:1(unit)]] arg2]
    ...
    [set [+ use-stor [* #(N-1)(unit)]] argN]
    use-stor)))

(function use-storage (use-storage.l use-storage.r)
  (`(function use-storage.temp (l r)
      (`(let ((,[@fst l]) (,(,[`[llst [@fst use-storage.l] (` r use-storage.r) emt use-storage.r] use-storage.r])))
          (,[lst (` do r) [meta.reverse [lst [@fst l]
            (loop make-set (identifiers [@rst l]) (idx #:0) (sets emt)
              (if [emt? identifiers]
                sets
                {make-set [@rst identifiers] [+ idx #:1]
                  [lst (`[set [+ (,[@fst l]) [* (,[=# idx r]) (unit)]] (,[@fst identifiers])]r) sets r]})) r] r] r]))r))use-storage.r))

(ignore
  Implements the transformations (@n expr) -> ($[+ expr [* #:n(unit)]]). Designed to
  evaluate to the nth argument of a storage expression.)

(function @0 (l r) (`($[+ (,[@fst l]) [* #:0(unit)]])r))

(function @1 (l r) (`($[+ (,[@fst l]) [* #:1(unit)]])r))

(function @2 (l r) (`($[+ (,[@fst l]) [* #:2(unit)]])r))

(function @3 (l r) (`($[+ (,[@fst l]) [* #:3(unit)]])r))

(function @4 (l r) (`($[+ (,[@fst l]) [* #:4(unit)]])r))

(ignore
  A macro to produce the address of an element of a multi-dimensional array.
  For example, (loc(unit) #:4 $:arr) gets the address corresponding to unit 4
  from $:arr. The signature of the expression is the same as that of the base.)

(function loc (l r)
  (`(with loc.return
      (let (loc.base (,[@frrst l]))
        {(constrain (continuation loc.cont (base val) {loc.return val})
            (\ r (?(a) (`(continuation (,:a ,:a))r)r)))
          loc.base [+ [* (,[@fst l]) (,[@frst l])] loc.base]}))r))

(ignore
  A tuple is a continuation that supplies its values to any continuation passed
  to it. The following macro creates an appropriate tuple signature by do the
  following transformation:
  (tuple- t1 t2 ... tN)
  ->
  (continuation ((continuation (t1 t2 ... tN)))))

(function tuple- (l r) `:(continuation ((continuation ,:l))):r)

(ignore
  A macro to create a local tuple. Does the following transformation:
  (tuple val1 val2 ... valN)
  ->
  (continuation tuple.cont (tuple.target)
    {tuple.target val1 val2 ... valN}))

(function tuple (l r)
  `:(continuation tuple.cont (tuple.target)
      {tuple.target , l}):r)

(ignore
  A macro to match a local tuple. Does the following transformation:
  ((tuple? matcher1 matcher2 ... matcherN) obj consequent alternate)
  ->
  (with tuple?.ret
    {obj (continuation tuple?.cont (val1 val2 ... valN)
      {tuple?.ret
        (matcher1 val1
          (matcher2 val2
            (...
              (matcherN valN
                consequent
                alternate)
              ...)
            alternate)
          alternate)})}))

(function tuple? (l r)
  `:(function tuple?.func (l r)
      (let (obj [@fst l]) (consequent [@frst l]) (alternate [@frrst l]) (matchers ,:[meta.bq l `:r:r r])
      (let (vars [meta.label matchers [meta.concat `:tuple?.var:r [meta.concat [gentok r] `:.:r r] r] r])
        `:(with tuple?.ret
            {,:obj (continuation tuple?.cont ,:vars
              {tuple?.ret
                ,:(loop build (expr consequent) (matchers [meta.reverse matchers r]) (vars [meta.reverse vars r])
                    (if [emt? matchers]
                      expr
                      {build `:(,:[@fst matchers] ,:[@fst vars] ,:expr ,:alternate):r [@rst matchers] [@rst vars]}))})}):r))):r)

(ignore
  A macro to turn a predicate into a branch expression. Does the following transformation:
  ((| (func arg1 arg2 ... argN)) obj consequent alternate)
  ->
  (if (func arg1 arg2 ... argN obj) consequent alternate))

(function | (l r)
  `:(function |.func (l r)
      (let (obj [@fst l]) (consequent [@frst l]) (alternate [@frrst l]) (partial ,:[meta.bq [@fst l] `:r:r r])
        (let (complete [meta.concat partial [lst obj emt r] r])
          `:(if ,:complete ,:consequent ,:alternate):r))):r)

(ignore
  A macro for capturing variables. Does the following transformation:
  (.:id val consequent alternate)
  ->
  (let (id val) consequent))

(function . (l r)
  (`(function dot.func (l r)
      (let (id ,:[meta.bq [@fst l] `:r:r r])
        (`(let (,:id ,:[@fst l]) ,:[@frst l])r)))r))

(ignore
  A macro for matching objects against certain properties. The macro does the following
  transformation:
  ((property? (prop1 matcher1) (prop2 matcher2) ... (propN matcherN)) obj consequent alternate)
  ->
  (let (property?.obj obj)
    (matcher1 (@ prop1 property?.obj)
      (matcher2 (@ prop2 property?.obj)
        (...
          (matcherN (@ propN property?.obj)
            consequent
            alternate)
          ...)
        alternate)
      alternate)))

(function property? (l r)
  `:(function property?.func (l r)
      (let (obj [@fst l]) (alternate [@frrst l]) (consequent [@frst l]) (obj-sym [meta.concat `:property?.obj:r [gentok r] r])
        `:(let (,:obj-sym ,:obj)
            ,:(loop build (expr consequent) (parts ,:[meta.bq [meta.reverse l r] `:r:r r])
              (if [emt? parts]
                expr
                (let (matcher [@frfst parts]) (prop [@ffst parts])
                  {build `:(,:matcher (@ ,:prop ,:obj-sym) ,:expr ,:alternate):r
                    [@rst parts]})))):r)):r)

(ignore
  A macro for matching objects to at least one of the given matchers. The macro does the
  following transformation:
  (or? (matcher1 matcher2 ... matcherN) obj consequent alternate)
  ->
  (let (or?.obj obj)
    (matcher1 or?.obj
      consequent
      (matcher2 or?.obj
        consequent
        (...
          (matcherN or?.obj
            consequent
            alternate)
          ...)))))

(function or? (l r)
  `:(function or?.func (l r)
      (let (obj [@fst l]) (alternate [@frrst l]) (consequent [@frst l])
        `:(let (or?.obj ,:obj)
            ,:(loop build (expr alternate) (parts ,:[meta.bq [meta.reverse l r] `:r:r r])
              (if [emt? parts]
                expr
                (let (matcher [@fst parts])
                  {build `:(,:matcher or?.obj ,:consequent ,:expr):r [@rst parts]})))):r)):r)

(ignore
  A macro for matching objects to at least one of the given matchers. The macro does the
  following transformation:
  ((and? matcher1 matcher2 ... matcherN) obj consequent alternate)
  ->
  (let (and?.obj obj)
    (matcher1 and?.obj
      (matcher2 and?.obj
        (...
          (matcherN and?.obj
            consequent
            alternate)
          ...)
        alternate)
      alternate)))

(function and? (l r)
  `:(function and?.func (l r)
      (let (obj [@fst l]) (consequent [@frst l]) (alternate [@frrst l])
        `:(let (and?.obj ,:obj)
            ,:(loop build (expr consequent) (parts ,:[meta.bq [meta.reverse l r] `:r:r r])
              (if [emt? parts]
                expr
                (let (matcher [@fst parts])
                  {build `:(,:matcher and?.obj ,:expr ,:alternate):r [@rst parts]})))):r)):r)

(ignore
  ((guards? matcher guard) obj consequent alternate)
  ->
  (matcher obj (if guard consequent alternate) alternate))

(function guards? (l r)
  `:(function guards?.func (l r)
      (let (consequent [@frst l]) (obj [@fst l]) (alternate [@frrst l])
          (matcher ,:[meta.bq [@fst l] `:r:r r]) (guard ,:[meta.bq [@frst l] `:r:r r])
        (`(,:matcher ,:obj (if ,:guard ,:consequent ,:alternate) ,:alternate)r))):r)

(ignore
  A variant of the if-expression where the condition and the consequent are evaluated in
  the environment of the given storage bindings. The macro performs the following
  transformation:
  (bind-if cond (param1 param2 ... paramN)
    consequent
    alternate)
  ->
  (with bind-if.return (do
    (let
        (param1 (storage bind-if.temp (ignore)))
        (param2 (storage bind-if.temp (ignore)))
        ...
        (paramN (storage bind-if.temp (ignore)))
      (if cond
        {bind-if.return consequent}
        (ignore)))
    alternate)))

(function bind-if (l r)
  (let (cond [@fst l]) (params [@frst l]) (consequent [@frrst l]) (alternate [@frrrst l])
  (let (bindings [meta.map2 params r
      (function _ (elt r) (`(,:elt (storage bind-if.temp (ignore)))r)) r])
    (`(with bind-if.return (do
        (,[lst (` let r)
            [meta.reverse [lst (`(if ,:cond {bind-if.return ,:consequent} (ignore))r) bindings r] r] r])
        ,:alternate))r))))

(ignore The following function measures the length of the list given as its argument.)

(function meta.length (l)
  (loop measure (l l) (len #:0)
    (if [emt? l] len {measure [@rst l] [+ len #:1]})))

(ignore
  A macro to keep the callee's stack frame alive. Does the following transformation:
  (%:func arg1 arg2 ... argN)
  ->
  (with percent.return [func percent.return arg1 arg2 ... argN]))

(function % (l r)
  (`(function percent.func (l r)
      (let (func ,:[meta.bq [@fst l] `:r:r r])
        (`(with percent.return [,:func percent.return , l])r)))r))

(ignore
  A macro to define C-style substitution macros. Does the following transformation:
  ((define id macro) frags ...)
  ->
  (macro frags ...))

(function define (l r)
  `:(function ,:[@fst l] (l r)
      (let (macro ,:[meta.bq [@frst l] `:r:r r])
        [lst macro l r])):r)

(ignore
  A module is a set of bindings. The following macro takes a module and produces
  a macro to execute an expression in the context of the aforementioned module.
  Does the following transformation:
  ((module (id1 val1) ... (idN valN)) expr)
  ->
  (use (id1 val1) ... (idN valN) expr))

(function module (l r)
  `:(function module.func (l r)
      (let (binds ,:[meta.bq l `:r:r r])
        `:(use , [meta.reverse [lst [@fst l] binds r] r]):r)):r)

(ignore
  Define the empty module. Useful for checking constraint satisfaction of functors
  without a module that implements the required signature.)

(define _ (module))

(ignore
  A bifunction takes its first argument set by-name and produces a function taking
  the second argument set by value. The following bifunction macro does the following
  transformation:
  ((bifunction bifunction-a (frag-a frag-b ... frag-z) (param-a param-b ... param-z) expr)
    arg-a arg-b ... arg-z)
  ->
  (function bifuncation-a (param-a param-b ... param-z)
    expr with substitutions
      frag-a -> arg-a, frag-b -> arg-b, ..., frag-z -> arg-z))

(function bifunction (l r)
  (let (name [@fst l]) (ct-params [@frst l]) (rt-params [@frrst l]) (body [@frrrst l])
    `:(function ,:name (l r)
        (let (subs [meta.zip ,:[meta.bq ct-params `:r:r r] l r])
        (let (body-mod [substitute [meta.reverse [lst ,:[meta.bq body `:r:r r] subs r] r] r])
        (let (rt-params ,:[meta.bq rt-params `:r:r r])
          `:(function bifunction.func ,:rt-params ,:body-mod):r)))):r))

(ignore
  A functor maps a tuple of modules to a module comprising the given expressions.
  Does the following transformation:
  (((functor (params ...)
    (id1 val1)
    ...
    (idN valN)) args ...) expr)
  ->
  (use
      (id1 <val1 with args ... substituted for params ...>)
      ...
      (idN <valN with args ... substituted for params ...>)
    expr))

(function functor (l r)
  (let (ct-params [@fst l]) (binds [@rst l])
    `:(function functor.func (l r)
        (let (binds ,:[meta.bq binds `:r:r r]) (ct-params ,:[meta.bq ct-params `:r:r r])
        (let (binds-sub [meta.map3 binds [meta.zip ct-params l r] r
            (function _ (elt subs r) [lst [@fst elt] [substitute [meta.reverse [lst [@rst elt] subs r] r] r] r]) r])
          `:(function functor.func (l r)
              (let (binds-sub ,:[meta.bq binds-sub `:r:r r])
                `:(use , [meta.reverse [lst [@fst l] binds-sub r] r]):r)):r))):r))

(ignore
  A interface exposes and constrains a subset of the functions of a module. The
  interface macro does the following transformation:
  (((interface (var-a var-b ... var-z) r
    (id-a sig-a)
    (id-b sig-b)
    ...
    (id-z sig-z)) module-a) expr)
  ->
  (with interface.ret
    (let (interface.cont (constrain (continuation interface.cont (id-a id-b ... id-z) {interface.ret expr})
        \:r:(let (var-a [var r]) (var-b [var r]) ... (var-z [var r])
          `:(continuation (,:sig-a ,:sig-b ... ,:sig-z)):r)))
      (module-a {interface.cont id-a id-b ... id-z}))))

(function interface (l r)
  (let (buffer [@frst l]) (ids [meta.map [@rrst l] @fst r]) (sigs [meta.map [@rrst l] @frst r])
  (let (var-binds [meta.map3 [@fst l] buffer r (function _(elt buffer r) [llst elt `:[var ,:buffer]:r emt r]) r])
    `:(function interface.func (l r)
        (let (module [@fst l])
          `:(function interface.func (l r)
              (let (var-binds ,:,;[meta.bqbq var-binds `:r:r `:r:r r]) (buffer ,:,;[meta.bqbq buffer `:r:r `:r:r r]) (ids ,:,;[meta.bqbq ids `:r:r `:r:r r])
                  (sigs ,:,;[meta.bqbq sigs `:r:r `:r:r r]) (module ,:[meta.bq module `:r:r r]) (expr [@fst l]) (cont-sym [meta.concat `:interface.cont:r [gentok r] r])
                `:(with interface.ret
                    (let (,:cont-sym (constrain (continuation ,:cont-sym ,:ids {interface.ret ,:expr})
                        \:(, buffer):(let (interface.r (, buffer)) (let , [meta.reverse
                          [lst (` `:(continuation ,:,;[meta.bq [meta.map2 sigs r meta.unquote r] buffer r]):interface.r r) var-binds r] r]))))
                      (,:module {,:cont-sym , ids}))):r)):r)):r)))
