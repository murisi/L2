(ignore A complete description for bindings that will be put into generated object files.)

  (constant binding-aug #:80 \:r:[var r])

  (property bndg-name #:0 #:8 \:r:`;(! static~ string bndg-aug);r)

  (property bndg-offset #:8 #:8 \:r:(?(a) `:(! static~ ,:a bndg-aug):r r))

  (property bndg-size #:16 #:8 \:r:(?(a) `:(! static~ ,:a bndg-aug):r r))

  (property bndg-expression #:24 #:8 \:r:(?(a) `:(! static~ (expr ,:a) bndg-aug):r r))

  (property bndg-other #:32 #:8 \:r:(?(a) `:(! static~ ,:a bndg-aug):r r))
  
  (property bndg-propagate #:40 #:8 \:r:(?(a) `:(! static~ (expr ,:a) bndg-aug):r r))
  
  (property bndg-signature #:48 #:8 \:r:`;(! static~ frag bndg-aug);r)
  
  (property bndg-preferred-offset #:56 #:8 \:r:(?(a) `:(! static~ ,:a bndg-aug):r r))
  
  (property bndg-condition-jump #:64 #:8 \:r:`;(! static~ instr-code bndg-aug);r)

  (property bndg-storage #:72 #:1 \:r:`;(! static~ bndg-storage bndg-aug);r)

  (property bndg-scope #:73 #:1 \:r:`;(! static~ bndg-scope bndg-aug);r)

  (property bndg-state #:74 #:1 \:r:`;(! static~ bndg-state bndg-aug);r)
  
  (property bndg-context #:75 #:1 \:r:`;(! static~ bndg-context bndg-aug);r)
  
  (property bndg-preferred-storage #:76 #:1 \:r:`;(! static~ bndg-storage bndg-aug);r)
  
  (property bndg-mode #:77 #:1 \:r:`;(! static~ bndg-mode bndg-aug);r)
  
  (property bndg-is-read #:78 #:1 \:r:(?(a) `:(! static~ ,:a bndg-aug):r r))
  
  (property bndg-is-condition #:79 #:1 \:r:(?(a) `:(! static~ ,:a bndg-aug):r r))

(ignore Valid values for bndg-storage)

  (constant absolute-storage #:0 \:r:`;bndg-storage;r)

  (constant frame-relative-storage #:1 \:r:`;bndg-storage;r)
  
  (constant register-storage #:2 \:r:`;bndg-storage;r)

  (constant nil-storage #:3 \:r:`;bndg-storage;r)

(ignore Valid values for bndg-scope)

  (constant local-scope #:0 \:r:`;bndg-scope;r)

  (constant global-scope #:1 \:r:`;bndg-scope;r)

(ignore Valid values for bndg-state)

  (constant undefined-state #:0 \:r:`;bndg-state;r)

  (constant defined-state #:1 \:r:`;bndg-state;r)

(ignore Valid values for bndg-context)

  (constant intra-function-context #:0 \:r:`;bndg-context;r)

  (constant extra-function-context #:1 \:r:`;bndg-context;r)

(ignore Valid values for bndg-mode)

  (constant value-mode #:0 \:r:`;bndg-mode;r)

  (constant reference-mode #:1 \:r:`;bndg-mode;r)

(ignore A complete representation for L2 expressions as they are found in L2 source files.)

  (constant expression #:120 \:r:[var r])
  
  (property expr-new #:0 #:0 \:r:(?(a) `:(! dynamic~ (expr ,:a) (expr ())):r r))

  (property expr-type #:0 #:8 \:r:(?(a) `:(! static~ expr-type (expr ,:a)):r r))

  (property expr-fragment #:8 #:8 \:r:(?(a) `:(! static~ frag (expr ,:a)):r r))

  (property expr-metalink #:16 #:8 \:r:(?(a) `:(! static~ (expr ,:a) (expr ,:a)):r r))

  (property expr-lowlink #:32 #:8 \:r:(?(a b) `:(! static~ ,:b (expr ,:a)):r r))

  (property expr-dependencies #:40 #:8 \:r:(?(a) `:(! static~ (list (expr ,:a)) (expr ,:a)):r r))
  
  (property expr-binding-aug #:48 #:8 \:r:(?(a) `:(! static~ bndg-aug (expr ,:a)):r r))
  
  (property expr-generator #:56 #:8 \:r:(?(a) `:(! static~ generator (expr ,:a)):r r))
  
  (property expr-depth #:64 #:8 \:r:(?(a b) `:(! static~ ,:a (expr ,:b)):r r))
  
  (property expr-storage #:0 #:48 \:r:(?(b) `:(! static~ (expr-storage ,:b) (expr ,:b)):r r))
  
  (property expr-literal #:72 #:48 \:r:(?(b) `:(! static~ (expr-literal ,:b) (expr ,:b)):r r))
  
  (property expr-if #:72 #:48 \:r:(?(b) `:(! static~ (expr-if ,:b) (expr ,:b)):r r))
  
  (property expr-continuation #:72 #:48 \:r:(?(b) `:(! static~ (expr-continuation ,:b) (expr ,:b)):r r))
  
  (property expr-with #:72 #:48 \:r:(?(b) `:(! static~ (expr-with ,:b) (expr ,:b)):r r))
  
  (property expr-jump #:72 #:48 \:r:(?(b) `:(! static~ (expr-jump ,:b) (expr ,:b)):r r))
  
  (property expr-invoke #:72 #:48 \:r:(?(b) `:(! static~ (expr-invoke ,:b) (expr ,:b)):r r))
  
  (property expr-function #:72 #:48 \:r:(?(b) `:(! static~ (expr-function ,:b) (expr ,:b)):r r))
  
  (property expr-meta #:0 #:48 \:r:(?(b) `:(! static~ (expr-meta ,:b) (expr ,:b)):r r))
  
  (property expr-constrain #:0 #:48 \:r:(?(b) `:(! static~ (expr-constrain ,:b) (expr ,:b)):r r))

(ignore Properties of (-storage-) objects.)
  
  (property expr-storage-arguments #:80 #:8 \:r:(?(a) `:(! static~ (list (expr ,:a)) (expr ,:a)):r r))
  
  (property expr-storage-reference #:72 #:8 \:r:(?(a) `:(! static~ bndg-aug (expr ,:a)):r r))
  
(ignore Properies of (-invoke-) objects.)
  
  (property expr-invoke-target #:0 #:8 \:r:(?(a) `:(! static~ (expr ,:a) !:Ref:(expr-invoke ,:a)):r r))
  
  (property expr-invoke-arguments #:8 #:8 \:r:(?(a) `:(! static~ (list (expr ,:a)) !:Ref:(expr-invoke ,:a)):r r))
  
(ignore Properies of (-jump-) objects.)
  
  (property expr-jump-target #:0 #:8 \:r:(?(a) `:(! static~ (expr ,:a) !:Ref:(expr-jump ,:a)):r r))
  
  (property expr-jump-arguments #:8 #:8 \:r:(?(a) `:(! static~ (list (expr ,:a)) !:Ref:(expr-jump ,:a)):r r))
  
  (property expr-short-circuit #:32 #:8 \:r:(?(a b) `:(! static~ ,:a !:Ref:(expr-jump ,:b)):r r))
  
(ignore Properies of (-function-) objects.)
  
  (property expr-function-reference #:0 #:8 \:r:(?(a) `:(! static~ bndg-aug !:Ref:(expr-function ,:a)):r r))
  
  (property expr-function-expression #:8 #:8 \:r:(?(a) `:(! static~ (expr ,:a) !:Ref:(expr-function ,:a)):r r))
  
  (property expr-function-parameters #:16 #:8 \:r:(?(a) `:(! static~ (list bndg-aug) !:Ref:(expr-function ,:a)):r r))
  
  (property expr-frame-size #:24 #:8 \:r:(?(a b) `:(! static~ ,:a !:Ref:(expr-function ,:b)):r r))
  
  (property expr-registers-used #:32 #:8 \:r:(?(a) `:(! static~ reg-use-vec !:Ref:(expr-function ,:a)):r r))
  
(ignore Properies of (-continuation-) objects.)
  
  (property expr-continuation-reference #:0 #:8 \:r:(?(a) `:(! static~ bndg-aug !:Ref:(expr-continuation ,:a)):r r))
  
  (property expr-continuation-expression #:8 #:8 \:r:(?(a) `:(! static~ (expr ,:a) !:Ref:(expr-continuation ,:a)):r r))
  
  (property expr-continuation-parameters #:16 #:8 \:r:(?(a) `:(! static~ (list bndg-aug) !:Ref:(expr-continuation ,:a)):r r))
  
  (property expr-continuation-instr-bndg #:24 #:8 \:r:(?(a b) `:(! static~ ,:a !:Ref:(expr-continuation ,:b)):r r))
  
  (property expr-continuation-escapes #:32 #:8 \:r:(?(a b) `:(! static~ ,:a !:Ref:(expr-continuation ,:b)):r r))
  
  (property expr-continuation-jumps #:40 #:8 \:r:(?(a) `:(! static~ (list (expr ,:a)) !:Ref:(expr-continuation ,:a)):r r))

(ignore Properies of (-with-) objects.)
  
  (property expr-with-reference #:0 #:8 \:r:(?(a) `:(! static~ bndg-aug !:Ref:(expr-with ,:a)):r r))
  
  (property expr-with-expression #:8 #:8 \:r:(?(a) `:(! static~ (expr ,:a) !:Ref:(expr-with ,:a)):r r))
  
  (property expr-with-parameters #:16 #:8 \:r:(?(a) `:(! static~ (list bndg-aug) !:Ref:(expr-with ,:a)):r r))
  
  (property expr-with-instr-bndg #:24 #:8 \:r:(?(a b) `:(! static~ ,:a !:Ref:(expr-with ,:b)):r r))
  
  (property expr-with-escapes #:32 #:8 \:r:(?(a b) `:(! static~ ,:a !:Ref:(expr-with ,:b)):r r))
  
  (property expr-with-jumps #:40 #:8 \:r:(?(a) `:(! static~ (list (expr ,:a)) !:Ref:(expr-with ,:a)):r r))
  
(ignore Properies of (-symbol-) objects.)
  
  (property expr-symbol-reference #:72 #:8 \:r:(?(a) `:(! static~ bndg-aug (expr ,:a)):r r))
  
  (property expr-name #:80 #:8 \:r:(?(a) `:(! static~ string (expr ,:a)):r r))

(ignore Properies of (-meta-) objects.)
  
  (property expr-meta-target #:72 #:8 \:r:(?(a) `:(! static~ (expr ,:a) (expr ,:a)):r r))

(ignore Properies of (-constrain-) objects.)

  (property expr-constrain-target #:72 #:8 \:r:(?(a) `:(! static~ (expr ,:a) (expr ,:a)):r r))
  
  (property expr-constrain-expression #:80 #:8 \:r:(?(a) `:(! static~ (expr ,:a) (expr ,:a)):r r))

(ignore Properies of (-if-) objects.)

  (property expr-condition #:0 #:8 \:r:(?(a) `:(! static~ (expr ,:a) !:Ref:(expr-if ,:a)):r r))

  (property expr-consequent #:8 #:8 \:r:(?(a) `:(! static~ (expr ,:a) !:Ref:(expr-if ,:a)):r r))

  (property expr-alternate #:16 #:8 \:r:(?(a) `:(! static~ (expr ,:a) !:Ref:(expr-if ,:a)):r r))

(ignore Properies of (-literal-) objects.)

  (property expr-value #:0 #:8 \:r:(?(a b) `:(! static~ ,:a !:Ref:(expr-literal ,:b)):r r))

(ignore Valid values for expr-type.)

  (constant -storage- #:0 \:r:`;expr-type;r)

  (constant -function- #:1 \:r:`;expr-type;r)

  (constant -with- #:2 \:r:`;expr-type;r)

  (constant -invoke- #:3 \:r:`;expr-type;r)

  (constant -if- #:4 \:r:`;expr-type;r)

  (constant -literal- #:6 \:r:`;expr-type;r)

  (constant -symbol- #:7 \:r:`;expr-type;r)

  (constant -jump- #:8 \:r:`;expr-type;r)

  (constant -continuation- #:9 \:r:`;expr-type;r)

  (constant -meta- #:11 \:r:`;expr-type;r)

  (constant -constrain- #:12 \:r:`;expr-type;r)

(ignore
  Some expressions resemble each other in different ways and hence are treated
  the same for some operations. Manually implementing ad-hoc polymorphism over
  certain fields below.)

(function expr-target (n)
  (switch = (@ expr-type n)
    ((-invoke-) (& expr-invoke-target (& expr-invoke n)))
    ((-jump-) (& expr-jump-target (& expr-jump n)))
    ((-meta-) (& expr-meta-target n))
    ((-constrain-) (& expr-constrain-target n))
    [print-str (stdout) (" expr-target called on incorrect type.) (ignore)]))

(function expr-arguments (n)
  (switch = (@ expr-type n)
    ((-storage-) (& expr-storage-arguments n))
    ((-invoke-) (& expr-invoke-arguments (& expr-invoke n)))
    ((-jump-) (& expr-jump-arguments (& expr-jump n)))
    [print-str (stdout) (" expr-arguments called on incorrect type.) (ignore)]))

(function expr-reference (n)
  (switch = (@ expr-type n)
    ((-storage-) (& expr-storage-reference n))
    ((-function-) (& expr-function-reference (& expr-function n)))
    ((-continuation-) (& expr-continuation-reference (& expr-continuation n)))
    ((-with-) (& expr-with-reference (& expr-with n)))
    ((-symbol-) (& expr-symbol-reference n))
    [print-str (stdout) (" expr-reference called on incorrect type.) (ignore)]))

(function expr-expression (n)
  (switch = (@ expr-type n)
    ((-function-) (& expr-function-expression (& expr-function n)))
    ((-continuation-) (& expr-continuation-expression (& expr-continuation n)))
    ((-with-) (& expr-with-expression (& expr-with n)))
    ((-constrain-) (& expr-constrain-expression n))
    [print-str (stdout) (" expr-target called on incorrect type.) (ignore)]))

(function expr-parameters (n)
  (switch = (@ expr-type n)
    ((-function-) (& expr-function-parameters (& expr-function n)))
    ((-continuation-) (& expr-continuation-parameters (& expr-continuation n)))
    ((-with-) (& expr-with-parameters (& expr-with n)))
    [print-str (stdout) (" expr-parameters called on incorrect type.) (ignore)]))

(function expr-instr-bndg (n)
  (switch = (@ expr-type n)
    ((-continuation-) (& expr-continuation-instr-bndg (& expr-continuation n)))
    ((-with-) (& expr-with-instr-bndg (& expr-with n)))
    [print-str (stdout) (" expr-instr-bndg called on incorrect type.) (ignore)]))

(function expr-escapes (n)
  (switch = (@ expr-type n)
    ((-continuation-) (& expr-continuation-escapes (& expr-continuation n)))
    ((-with-) (& expr-with-escapes (& expr-with n)))
    [print-str (stdout) (" expr-escapes called on incorrect type.) (ignore)]))

(function expr-jumps (n)
  (switch = (@ expr-type n)
    ((-continuation-) (& expr-continuation-jumps (& expr-continuation n)))
    ((-with-) (& expr-with-jumps (& expr-with n)))
    [print-str (stdout) (" expr-jumps called on incorrect type.) (ignore)]))

(ignore
  Convenience functions for making L2 expressions. They save you from having
  to construct parameter and argument lists separately from the construction of
  the expression.)

(ignore Usage (make-functionN ref-expr (param-exprs ...) expr frag meta buf handler))

(function make-functionN (l r)
  `:[make-function ,:[@fst l] (list ,:[@rrrrrst l] , [@frst l]) ,:[@frrst l] , [@rrrst l]]:r)

(ignore Analogous to above.)

(function make-continuationN (l r)
  `:[make-continuation ,:[@fst l] (list ,:[@rrrrrst l] , [@frst l]) ,:[@frrst l] , [@rrrst l]]:r)

(ignore Usage (make-jumpN ref-expr (arg-exprs ...) frag meta buf handler))

(function make-jumpN (l r)
  `:[make-jump ,:[@fst l] (list ,:[@rrrrst l] , [@frst l]) , [@rrst l]]:r)

(ignore Analogous to above.)

(function make-invokeN (l r)
  `:[make-invoke ,:[@fst l] (list ,:[@rrrrst l] , [@frst l]) , [@rrst l]]:r)

(ignore Constant against which the length of a literal expression is checked.)

(constant build-expression-literal-len #:64 \:r:[var r])

(constrain null-expr (\ r (?(a) (` (expr ,:a) r)r)))

(storage null-expr (ignore))

(storage null-binding (ignore))

(constrain make-binding-aug
  (\ r (?(a b) (`(function (bndg-mode bndg-context bndg-storage bndg-scope bndg-state string frag (expr ,:b) region ,:a) bndg-aug)r)r)))

(function make-binding-aug (mode context stg scope state name sig expression r handler)
  (substitute (.. r handler)
    (record (_[region-alloc (binding-aug) ..])
      (bndg-context context)
      (bndg-storage stg)
      (bndg-scope scope)
      (bndg-state state)
      (bndg-name name)
      (bndg-signature sig)
      (bndg-expression expression)
      (bndg-propagate null-expr)
      (bndg-preferred-storage (nil-storage))
      (bndg-is-read (false))
      (bndg-mode mode)
      (bndg-is-condition (false))
      (bndg-condition-jump (x86-nop)))))

(constrain set-expr-is-read (\ r (?(a b) (`(function ((expr ,:b) ,:a) ())r)r)))

(function set-expr-is-read (expr val) (do
  (setf bndg-is-read (@ expr-binding-aug expr) val)
  (ignore)))

(constrain bndg-depth (\ r (?(a) (`(function (bndg-aug) ,:a)r)r)))

(function bndg-depth (bndg) (@ expr-depth (@ bndg-expression bndg)))

(constrain expr-binding-depth (\ r (?(a b) (`(function ((expr ,:b)) ,:a)r)r)))

(function expr-binding-depth (expr) [bndg-depth (@ expr-binding-aug expr)])

(constrain bndg-escapes (\ r (?(a) (`(function (bndg-aug) ,:a)r)r)))

(function bndg-escapes (bndg)
  (let (e (@ bndg-expression bndg))
    (or (and [not= (@ expr-type e) (-continuation-)] [not= (@ expr-type e) (-with-)]) $:[expr-escapes e])))

(constrain make-literal (\ r (?(a b c) (`(function (,:a frag (expr ,:c) region ,:b) (expr ()))r)r)))

(function make-literal (value frag meta reg handler)
  (substitute (.. reg handler)
    (record (t [region-alloc (expression) ..])
      (expr-new (ignore))
      (expr-type (-literal-))
      (expr-fragment frag)
      (expr-metalink meta)
      (expr-lowlink #:0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] t ..])
      (phantom (record (_ (& expr-literal t))
        (expr-value value))))))

(constrain make-symbol (\ r (?(a b) (`(function (string frag (expr ,:a) region ,:b) (expr ()))r)r)))

(function make-symbol (name frag meta reg handler)
  (substitute (.. reg handler)
    (record (sym [region-alloc (expression) ..])
      (expr-new (ignore))
      (expr-type (-symbol-))
      (expr-fragment frag)
      (expr-metalink meta)
      (expr-lowlink #:0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] sym ..])
      (expr-name name)
      (expr-symbol-reference null-binding))))

(ignore
  Makes an undefined binding with the given name. Internally, a storage expression is made
  to be the target of the symbol so as to enable type inferencing on symbols using this
  binding.)

(constrain make-undefined-binding (\ r (?(b) (`(function (string region ,:b) bndg-aug)r)r)))

(function make-undefined-binding (name r handler)
  (substitute (.. r handler)
    (let (stg [make-storage name nil null-fragment null-expr ..])
    (record (bndg (@ expr-storage-reference stg))
      (bndg-context (extra-function-context))
      (bndg-storage (absolute-storage))
      (bndg-scope (global-scope))
      (bndg-state (undefined-state))))))

(constrain expr-signature (\ r (?(a) (`(function ((expr ,:a)) frag)r)r)))

(function expr-signature (expr) (@ bndg-signature (@ expr-binding-aug expr)))

(constrain make-function (\ r (?(a b) (`(function (string (list string) (expr ,:a) frag (expr ,:a) region ,:b) (expr ()))r)r)))

(function make-function (ref params expr frag meta reg handler)
  (substitute (.. reg handler)
    (record (func [region-alloc (expression) ..])
      (expr-new (ignore))
      (expr-type (-function-))
      (expr-fragment frag)
      (expr-metalink meta)
      (expr-lowlink #:0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] func ..])
      (phantom (record (_ (& expr-function func))
        (expr-function-reference
          [make-binding-aug (reference-mode) (extra-function-context) (absolute-storage) (local-scope)
            (defined-state) ref [vbl->frag [vbl ..]] func ..])
        (expr-function-parameters
          [collect-list (map (param (%:list-iter params))
            [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
              (defined-state) param [vbl->frag [vbl ..]] func ..]) nil ..])
        (expr-function-expression expr))))))

(constrain make-continuation (\ r (?(a b) (`(function (string (list string) (expr ,:a) frag (expr ,:a) region ,:b) (expr ()))r)r)))

(function make-continuation (ref params expr frag meta reg handler)
  (substitute (.. reg handler)
    (record (cont [region-alloc (expression) ..])
      (expr-new (ignore))
      (expr-type (-continuation-))
      (expr-fragment frag)
      (expr-metalink meta)
      (expr-lowlink #:0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] cont ..])
      (phantom (record (_ (& expr-continuation cont))
        (expr-continuation-expression expr)
        (expr-continuation-escapes (false))
        (expr-continuation-jumps nil)
        (expr-continuation-reference
          [make-binding-aug (reference-mode) (intra-function-context) (nil-storage) (local-scope)
            (defined-state) ref [vbl->frag [vbl ..]] cont ..])
        (expr-continuation-parameters
          [collect-list (map (param (%:list-iter params))
            [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
              (defined-state) param [vbl->frag [vbl ..]] cont ..]) nil ..])
        (expr-continuation-instr-bndg
          [make-binding-aug (reference-mode) (extra-function-context) (absolute-storage) (local-scope)
            (defined-state) empty-string null-fragment null-expr ..]))))))

(constrain make-with (\ r (?(a b) (`(function (string (expr ,:a) frag (expr ,:a) region ,:b) (expr ()))r)r)))

(function make-with (ref expr frag meta reg handler)
  (substitute (.. reg handler)
    (record (wth [region-alloc (expression) ..])
      (expr-type (-with-))
      (expr-fragment frag)
      (expr-metalink meta)
      (expr-lowlink #:0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] wth ..])
      (phantom (record (_(& expr-with wth))
        (expr-with-escapes (false))
        (expr-with-expression expr)
        (expr-with-jumps nil)
        (expr-with-parameters [cons
          [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
            (defined-state) empty-string [vbl->frag [vbl ..]] wth ..] nil ..])
        (expr-with-reference
          [make-binding-aug (reference-mode) (intra-function-context) (nil-storage) (local-scope)
            (defined-state) ref [vbl->frag [vbl ..]] wth ..])
        (expr-with-instr-bndg
          [make-binding-aug (reference-mode) (extra-function-context) (absolute-storage) (local-scope)
            (defined-state) empty-string null-fragment null-expr ..]))))))

(constrain make-jump (\ r (?(a b) (`(function ((expr ,:a) (list (expr ,:a)) frag (expr ,:a) region ,:b) (expr ()))r)r)))

(function make-jump (ref args frag meta reg handler)
  (substitute (.. reg handler)
    (record (u [region-alloc (expression) ..])
      (expr-new (ignore))
      (expr-type (-jump-))
      (expr-fragment frag)
      (expr-metalink meta)
      (expr-lowlink #:0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] u ..])
      (phantom (record (_ (& expr-jump u))
        (expr-short-circuit null-expr)
        (expr-jump-target ref)
        (expr-jump-arguments args))))))

(constrain make-storage (\ r (?(a b) (`(function (string (list (expr ,:a)) frag (expr ,:a) region ,:b) (expr ()))r)r)))

(function make-storage (ref args frag meta reg handler)
  (substitute (.. reg handler)
    (record (u [region-alloc (expression) ..])
      (expr-new (ignore))
      (expr-type (-storage-))
      (expr-fragment frag)
      (expr-metalink meta)
      (expr-lowlink #:0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] u ..])
      (expr-storage-reference
        [make-binding-aug (reference-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) ref [vbl->frag [vbl ..]] u ..])
      (expr-storage-arguments args))))

(constrain make-meta (\ r (?(a b) (`(function ((expr ,:a) frag (expr ,:a) region ,:b) (expr ()))r)r)))

(function make-meta (ref frag meta reg handler)
  (substitute (.. reg handler)
    (record (u [region-alloc (expression) ..])
      (expr-new (ignore))
      (expr-type (-meta-))
      (expr-metalink meta)
      (expr-lowlink #:0)
      (expr-dependencies nil)
      (expr-binding-aug null-binding)
      (expr-meta-target ref)
      (expr-fragment frag))))

(constrain make-constrain (\ r (?(a b) (`(function ((expr ,:a) (expr ,:a) frag (expr ,:a) region ,:b) (expr ()))r)r)))

(function make-constrain (expr ref frag meta reg handler)
  (substitute (.. reg handler)
    (record (u [region-alloc (expression) ..])
      (expr-new (ignore))
      (expr-type (-constrain-))
      (expr-fragment frag)
      (expr-metalink meta)
      (expr-lowlink #:0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] u ..])
      (expr-constrain-target ref)
      (expr-constrain-expression expr))))

(constrain make-if (\ r (?(a b) (`(function ((expr ,:a) (expr ,:a) (expr ,:a) frag (expr ,:a) region ,:b) (expr ()))r)r)))

(function make-if (condition consequent alternate frag meta reg handler)
  (substitute (.. reg handler)
    (record (u [region-alloc (expression) ..])
      (expr-new (ignore))
      (expr-type (-if-))
      (expr-fragment frag)
      (expr-metalink meta)
      (expr-lowlink #:0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] u ..])
      (phantom (record (_ (& expr-if u))
        (expr-condition condition)
        (expr-consequent consequent)
        (expr-alternate alternate))))))

(constrain make-invoke (\ r (?(a b) (`(function ((expr ,:a) (list (expr ,:a)) frag (expr ,:a) region ,:b) (expr ()))r)r)))

(function make-invoke (ref args frag meta reg handler)
  (substitute (.. reg handler)
    (record (u [region-alloc (expression) ..])
      (expr-new (ignore))
      (expr-type (-invoke-))
      (expr-fragment frag)
      (expr-metalink meta)
      (expr-lowlink #:0)
      (expr-dependencies nil)
      (expr-binding-aug
        [make-binding-aug (value-mode) (intra-function-context) (nil-storage) (local-scope)
          (defined-state) empty-string [vbl->frag [vbl ..]] u ..])
      (phantom (record (_ (& expr-invoke u))
        (expr-invoke-target ref)
        (expr-invoke-arguments args))))))

(ignore Prints the given expression as it would be written in an L2 source file. s is an expression.)

(function print-binding (bndg hdl) (substitute (.. hdl)
  (if [getb (@ bndg-name bndg)]
    [print-str (stdout) (@ bndg-name bndg) ..]
    (do
      [print-str (stdout) (" (lparen)binding(space)) ..]
      [print-uint (stdout) bndg ..]
      [print-str (stdout) (" (rparen)) ..]))))

(constrain print-expression (\ r (?(a b) (`(function ((expr ,:b) ,:a) ())r)r)))

(function print-expression (s hdl) (substitute (.. hdl)
  (switch = (@ expr-type s)
    ((-with-) (do
      [print-str (stdout) (" (lparen)with(space)) ..]
      [print-binding (@ expr-with-reference (& expr-with s)) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-with-expression (& expr-with s)) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-storage-) (do
      [print-str (stdout) (" (lparen)storage(space)) ..]
      [print-binding (@ expr-storage-reference s) ..]
      [print-str (stdout) (" (space)) ..]
      (for (t (%:list-iter (@ expr-storage-arguments s))) (ignore) (do
        [print-expression t ..]
        [print-str (stdout) (" (space)) ..]))
      [print-str (stdout) (" (bs)) ..]
      [print-str (stdout) (switch = (@ expr-type s)
        ((-invoke-) (" (rbracket)))
        ((-jump-) (" (rbrace)))
        (" (rbracket))) ..]))
    
    ((-invoke-) (-jump-) (do
      [print-str (stdout) (switch = (@ expr-type s)
        ((-invoke-) (" (lbracket)))
        ((-jump-) (" (lbrace)))
        (ignore)) ..]
      [print-expression $:[expr-target s] ..]
      [print-str (stdout) (" (space)) ..]
      (for (t (%:list-iter $:[expr-arguments s])) (ignore) (do
        [print-expression t ..]
        [print-str (stdout) (" (space)) ..]))
      [print-str (stdout) (" (bs)) ..]
      [print-str (stdout) (switch = (@ expr-type s)
        ((-invoke-) (" (rbracket)))
        ((-jump-) (" (rbrace)))
        (" (rbracket))) ..]))
    
    ((-function-) (-continuation-) (do
      [print-str (stdout) (" (lparen)) ..]
      [print-str (stdout) (switch = (@ expr-type s)
        ((-function-) (" function))
        ((-continuation-) (" continuation))
        (ignore)) ..]
      [print-str (stdout) (" (space)) ..]
      [print-binding $:[expr-reference s] ..]
      [print-str (stdout) (" (space)(lparen)(space)) ..]
      (for (t (%:list-iter $:[expr-parameters s])) (ignore) (do
        [print-binding t ..]
        [print-str (stdout) (" (space)) ..]))
      [print-str (stdout) (" (rparen)(space)) ..]
      [print-expression $:[expr-expression s] ..]
      [print-str (stdout) (" (rparen)) ..]))
      
    ((-if-) (do
      [print-str (stdout) (" (lparen)if(space)) ..]
      [print-expression (@ expr-condition (& expr-if s)) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-consequent (& expr-if s)) ..]
      [print-str (stdout) (" (space)) ..]
      [print-expression (@ expr-alternate (& expr-if s)) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-constrain-) (do
      [print-str (stdout) (" (lparen)constrain(space)) ..]
      [print-expression (@ expr-constrain-expression s) ..]
      [print-str (stdout) (" (space)) ..]
      [print-fragment (@ bndg-signature (@ expr-binding-aug s)) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-symbol-)
      (if [getb (@ expr-name s)]
        [print-str (stdout) (@ expr-name s) ..]
        [print-binding (@ expr-symbol-reference s) ..]))
          
    ((-literal-) (do
      [print-str (stdout) (" (lparen)literal(space)) ..]
      [print-uint (stdout) (@ expr-value (& expr-literal s)) ..]
      [print-str (stdout) (" (rparen)) ..]))
    
    ((-meta-) [print-fragment (@ expr-fragment s) ..])
      
    (ignore))))

(storage special-form-error (ignore))

(ignore
  Builds an expression from a given program fragment. d is the program fragment.
  reg is the region into which the built expressions will be put. The return value
  is the constructed expression. The continuation handler will be followed with the
  tuple (special-form-error, ...) in the event of a malformed expression.)

(constrain build-expression (\ r (?(a b) (`(function (frag (expr ,:b) region ,:a) (expr ()))r)r)))

(function build-expression (frag meta reg handler) (substitute (.. reg handler)
  (if [i/f.token? frag] [make-symbol [to-string [fragment->token frag] ..] frag meta ..]
  (let (d [frag->list frag])
    (if [= [length d] #:0] {handler (storage _ special-form-error d null-fragment)}
    (switch str= [to-string [fragment->token [@car d]] ..]
      ((" with)
        (if (not [= [length d] #:3])
          {handler (storage _ special-form-error d null-fragment)}
        (if (not [i/f.token? [@cadr d]])
          {handler (storage _ special-form-error d [@cadr d])}
          [make-with [to-string [fragment->token [@cadr d]] ..] [build-expression [@caddr d] meta ..] frag meta ..])))
      
      ((" if)
        (if (not [= [length d] #:4])
          {handler (storage _ special-form-error d null-fragment)}
          [make-if [build-expression [@cadr d] meta ..] [build-expression [@caddr d] meta ..]
            [build-expression [@cadddr d] meta ..] frag meta ..]))
      
      ((" function) (" continuation)
        (if (not [= [length d] #:4])
          {handler (storage _ special-form-error d null-fragment)}
        (if (not [i/f.token? [@cadr d]])
          {handler (storage _ special-form-error d [@cadr d])}
        (if [i/f.token? [@caddr d]]
          {handler (storage _ special-form-error d [@caddr d])}
          (let (parameters [collect-list (map (v (%:list-iter [frag->list [@caddr d]]))
              (if [i/f.token? v]
                [to-string [fragment->token v] ..]
                {handler (storage _ special-form-error d v)})) nil ..])
                
            [(switch str= [to-string [fragment->token [@car d]] ..]
                ((" function) make-function)
                ((" continuation) make-continuation)
                (ignore))
              [to-string [fragment->token [@cadr d]] ..] parameters [build-expression [@cadddr d] meta ..] frag meta ..])))))
      
      ((" storage)
        (if [= [length d] #:1]
          {handler (storage _ special-form-error d null-fragment)}
        (if (and [str= [to-string [fragment->token [@car d]] ..] (" storage)] (not [i/f.token? [@cadr d]]))
          {handler (storage _ special-form-error d [@cadr d])}
          [make-storage
            [to-string [fragment->token [@cadr d]] ..] [collect-list (map (v (%:list-iter [@cddr d])) [build-expression v meta ..]) nil ..] frag meta ..])))
      
      ((" invoke) (" jump)
        (if [= [length d] #:1]
          {handler (storage _ special-form-error d null-fragment)}
        (if (and [str= [to-string [fragment->token [@car d]] ..] (" storage)] (not [i/f.token? [@cadr d]]))
          {handler (storage _ special-form-error d [@cadr d])}
          [(switch str= [to-string [fragment->token [@car d]] ..]
              ((" invoke) make-invoke)
              ((" jump) make-jump)
              (ignore))
            [build-expression [@cadr d] meta ..] [collect-list (map (v (%:list-iter [@cddr d])) [build-expression v meta ..]) nil ..] frag meta ..])))
      
      ((" literal)
        (if (not [= [length d] #:2])
          {handler (storage _ special-form-error d null-fragment)}
        (if (or (not [i/f.token? [@cadr d]]) (not [= [length [frag->list [@cadr d]]] (build-expression-literal-len)]))
          {handler (storage _ special-form-error d [@cadr d])}
          [make-literal
            (loop build-num (str [to-string [fragment->token [@cadr d]] ..]) (i (build-expression-literal-len)) (value #:0)
              (if [= i #:0]
                value
              (if [= [getb str] (char 1)]
                {build-num [+ str #:1] [- i #:1] [+ [<< value #:1] #:1]}
              (if [= [getb str] (char 0)]
                {build-num [+ str #:1] [- i #:1] [<< value #:1]}
                {handler (storage _ special-form-error d [@cadr d])})))) frag meta ..])))
      
      ((" constrain)
        (if (not [= [length d] #:3])
          {handler (storage _ special-form-error d null-fragment)}
          [make-constrain [build-expression [@cadr d] meta ..] [build-expression [@caddr d] meta ..] frag meta ..]))
      
      [make-meta [build-expression [@car d] meta ..] frag meta ..]))))))

(ignore
  Make a unary function with the given name that calls an undefined function of the same
  name with the same arguments that it received. The idea is that the intrinsic generators
  will replace the function call with inline assembly.)

(constrain make-unary-intrinsic (\ r (?(a b) (`(function (string region ,:a) (expr ,:b))r)r)))

(function make-unary-intrinsic (name buf handler)
  (substitute (.. buf handler)
    (let (callee-symbol [make-symbol empty-string null-fragment null-expr ..])
        (arg-a [make-symbol empty-string null-fragment null-expr ..])
      (let (func (make-functionN name (empty-string)
          (make-invokeN callee-symbol (arg-a) null-fragment null-expr ..) null-fragment null-expr ..)) (do
        (setf expr-symbol-reference callee-symbol [make-undefined-binding name ..])
        (setf expr-symbol-reference arg-a [@car (@ expr-function-parameters (& expr-function func))])
        func)))))

(ignore Performs actions analogous to make-unary-intrinsic, but for binary functions.)

(constrain make-binary-intrinsic (\ r (?(a b) (`(function (string region ,:a) (expr ,:b))r)r)))

(function make-binary-intrinsic (name buf handler)
  (substitute (.. buf handler)
    (let (callee-symbol [make-symbol empty-string null-fragment null-expr ..])
        (arg-a [make-symbol empty-string null-fragment null-expr ..])
        (arg-b [make-symbol empty-string null-fragment null-expr ..])
      (let (func (make-functionN name (empty-string empty-string)
          (make-invokeN callee-symbol (arg-a arg-b) null-fragment null-expr ..) null-fragment null-expr ..)) (do
        (setf expr-symbol-reference callee-symbol [make-undefined-binding name ..])
        (setf expr-symbol-reference arg-a [@car (@ expr-function-parameters (& expr-function func))])
        (setf expr-symbol-reference arg-b [@cadr (@ expr-function-parameters (& expr-function func))])
        func)))))

