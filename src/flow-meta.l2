(ignore Most macros that are about modifying control flow and their helper functions are here.)

(ignore This is false.)

(function false (l r) [=# #:0 r])

(function true (l r) [=# #:1 r])

(ignore
  The following macro iterates through its arguments in order and returns (true) upon
  encountering the first non-zero argument supplied to it. If all the arguments are zero,
  then it returns (false).)

(function cor (l r)
  (loop prepend-or (l [meta.reverse l r]) (sexpr (`(false)r))
    (if [emt? l]
      sexpr
      {prepend-or [@rst l] (`(if (,[@fst l]) (true) (, sexpr r))r)})))

(ignore
  The following macro iterates through its arguments in order and returns (false) upon
  encountering the first zero argument supplied to it. If all the arguments are non-zero,
  then it returns (true).)

(function cand (l r)
  (loop prepend-and (l [meta.reverse l r]) (sexpr (`(true)r))
    (if [emt? l]
      sexpr
      {prepend-and [@rst l] (`(if (,[@fst l]) (, sexpr r) (false))r)})))

(ignore
  The following macro returns (false) if the single argument supplied to it is non-zero.
  Otherwise it returns (true).)

(function not (l r) (`(if (,[@fst l]) (false) (true))r))

(ignore
  Reverses the given list. l is the list to be reversed. r is the region into which the
  reversed list will be put. Return value is the reversed list.)

(function meta.reverse (l r)
  (with return
    {(continuation _ (l reversed)
      (if [emt? l]
        {return reversed}
        {_ [@rst l] [lst [@fst l] reversed r]})) l emt}))

(ignore
  Maps the given list using the given function. l is the list to be mapped. ctx
  is always passed as a second argument to the mapper. mapper is the two argument
  function that will be supplied a list item as its first argument and ctx as its
  second argument and will return an argument that will be put into the corresponding
  position of another list. r is the region into which the list being constructed
  will be put. Return value is the mapped list.)

(function meta.map (l mapper r)
  (with return
    {(continuation aux (in out)
      (if [emt? in]
        {return [meta.reverse out r]}
        {aux [@rst in] [lst [mapper [@fst in]] out r]})) l emt}))

(function meta.map2 (l ctx mapper r)
  (with return
    {(continuation aux (in out)
      (if [emt? in]
        {return [meta.reverse out r]}
        {aux [@rst in] [lst [mapper [@fst in] ctx] out r]})) l emt}))

(function meta.map3 (l ctx1 ctx2 mapper r)
  (with return
    {(continuation aux (in out)
      (if [emt? in]
        {return [meta.reverse out r]}
        {aux [@rst in] [lst [mapper [@fst in] ctx1 ctx2] out r]})) l emt}))

(ignore
  The following function implements variable binding by do the following transformation:
  (let (params vals) ... expr0)
  ->
  (with let.return
    {(continuation let.aux (params ...)
      {let.return expr0}) vals ...}))

(function let (l r)
  (`(with let.return
    (,[llst (` jump r) (`(continuation let.aux (,[meta.map [@rst [meta.reverse l r]] @fst r])
      {let.return (,[@fst [meta.reverse l r]])}) r) [meta.map [@rst [meta.reverse l r]] @frst r] r])) r))

(ignore
  The following function implements variable binding by do the following transformation:
  (where expr0 (params vals) ...)
  ->
  (with let.return
    {(continuation let.aux (params ...)
      {let.return expr0}) vals ...}))

(function where (l r) [let [meta.reverse l r] r])

(ignore
  The following function implements the switch expression by doing the following transformation:
  (switch eq0 val0 (vals exprs) ... expr0)
  ->
  (let (tempeq0 eq0) (tempval0 val0)
    (if [tempeq0 tempval0 vals1]
      exprs1
      (if [tempeq0 tempval0 vals2]
        exprs2
        ...
          (if [tempeq0 tempval0 valsN]
            exprsN
            expr0)))))

(function switch (l r)
  (`(let (switch.= (,[@fst l])) (switch.val (,[@frst l]))
    (,(with return
      {(continuation aux (remaining else-clause)
        (if [emt? remaining]
          {return else-clause}
          {aux [@rst remaining]
            (`(if (,[lst (` cor r) [meta.map2 [@rst [meta.reverse [@fst remaining] r]] r
                (function _ (e r) [llllst (` invoke r) (` switch.= r) (` switch.val r) e emt r]) r] r])
              (,[@fst [meta.reverse [@fst remaining] r]]) ,else-clause) r)}))
        [@rst [meta.reverse [@rrst l] r]] [@fst [meta.reverse l r]]})))r))

(ignore
  The following function implements the following transformation:
  (fallthrough expr (labels args exprs) ...)
  ->
  (let (argN (with labelN
      (let (argN-1 (with labelN-1
          ...
              (let (arg1 (with label1
                  (let (arg0 (with label0
                      expr))
                    expr0)))
                expr1)
            ...))
        exprN-1)))
    exprN))

(function fallthrough (l r)
  (loop do-layer (acc [@fst l]) (exprs [@rst l])
    (if [emt? exprs]
      acc
      {do-layer (`(let ((,[@frfst exprs]) (with (,[@ffst exprs]) ,acc)) (,[@frrfst exprs]))r) [@rst exprs]})))

(ignore
  Syntactic sugar for continuation passing style. The next continuations is always bound.
  Transformation is as follows:
  (cps expr (conts (args ...) exprs) ...)
  ->
  (with cps.return
    (let (cont1 (continuation cont1 (arg11 arg12 ...) {cps.return
        (let (cont2 (continuation cont2 (arg21 arg22 ...) {cps.return
            ...
                (let (contN-1 (continuation contN-1 (argN-11 argN-12 ...) {cps.return
                    (let (contN (continuation contN (argN1 argN2 ...) {cps.return
                        exprN}))
                      exprN-1)}))
                  exprN-2)
              ...}))
          expr1)}))
      expr)))

(function cps (l r) (`(with cps.return
  (,[(function cps-aux (body rem-exprs r)
      (if [emt? rem-exprs]
        body
        (let (cont-name [@ffst rem-exprs]) (cont-args [@frfst rem-exprs]) (cont-expr [@frrfst rem-exprs])
          (`(let (,cont-name (continuation ,cont-name ,cont-args
                {cps.return (,[cps-aux cont-expr [@rst rem-exprs] r])}))
              ,body)r)))) [@fst l] [@rst l] r]))r))

(ignore
  The following function implements variable binding by do the following transformation:
  (loop cont (params args) ... expr0)
  ->
  (with loop.return
    {(continuation cont (params ...)
      {loop.return expr0}) vals ...}))

(function loop (l r)
  (let (bindings [meta.reverse [@rst [meta.reverse [@rst l] r]] r])
    (`(with loop.return
      (,[llst (` jump r) (`(continuation (,[@fst l]) (,[meta.map bindings @fst r])
        {loop.return (,[@fst [meta.reverse l r]])}) r) [meta.map bindings @frst r] r])) r)))

(ignore
  The following function implements an anonymous function using the following transformation:
  (\ params ... body)
  ->
  (function \.self (params ...) body))

(function \ (l r) (`(function \.self (,[meta.reverse [@rst [meta.reverse l r]]r]) (,[@fst [meta.reverse l r]]))r))

(ignore
  The following function implements sequencing by doing the following transformation:
  (do expr1 expr2 ... exprN)
  ->
  (with do.return
    {(continuation do.cont (do.arg)
      {(continuation do.cont (do.arg)
        {...
          {(continuation do.cont (do.arg) {do.return do.arg}) exprN}...}) expr2}) expr1}))

(function do (l r)
  (`(with do.return
    (,(loop make-do (acc (`{do.return do.arg}r)) (exprs [meta.reverse l r])
        (if [emt? exprs]
          acc
          {make-do (`{(continuation do.cont (do.arg) ,acc) (,[@fst exprs])}r) [@rst exprs]}))))r))

(ignore
  Takes a list of lists and make a list containing their concatenation in the given
  buffer.)

(function meta.flatten (lsts r)
  (loop flatten (acc emt) (lsts lsts)
    (if [emt? lsts]
      acc
      {flatten [meta.concat acc [@fst lsts] r] [@rst lsts]})))

(ignore
  Takes a group of expressions followed by equally lengthed groups of identifiers.
  Binds the groups of identifiers to the values of the expressions in the first
  group and then executes the body expr in this environment. The types of the bound
  identifiers are determined by their usage in expr, not by their definitions in
  the first group. Also, the type of the group of expressions is constrained to
  be that of at least one of the following groups of identifiers. Think unions
  or untagged case statements.
  
  (group-case (expr1 expr2 ... exprN) (b1 b2 ... bN) ... (z1 z2 ... zN) expr)
  ->
  (with group-case.with
    {(continuation group-case.eval (a1 a2 ... aN)
      {(constrain (continuation group-case.cont (a1 a2 ... aN b1 b2 ... bN ... z1 z2 ... zN) {group-case.with expr})
        (\ r (?(tb1 tb2 ... tbN ... tz1 tz2 ... tzN) (`(continuation (
          (,tb1 ,tb2 ... ,tbN ,tb1 ,tb2 ... ,tbN ... ,tz1 ,tz2 ... ,tzN)
          ...
          (,tz1 ,tz2 ... ,tzN ,tb1 ,tb2 ... ,tbN ... ,tz1 ,tz2 ... ,tzN), or))r)r)))
        a1 a2 ... aN [cast a1] [cast a2] ... [cast aN] ... [cast a1] [cast a2] ... [cast aN]}) expr1 expr2 ... exprN}))

(function group-case (l r)
  (let (unq (function _(elt r) [llst [lst -,- emt r] elt emt r]))
  (let (body [@fst [meta.reverse l r]])
  (let (all-groups [meta.reverse [@rst [meta.reverse l r]] r])
  (let (value-bindings [meta.label [@fst all-groups] (` group-case.id r) r])
  (let (cast-bindings [@rst all-groups])
  (let (all-bindings [lst value-bindings cast-bindings r])
  (let (value-casts [meta.map2 value-bindings r (function _(elt r) (`[cast ,elt]r)) r])
  (let (value-casts-repeated [meta.flatten [meta.map2 cast-bindings value-casts (function _(elt ctx1) ctx1) r] r])
  (let (cast-bindings-zipped [meta.zip [meta.label cast-bindings (` group-case.type r) r] cast-bindings r])
  (let (cast-binding-types [meta.map2 cast-bindings-zipped r (function _(elt r) [meta.label [@frst elt] [meta.reverse[meta.concat(` group-case.subtype r)[meta.reverse[@fst elt]r]r]r] r]) r])
  (let (cast-binding-types-unquoted [meta.map2 [meta.flatten cast-binding-types r] r unq r])
    (`(with group-case.with
        {(continuation group-case.eval ,value-bindings
          {(constrain (continuation group-case.cont (,[meta.flatten all-bindings r]) {group-case.with ,body})
            (\ r (?(,[meta.flatten cast-binding-types r]) ((,[lst -`- emt r]) (continuation (,
              (loop make-clause (cast-binding-types cast-binding-types) (clauses [llst [lst -,- emt r] [llst -o- -r- emt r] emt r])
                  (if [emt? cast-binding-types]
                    clauses
                    {make-clause [@rst cast-binding-types]
                      [lst [meta.concat [meta.map2 [@fst cast-binding-types] r unq r] cast-binding-types-unquoted r] clauses r]}))))r)r))),
            [meta.concat value-bindings value-casts-repeated r]}), [@fst all-groups]})r)))))))))))))

(ignore
  A lighter version of group-case for when the groups are singletons. Does the
  following transformation:
  (case val (a1 a2 ... aN) expr)
  ->
  (group-case (val)(a1)(a2)...(aN) expr))

(function case (l r)
  (let (body [@fst [meta.reverse l r]])
  (let (val [lst [@fst l] emt r])
  (let (binds [meta.map2 [@frst l] r (function _(elt r) [lst elt emt r]) r])
    (`(group-case ,[lst val [meta.reverse [lst body binds r] r] r])r)))))

(ignore
  Loops through the given iterator. Performs the following transformation:
  (for (x iter) def expr)
  ->
  (with for.return
    (let (for.iter iter)
      {for.iter for.return def
        (continuation for.cont (for.next for.ctx x)
          {for.next [cast for.cont] expr})})))

(function for (l r)
  (`(with for.return
      (let (for.iter (,[@frfst l]))
        {for.iter for.return (,[@frst l])
          (continuation for.cont (for.next for.ctx (,[@ffst l]))
            {for.next [cast for.cont] (,[@frrst l])})}))r))

(ignore
  Creates an iterator from from (inclusive) to to (exclusive). Performs the following
  transformation:
  (range from to)
  ->
  (continuation range.cont (range.end range.ctx range.recv)
    (let (to to) (from from)
      (loop range.count (recv range.recv) (idx from) (ctx range.ctx)
        (if [< idx to]
          (cps {recv next ctx idx}
            (next (new-recv new-ctx) {range.count new-recv [+ idx #:1] new-ctx}))
          {range.end ctx})))))

(function range (l r)
  (`(continuation range.cont (range.end range.ctx range.recv)
      (let (to (,[@frst l])) (from (,[@fst l]))
        (loop range.count (recv range.recv) (idx from) (ctx range.ctx)
          (if [< idx to]
            (cps {recv next ctx idx}
              (next (new-recv new-ctx) {range.count [cast new-recv] [+ idx #:1] new-ctx}))
            {range.end ctx}))))r))

(ignore
  Zips the two given iterators into one that yields pairs of values. Performs
  the following transformation:
  (zip-iter iter1 iter2)
  ->
  (continuation zip-iter.cont (zip-iter.end zip-iter.ctx zip-iter.recv) (cps
    {iter1 zip-iter.end zip-iter.ctx zip-iter.init2}
      
    (zip-iter.init2 (zip-iter.next1 zip-iter.ctx1 zip-iter.val1)
      {iter2 zip-iter.end zip-iter.ctx1 body1})
      
    (body1 (next2 ctx2 val2)
      {zip-iter.recv (continuation _(new-recv new-ctx) {body2 zip-iter.next1 next2 new-recv new-ctx}) ctx2 (values storage zip-iter.val1 val2)})
    
    (body2 (new-next1 new-next2 new-recv new-ctx)
      {new-next1 body3 new-ctx})
    
    (body3 (next3 ctx3 val3)
      {new-next2 body4 ctx3})
    
    (body4 (next4 ctx4 val4)
      {new-recv (continuation _(new-recv new-ctx) {body2 next3 next4 new-recv new-ctx}) ctx4 (values storage val3 val4)}))))

(function zip-iter (l r)
  (`(continuation zip-iter.cont (zip-iter.end zip-iter.ctx zip-iter.recv) (cps
      {(,[@fst l]) zip-iter.end zip-iter.ctx zip-iter.init2}
        
      (zip-iter.init2 (zip-iter.next1 zip-iter.ctx1 zip-iter.val1)
        {(,[@frst l]) zip-iter.end zip-iter.ctx1 body1})
        
      (body1 (next2 ctx2 val2)
        {zip-iter.recv (continuation _(new-recv new-ctx) {body2 zip-iter.next1 next2 new-recv new-ctx}) ctx2 (values storage zip-iter.val1 val2)})
      
      (body2 (new-next1 new-next2 new-recv new-ctx)
        {new-next1 body3 new-ctx})
      
      (body3 (next3 ctx3 val3)
        {new-next2 body4 ctx3})
      
      (body4 (next4 ctx4 val4)
        {new-recv (continuation _(new-recv new-ctx) {body2 next3 next4 new-recv new-ctx}) ctx4 (values storage val3 val4)})))r))
