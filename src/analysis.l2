(constrain defined-str= (\ r (with-vars (a) (`(function (string string) ,a)r)r)))

(function defined-str= (a b) (cand [getb a] [getb b] [str= a b]))

(constrain bndg-name= (\ r (with-vars (a) (`(function (bndg-aug bndg-aug) ,a)r)r)))

(function bndg-name= (a b) [defined-str= (@ bndg-name a) (@ bndg-name b)])

(storage multiple-definition-error (ignore))

(constrain vfind-multiple-definitions (\ r (with-vars (a) (`(function (expr ,a) expr)r)r)))

(function vfind-multiple-definitions (e handler)
  (switch = (@ expr-type e)
    ((-continuation-) (-function-) (do
      (let (ref-with-params (storage-cons (@ expr-reference e) (@ expr-parameters e)))
      (until (partial ref-with-params) [nil? partial] [@cdr partial]
        (if [nil? (find (f [@cdr partial]) [bndg-name= f [@car partial]])] (ignore)
          (let (dup-ref-name (@ bndg-name[@car partial]))
            {handler (storage _ multiple-definition-error dup-ref-name)}))))
      e))
    e))

(ignore
  A visitor to remove constrain expressions. This is a harmless operation providing that
  type-checking has been completed.)

(constrain veliminate-constrain (\ r (`(function (expr ()) expr)r)))

(function veliminate-constrain (e ctx)
  (if [= (@ expr-type e) (-constrain-)] (@ expr-expression e) e))

(ignore
  Replaces symbols with the literal or the symbol they are defined by in the cases in
  which it is possible.)

(constrain vpropagate-expressions (\ r (with-vars (a) (`(function (expr (values region ,a)) expr)r)r)))

(function vpropagate-expressions (e ctx)
  (bind (:a handler) ctx
    (if (cand [= (@ expr-type e) (-continuation-)] (not (@ expr-escapes e)) [= [length (@ expr-jumps e)] #1])
      (do
        (let (jmp [@car (@ expr-jumps e)])
          (foreach (u (@ expr-parameters e)) (v (@ expr-arguments jmp))
            (setf bndg-propagate u v)))
        e)
    (if (cand [= (@ expr-type e) (-symbol-)] [not= (@ bndg-propagate (@ expr-reference e)) null-expr]
        [= (@ expr-type (@ bndg-propagate (@ expr-reference e))) (-symbol-)])
      (do
        (setf expr-reference e (@ expr-reference (@ bndg-propagate (@ expr-reference e))))
        e)
    (if (cand [= (@ expr-type e) (-symbol-)] [not= (@ bndg-propagate (@ expr-reference e)) null-expr]
        [= (@ expr-type (@ bndg-propagate (@ expr-reference e))) (-literal-)])
      (do
        [make-literal (@ expr-value (@ bndg-propagate (@ expr-reference e))) null-fragment null-expr :a handler])
      e)))))

(ignore Does the following optimizations:
  (if (if cond <zero literal> <non-zero literal>) <consequent> <alternate>)
  ->
  (if cond <alternate> <consequent>)
  AND
  (if (if cond <non-zero literal> <zero literal>) <consequent> <alternate>)
  ->
  (if cond <consequent> <alternate>))

(constrain vswap-branches (\ r (`(function (expr ()) expr)r)))

(function vswap-branches (e ctx)
  (bind-if (match-property
      (expr-type (%[= (-if-)]))
      (expr-condition (%(guard-match (%(match-property
          (expr-type (%[= (-if-)]))
          (expr-condition (%[variable cond]))
          (expr-consequent (%(match-property
            (expr-type (%[= (-literal-)]))
            (expr-value (%[variable cons-val])))))
          (expr-alternate (%(match-property
            (expr-type (%[= (-literal-)]))
            (expr-value (%[variable alt-val])))))))
        (cand (cor $cons-val $alt-val) (not (cand $cons-val $alt-val))))))
      (expr-consequent (%[variable consequent]))
      (expr-alternate (%[variable alternate])) e)
    (cond cons-val alt-val consequent alternate) (do
      (setf expr-condition e $cond)
      (if $alt-val (do
        (setf expr-consequent e $alternate)
        (setf expr-alternate e $consequent)) (ignore))
      e)
    e))

(ignore Does the following optimizations:
  [... {expr1 ... exprN} ...] -> {expr1 ... exprN}
  {... {expr1 ... exprN} ...} -> {expr1 ... exprN}
  (if {expr1 ... exprN} cons alt) -> {expr1 ... exprN})

(constrain vdominate-jumps (\ r (`(function (expr ()) expr)r)))

(function vdominate-jumps (e ctx)
  (switch = (@ expr-type e)
    ((-invoke-) (-jump-)
      (loop search (exprs (storage-cons (@ expr-target e) (@ expr-arguments e)))
        (if [nil? exprs] e
        (if [= (@ expr-type [@car exprs]) (-jump-)] [@car exprs]
          {search [@cdr exprs]}))))
    
    ((-if-)
      (if [= (@ expr-type (@ expr-condition e)) (-jump-)]
        (@ expr-condition e)
        e))
    
    e))

(ignore Assigns depths to the given expression and its descendents.)

(constrain assign-depths (\ r (with-vars (a) (`(function (expr ,a) ())r)r)))

(function assign-depths (e depth) (do
  (setf expr-depth e depth)
  (switch = (@ expr-type e)
    ((-function-) (-continuation-) (-with-) (-constrain-)
      [assign-depths (@ expr-expression e) [+ depth #1]])
    ((-if-) (do
      [assign-depths (@ expr-condition e) [+ depth #1]]
      [assign-depths (@ expr-consequent e) [+ depth #1]]
      [assign-depths (@ expr-alternate e) [+ depth #1]]))
    ((-invoke-) (-jump-)
      (foreach (u (storage-cons (@ expr-target e) (@ expr-arguments e)))
        [assign-depths u [+ depth #1]]))
    ((-storage-)
      (foreach (u (@ expr-arguments e)) [assign-depths u [+ depth #1]]))
    (ignore))))

(ignore
  A visitor that replaces all occurences of the first binding in function/continuation
  /with parameters, symbol references, and expression bindings with the second binding.)

(constrain vreplace-value-bindings (\ r (`(function (expr (values bndg-aug bndg-aug)) expr)r)))

(function vreplace-value-bindings (e ctx)
  (bind (repl-target replacement) ctx (do
    (if [= (@ expr-binding-aug e) repl-target]
      (setf expr-binding-aug e replacement)
      (ignore))
    (switch = (@ expr-type e)
      ((-continuation-) (-with-) (-function-)
        (loop replace (rem-params (@ expr-parameters e))
          (if [nil? rem-params] e
          (if [= [@car rem-params] repl-target]
            (do (setf car rem-params replacement) {replace [@cdr rem-params]})
            {replace [@cdr rem-params]}))))
      ((-symbol-)
        (if [= (@ expr-reference e) repl-target]
          (do (setf expr-reference e replacement) e)
          e))
      e))))

(constrain assign-expr-is-reads (\ r (`(function (expr) ())r)))

(function assign-expr-is-reads (s)
  (switch = (@ expr-type s)
    ((-if-) (do
      [assign-expr-is-reads (@ expr-condition s)]
      [set-expr-is-read (@ expr-condition s) (true)]
      [assign-expr-is-reads (@ expr-consequent s)]
      [set-expr-is-read (@ expr-consequent s) (true)]
      [assign-expr-is-reads (@ expr-alternate s)]
      [set-expr-is-read (@ expr-alternate s) (true)]))
    
    ((-constrain-) (do
      [assign-expr-is-reads (@ expr-expression s)]
      [set-expr-is-read (@ expr-expression s) (true)]))
    
    ((-function-) (do
      (setf bndg-is-read (@ expr-reference s) (true))
      [assign-expr-is-reads (@ expr-expression s)]
      [set-expr-is-read (@ expr-expression s) (true)]))
    
    ((-with-) (do
      (setf bndg-is-read (@ expr-reference s) (true))
      (setf bndg-is-read [@car (@ expr-parameters s)] (true))
      [assign-expr-is-reads (@ expr-expression s)]
      [set-expr-is-read (@ expr-expression s) (true)]))
    
    ((-continuation-) (do
      (setf bndg-is-read (@ expr-reference s) (true))
      [assign-expr-is-reads (@ expr-expression s)]
      [set-expr-is-read (@ expr-expression s) (false)]))
    
    ((-storage-) (do
      (setf bndg-is-read (@ expr-reference s) (true))
      (foreach (u (@ expr-arguments s)) (do
        [assign-expr-is-reads u]
        [set-expr-is-read u (true)]))))
    
    ((-jump-) (-invoke-) (do
      [assign-expr-is-reads (@ expr-target s)]
      [set-expr-is-read (@ expr-target s) (true)]
      (foreach (u (@ expr-arguments s)) (do
        [assign-expr-is-reads u]
        [set-expr-is-read u (true)]))))
    
    ((-symbol-) (setf bndg-is-read (@ expr-reference s) (true)))
    
    (ignore)))

(constrain global-binding-augs-of (\ r (with-vars (a) (`(function ((list expr) region ,a) (hash-table string bndg-aug))r)r)))

(function global-binding-augs-of (exprs r handler)
  (substitute (.. r handler)
    (let (binding-augs [ht-create hash-str str= ..])
    (loop add-binding (exprs exprs)
      (if [nil? exprs]
        binding-augs
        (let (t [@car exprs])
          (if (cor [= (@ expr-type t) (-function-)] [= (@ expr-type t) (-storage-)])
            (do
              (setf bndg-scope (@ expr-reference t) (global-scope))
              [ht-put (@ bndg-name (@ expr-reference t)) (@ expr-reference t) binding-augs ..]
              {add-binding [@cdr exprs]})
            {add-binding [@cdr exprs]})))))))

(constrain vunlink-symbols (\ r (with-vars (a) (`(function (expr (values (hash-table string bndg-aug) region ,a)) expr)r)r)))

(function vunlink-symbols (s ctx)
  (bind (blacklist buf hdl) ctx
    (with-region buf
      (if (cand [= (@ expr-type s) (-symbol-)] [not= (@ expr-reference s) null-binding]
          [contains (@ expr-reference s) [ht-getall (@ bndg-name (@ expr-reference s)) blacklist buf hdl]])
        (do (setf expr-reference s null-binding) s)
        s))))

(constrain assign-binding (\ r (with-vars (a) (`(function (expr (hash-table string bndg-aug)) ,a)r)r)))

(function assign-binding (s bindings)
  (bind-if [ht-contains (@ expr-name s) bindings bndg]
    (bndg) (do (setf expr-reference s $bndg) (true))
    (false)))

(constrain link-symbols
  (\ r (with-vars (a b)
    (`(function (expr ,a (hash-table string bndg-aug) (hash-table string bndg-aug) (hash-table string bndg-aug) region ,b) ())r)r)))

(function link-symbols (s static-storage undefined-bindings static-bindings dynamic-bindings r handler)
  (substitute (.. r handler)
    (let (bindings (if static-storage static-bindings dynamic-bindings))
    
    (switch = (@ expr-type s)
      ((-function-) (do
        [ht-put (@ bndg-name(@ expr-reference s)) (@ expr-reference s) static-bindings ..]
        (let (dynamic-bindings [ht-create hash-str str= ..]) (do
        (foreach (u (@ expr-parameters s)) [ht-put (@ bndg-name u) u dynamic-bindings ..])
        [link-symbols (@ expr-expression s) (false) undefined-bindings static-bindings dynamic-bindings ..]))
        [ht-remove (@ bndg-name(@ expr-reference s)) static-bindings]))
      
      ((-with-) (-continuation-) (do
        [ht-put (@ bndg-name(@ expr-reference s)) (@ expr-reference s) bindings ..]
        (foreach (u (@ expr-parameters s)) [ht-put (@ bndg-name u) u bindings ..])
        [link-symbols (@ expr-expression s) static-storage undefined-bindings static-bindings dynamic-bindings ..]
        (foreach (u (@ expr-parameters s)) [ht-remove (@ bndg-name u) bindings])
        [ht-remove (@ bndg-name(@ expr-reference s)) bindings]))
      
      ((-storage-) (do
        [ht-put (@ bndg-name (@ expr-reference s)) (@ expr-reference s) bindings ..]
        (foreach (u (@ expr-arguments s))
          [link-symbols u static-storage undefined-bindings static-bindings dynamic-bindings ..])
        [ht-remove (@ bndg-name (@ expr-reference s)) bindings]))
      
      ((-symbol-)
        (if (cand [= (@ expr-reference s) null-binding] (not (if static-storage (false) [assign-binding s dynamic-bindings]))
            (not [assign-binding s static-bindings]) (not [assign-binding s undefined-bindings]))
          (let (bndg [make-undefined-binding (@ expr-name s) ..]) (do
            (setf expr-reference s bndg)
            [ht-put (@ bndg-name(@ expr-reference s)) (@ expr-reference s) undefined-bindings ..]
            (ignore)))
          (ignore)))
      
      ((-if-) (do
        [link-symbols (@ expr-condition s) static-storage undefined-bindings static-bindings dynamic-bindings ..]
        [link-symbols (@ expr-consequent s) static-storage undefined-bindings static-bindings dynamic-bindings ..]
        [link-symbols (@ expr-alternate s) static-storage undefined-bindings static-bindings dynamic-bindings ..]))
      
      ((-invoke-) (-jump-) (do
        [link-symbols (@ expr-target s) static-storage undefined-bindings static-bindings dynamic-bindings ..]
        (foreach (u (@ expr-arguments s))
          [link-symbols u static-storage undefined-bindings static-bindings dynamic-bindings ..])))
      
      ((-constrain-)
        [link-symbols (@ expr-expression s) static-storage undefined-bindings static-bindings dynamic-bindings ..])
      
      (ignore)))))

(constrain escape-analysis (\ r (with-vars (a b) (`(function (expr ,a region ,b) ())r)r)))

(function escape-analysis (s escaping r handler)
  (substitute (.. r handler)
    (switch = (@ expr-type s)
      ((-symbol-)
        (let (target-expr (@ bndg-expression (@ expr-reference s)))
          (if (cand escaping (cor [= (@ expr-type target-expr) (-continuation-)] [= (@ expr-type target-expr) (-with-)])
              [= (@ expr-reference target-expr) (@ expr-reference s)])
            (setf expr-escapes target-expr escaping)
            (ignore))))
      
      ((-if-) (do
        [escape-analysis (@ expr-condition s) (true) ..]
        [escape-analysis (@ expr-consequent s) (true) ..]
        [escape-analysis (@ expr-alternate s) (true) ..]))
      
      ((-function-) (-continuation-) (-with-) (do
        (if (cand escaping [= (@ expr-type s) (-continuation-)])
          (setf expr-escapes s escaping)
          (ignore))
        [escape-analysis (@ expr-expression s) (true) ..]))
      
      ((-storage-)
        (foreach (t (@ expr-arguments s)) [escape-analysis t (true) ..]))
      
      ((-jump-) (do
        (if [= (@ expr-type (@ expr-target s)) (-symbol-)]
          (let (target-expr (@ bndg-expression (@ expr-reference (@ expr-target s))))
          (if (cand (cor [= (@ expr-type target-expr) (-continuation-)] [= (@ expr-type target-expr) (-with-)])
              [= (@ expr-reference target-expr) (@ expr-reference (@ expr-target s))]) (do
            [prepend s (& expr-jumps target-expr) ..]
            (setf expr-short-circuit s target-expr))
            (ignore)))
        (if [= (@ expr-type (@ expr-target s)) (-continuation-)] (do
          [prepend s (& expr-jumps (@ expr-target s)) ..]
          (setf expr-short-circuit s (@ expr-target s)))
          (ignore)))
        [escape-analysis (@ expr-target s) (false) ..]
        (foreach (t (@ expr-arguments s)) [escape-analysis t (true) ..])))
      
      ((-invoke-) (do
        [escape-analysis (@ expr-target s) (true) ..]
        (foreach (t (@ expr-arguments s)) [escape-analysis t (true) ..])))
      
      ((-constrain-) [escape-analysis (@ expr-expression s) (true) ..])
      
      (ignore))))

(constrain vfind-dependencies (\ r (with-vars (a) (`(function (expr (values region ,a)) expr)r)r)))

(function vfind-dependencies (s ctx)
  (bind (r handler) ctx (substitute (.. r handler) (do
    (switch = (@ expr-type s)
      ((-if-) (do
        [prepend (@ expr-condition s) (& expr-dependencies s) ..]
        [prepend (@ expr-consequent s) (& expr-dependencies s) ..]
        [prepend (@ expr-alternate s) (& expr-dependencies s) ..]))
      
      ((-function-) (-continuation-) (-with-)
        [prepend (@ expr-expression s) (& expr-dependencies s) ..])
      
      ((-storage-)
        (foreach (t (@ expr-arguments s)) [prepend t (& expr-dependencies s) ..]))
      
      ((-jump-) (-invoke-) (do
        [prepend (@ expr-target s) (& expr-dependencies s) ..]
        (foreach (t (@ expr-arguments s)) [prepend t (& expr-dependencies s) ..])))
      
      ((-symbol-)
        (let (target-expr (@ bndg-expression (@ expr-reference s))) (do
        [prepend target-expr (& expr-dependencies s) ..]
        [prepend s (& expr-dependencies target-expr) ..])))
      
      ((-constrain-) (do
        [prepend (@ expr-expression s) (& expr-dependencies s) ..]
        [prepend s (& expr-dependencies (@ expr-expression s)) ..]))
      
      (ignore))
    s))))

(constrain construct-sccs (\ r (with-vars (a b) (`(function (expr ,a (ref (list expr)) (ref (list (list expr))) region ,b) ())r)r)))

(function construct-sccs (s preorder stack sccs r handler)
  (substitute (.. r handler)
    (if [= (@ expr-lowlink s) #0]
      (let (marker $stack) (do
      (setf expr-lowlink s preorder)
      (foreach (t (@ expr-dependencies s)) (do
        [construct-sccs t [+ preorder #1] stack sccs ..]
        (if [< (@ expr-lowlink t) (@ expr-lowlink s)]
          (setf expr-lowlink s (@ expr-lowlink t))
          (ignore))))
      [prepend s stack ..]
      
      (if [= (@ expr-lowlink s) preorder] (do
        [prepend (loop add (t $stack) (scc nil)
          (if [= t marker] scc
            (let (u [@car t]) (do
            (setf expr-lowlink u [- #0 #1])
            {add [@cdr t] [cons u scc ..]})))) sccs ..]
        [set stack marker])
        (ignore))))
      (ignore))))

(constrain occurs-in? (\ r (with-vars (a) (`(function (vbl frag (hash-table vbl frag)) ,a)r)r)))

(function occurs-in? (var val assigns)
  (let (eval [evaluate val assigns])
    (if [vbl? eval]
      [vbl= var [frag->vbl eval]]
    (if [i/f:token? eval]
      (false)
      (not [nil? (find (a [frag->list eval]) [occurs-in? var a assigns])])))))

(constrain unify-var (\ r (with-vars (a b c) (`(function (vbl frag (hash-table vbl frag) ,b region ,c) ,a)r)r)))

(function unify-var (var val assigns succ buf hdl)
  (substitute (.. buf hdl)
    (if (not [occurs-in? var val assigns])
      (cps
        (do [ht-put var val assigns ..] {succ stop})
        (stop () [ht-remove var assigns]))
      (ignore))))

(constrain unify-or (\ r (with-vars (a b c d) (`(function ((list frag) frag ,d (hash-table vbl frag) ,b region ,c) ,a)r)r)))

(function unify-or (x y rev assigns succ buf hdl)
  (substitute (.. buf hdl)
    (loop try-next (x x)
      (if [nil? x] (ignore)
        (do
          (if rev
            [unify y [@car x] assigns succ ..]
            [unify [@car x] y assigns succ ..])
          {try-next [@cdr x]})))))

(constrain unify-and (\ r (with-vars (a b c d) (`(function ((list frag) frag ,d (hash-table vbl frag) ,b region ,c) ,a)r)r)))

(function unify-and (x y rev assigns succ buf hdl)
  (substitute (.. buf hdl)
    (if [nil? x]
      (cps {succ stop} (stop () (ignore)))
      (cps
        (if rev
          [unify y [@car x] assigns iter ..]
          [unify [@car x] y assigns iter ..])
        (iter (next) (do
          [unify-and [@cdr x] y rev assigns succ ..]
          {next}))))))

(ignore
  AND and OR combinators are not commutative. Process the OR combinator first
  so as to get disjunctive normal form.)

(constrain unify (\ r (with-vars (a b c) (`(function (frag frag (hash-table vbl frag) ,b region ,c) ,a)r)r)))

(function unify (x y assigns succ buf hdl)
  (substitute (.. buf hdl)
    (let (xl [evaluate x assigns]) (yl [evaluate y assigns])
      (if (cand [vbl? xl] [vbl? yl] [vbl= [frag->vbl xl] [frag->vbl yl]])
        (cps {succ stop} (stop () (ignore)))
      (if (cand [i/f:token? xl] [i/f:token? yl])
        (if [i/f:token= [fragment->token xl] [fragment->token yl]]
          (cps {succ stop} (stop () (ignore)))
          (ignore))
      (if (cand [lst? xl] [or?! [nil-of [frag->list xl]]])
        [unify-or [frag->list xl] yl (false) assigns succ ..]
      (if (cand [lst? yl] [or?! [nil-of [frag->list yl]]])
        [unify-or [frag->list yl] xl (true) assigns succ ..]
      (if (cand [lst? xl] [and?! [nil-of [frag->list xl]]])
        [unify-and [frag->list xl] yl (false) assigns succ ..]
      (if (cand [lst? yl] [and?! [nil-of [frag->list yl]]])
        [unify-and [frag->list yl] xl (true) assigns succ ..]
      (if [vbl? xl] [unify-var [frag->vbl xl] yl assigns succ ..]
      (if [vbl? yl] [unify-var [frag->vbl yl] xl assigns succ ..]
      (if (cor [i/f:token? xl] [i/f:token? yl]) (ignore)
      (let (xl [frag->list xl]) (yl [frag->list yl])
        [(function unify-aux (xl yl assigns succ buf hdl)
          (cps
            (if (cand [nil? xl] [nil? yl])
              (cps {succ stop} (stop () (ignore)))
            (if (cor [nil? xl] [nil? yl])
              (ignore)
              [unify [@car xl] [@car yl] assigns iter ..]))
            (iter (next) (do
              [unify-aux [@cdr xl] [@cdr yl] assigns succ ..]
              {next})))) xl yl assigns succ ..])))))))))))))

(ignore
  The same function may be called with different type parameters in the same strongly connected
  component, hence we need to make sure that each equation has its own fresh type variables.)

(constrain scoped-signature (\ r (with-vars (a) (`(function (expr (list expr) region ,a) frag)r)r)))

(function scoped-signature (e scc r handler)
  (substitute (.. r handler)
    (if (not [nil? (find (x scc) [= x e])])
      [expr-signature e]
      (let (var-map [ht-create hash-ptr = ..])
        [copy-fragment [expr-signature e] var-map ..]))))

(constrain generate-equations
  (\ r (with-vars (a b) (`(function (expr (list expr) frag frag (ref (list frag)) (ref (list frag)) region ,a) ,b)r)r)))

(function generate-equations (e scc function-token continuation-token lhss rhss buf handler)
  (substitute (.. buf handler)
    (switch = (@ expr-type e)
      ((-function-)
        (let (params-signature [list->fragment (map (x (@ expr-parameters e)) (@ bndg-signature x) ..)]) (do
          [prepend [expr-signature e] [prepend [expr-signature e] lhss ..] ..]
          [prepend [list->fragment [cons function-token [cons params-signature
            [cons [expr-signature (@ expr-expression e)] nil ..] ..] ..]] [prepend (@ bndg-signature (@ expr-reference e)) rhss ..] ..])))
      
      ((-continuation-)
        (let (params-signature [list->fragment (map (x (@ expr-parameters e)) (@ bndg-signature x) ..)]) (do
          [prepend [expr-signature e] [prepend [expr-signature e] lhss ..] ..]
          [prepend [list->fragment [cons continuation-token [cons params-signature nil ..] ..]]
            [prepend (@ bndg-signature (@ expr-reference e)) rhss ..] ..])))
      
      ((-constrain-) (do
        [prepend [expr-signature e] lhss ..]
        [prepend [expr-signature (@ expr-expression e)] rhss ..]))
      
      ((-invoke-)
        (let (params-signature [list->fragment (map (arg (@ expr-arguments e)) [scoped-signature arg scc ..] ..)]) (do
          [prepend [scoped-signature (@ expr-target e) scc ..] lhss ..]
          [prepend [list->fragment [cons function-token [cons params-signature [cons [expr-signature e] nil ..] ..] ..]] rhss ..])))
      
      ((-jump-)
        (let (params-signature [list->fragment (map (arg (@ expr-arguments e)) [scoped-signature arg scc ..] ..)]) (do
          [prepend [scoped-signature (@ expr-target e) scc ..] lhss ..]
          [prepend [list->fragment [cons continuation-token [cons params-signature nil ..] ..]] rhss ..])))
      
      ((-with-)
        (let (params-signature [list->fragment [cons [expr-signature e] nil ..]]) (do
          [prepend (@ bndg-signature (@ expr-reference e)) [prepend [expr-signature e] lhss ..] ..]
          [prepend [list->fragment [cons continuation-token [cons params-signature nil ..] ..]]
            [prepend [expr-signature (@ expr-expression e)] rhss ..] ..])))
      
      ((-if-)
        (let (consequent-sig [scoped-signature (@ expr-consequent e) scc ..])
        (let (alternate-sig [scoped-signature (@ expr-alternate e) scc ..]) (do
          [prepend consequent-sig [prepend [expr-signature e] lhss ..] ..]
          [prepend alternate-sig [prepend consequent-sig rhss ..] ..]))))
      
      ((-symbol-) (do
        [prepend [expr-signature e] lhss ..]
        [prepend (@ bndg-signature (@ expr-reference e)) rhss ..]))
      
      (ignore))))

(storage unification-error (ignore))

(constrain infer-types (\ r (with-vars (a) (`(function ((list expr) region ,a) ())r)r)))

(function infer-types (exprs buf handler)
  (substitute (.. buf handler) (do
    (ignore Type inferencing is done on strongly connected components)
    (let (stack (storage _ nil))
    (let (sccs (storage _ nil)) (do
    (foreach (expr exprs) [visit-expressions vfind-dependencies (storage _ expr) (values storage ..)])
    (foreach (expr exprs) [construct-sccs expr #1 stack sccs ..])
    
    (let (assigns [ht-create hash-ptr = ..])
    (let (expr-sigs [ht-create hash-ptr = ..])
    (let (compare-map [ht-create hash-ptr = ..])
    (let (function-token [token->fragment [build-token [rstrcpy (" function) ..] ..]])
    (let (continuation-token [token->fragment [build-token [rstrcpy (" continuation) ..] ..]])
    (foreach (scc [reverse $sccs ..])
      (let (lhss (storage _ nil)) (rhss (storage _ nil)) (do
        (foreach (e scc) [generate-equations e scc function-token continuation-token lhss rhss ..])
        (if (let (has-solution? (storage _ (false)))
            (cps (do
                [unify [list->fragment $lhss] [list->fragment $rhss] assigns iter ..]
                $has-solution?)
              (iter (next) (do
                (foreach (e scc) (do
                  (let (new-sig [recursive-evaluate [expr-signature e] assigns ..])
                  (if (ht-find (old-sig e expr-sigs) [fragment= new-sig old-sig compare-map ..])
                    (ignore)
                    [ht-put e new-sig expr-sigs ..]))
                  [ht-removeall compare-map]))
                [set has-solution? (true)]
                {next}))))
          (ignore)
          {handler (storage _ unification-error)})
        (foreach (e scc)
          (let (sig-opts (storage _[ht-getall e expr-sigs ..])) (do
            (ignore Turn the list of possible types into an or type.)
            [append-list sig-opts or!]
            (setf bndg-signature (@ expr-binding-aug e) [list->fragment $sig-opts]))))))))))))))))))

(constrain visit-expressions (\ r (with-vars (a) (`(function ((function (expr ,a) expr) (ref expr) ,a) ())r)r)))

(function visit-expressions (visitor s ctx) (do
  (switch = (@ expr-type $s)
    ((-if-) (do
      [visit-expressions visitor (& expr-condition $s) ctx]
      [visit-expressions visitor (& expr-consequent $s) ctx]
      [visit-expressions visitor (& expr-alternate $s) ctx]))
    
    ((-function-) (-continuation-) (-with-) (-constrain-)
      [visit-expressions visitor (& expr-expression $s) ctx])
    
    ((-storage-)
      (until (partial (@ expr-arguments $s)) [nil? partial] [@cdr partial]
        [visit-expressions visitor (& car partial) ctx]))
    
    ((-jump-) (-invoke-) (do
      [visit-expressions visitor (& expr-target $s) ctx]
      (until (partial (@ expr-arguments $s)) [nil? partial] [@cdr partial]
        [visit-expressions visitor (& car partial) ctx])))
    
    (ignore))
  [set s [visitor $s ctx]]))

(constrain pre-visit-expressions (\ r (with-vars (a) (`(function ((function (expr ,a) expr) (ref expr) ,a) ())r)r)))

(function pre-visit-expressions (visitor s ctx) (do
  [set s [visitor $s ctx]]
  
  (switch = (@ expr-type $s)
    ((-if-) (do
      [pre-visit-expressions visitor (& expr-condition $s) ctx]
      [pre-visit-expressions visitor (& expr-consequent $s) ctx]
      [pre-visit-expressions visitor (& expr-alternate $s) ctx]))
    
    ((-function-) (-continuation-) (-with-) (-constrain-)
      [pre-visit-expressions visitor (& expr-expression $s) ctx])
    
    ((-storage-)
      (until (partial (@ expr-arguments $s)) [nil? partial] [@cdr partial]
        [pre-visit-expressions visitor (& car partial) ctx]))
    
    ((-jump-) (-invoke-) (do
      [pre-visit-expressions visitor (& expr-target $s) ctx]
      (until (partial (@ expr-arguments $s)) [nil? partial] [@cdr partial]
        [pre-visit-expressions visitor (& car partial) ctx])))
    
    (ignore))))

(constrain classify-program-bindings (\ r (`(function (expr) ())r)))

(function classify-program-bindings (expr) (do
  (setf bndg-context (@ expr-binding-aug expr) (extra-function-context))
  (switch = (@ expr-type expr)
    ((-constrain-) [classify-program-bindings (@ expr-expression expr)])
    
    ((-storage-) (do
      (setf bndg-context (@ expr-reference expr) (extra-function-context))
      (foreach (t (@ expr-arguments expr)) [classify-program-bindings t])))
    
    ((-jump-) (-invoke-) (do
      [classify-program-bindings (@ expr-target expr)]
      (foreach (t (@ expr-arguments expr)) [classify-program-bindings t])))
    
    ((-continuation-) (-with-) (do
      (setf bndg-context (@ expr-reference expr) (extra-function-context))
      (foreach (t (@ expr-parameters expr))
        (setf bndg-context t (extra-function-context)))
      [classify-program-bindings (@ expr-expression expr)]))
    
    ((-if-) (do
      [classify-program-bindings (@ expr-condition expr)]
      [classify-program-bindings (@ expr-consequent expr)]
      [classify-program-bindings (@ expr-alternate expr)]))
    
    (ignore))))

(constrain setup-collect-static-bindings (\ r (with-vars (b) (`(function (expr) ,b)r)r)))

(function setup-collect-static-bindings (n) (do
  (switch = (@ expr-type n)
    ((-continuation-) (-with-) (do
      [setup-collect-static-bindings (@ expr-expression n)]
      (if (@ expr-escapes n)
        (setf bndg-other (@ expr-reference n) (true)) (ignore))
      (foreach (t (@ expr-parameters n))
        (setf bndg-other t (true)))))
    
    ((-storage-) (do
      (setf bndg-other (@ expr-reference n) (true))
      (foreach (u (@ expr-arguments n)) [setup-collect-static-bindings u])))
    
    ((-jump-) (-invoke-) (do
      [setup-collect-static-bindings (@ expr-target n)]
      (foreach (u (@ expr-arguments n)) [setup-collect-static-bindings u])))
    
    ((-if-) (do
      [setup-collect-static-bindings (@ expr-condition n)]
      [setup-collect-static-bindings (@ expr-consequent n)]
      [setup-collect-static-bindings (@ expr-alternate n)]))
    
    ((-constrain-)
      [setup-collect-static-bindings (@ expr-expression n)])
    
    (ignore))
  
  (setf bndg-other (@ expr-binding-aug n) (true))))

(constrain append-static-binding (\ r (with-vars (a b) (`(function (bndg-aug (ref (list bndg-aug)) region ,a) ,b)r)r)))

(function append-static-binding (bndg binding-augs r handler)
  (substitute (.. r handler)
    (if (cand [= (@ bndg-storage bndg) (absolute-storage)] (@ bndg-other bndg))
      (do (setf bndg-other bndg (false)) [append bndg binding-augs ..])
      (ignore))))

(constrain collect-static-bindings (\ r (with-vars (a b) (`(function (expr (ref (list bndg-aug)) region ,a) ,b)r)r)))

(function collect-static-bindings (n binding-augs r handler)
  (substitute (.. r handler) (do
    (switch = (@ expr-type n)
      ((-continuation-) (-with-) (do
        [collect-static-bindings (@ expr-expression n) binding-augs ..]
        (if (@ expr-escapes n)
          [append-static-binding (@ expr-reference n) binding-augs ..] (ignore))
        (foreach (t (@ expr-parameters n))
          [append-static-binding t binding-augs ..])))
      
      ((-storage-) (do
        [append-static-binding (@ expr-reference n) binding-augs ..]
        (foreach (u (@ expr-arguments n)) [collect-static-bindings u binding-augs ..])))
      
      ((-jump-) (-invoke-) (do
        [collect-static-bindings (@ expr-target n) binding-augs ..]
        (foreach (u (@ expr-arguments n)) [collect-static-bindings u binding-augs ..])))
      
      ((-if-) (do
        [collect-static-bindings (@ expr-condition n) binding-augs ..]
        [collect-static-bindings (@ expr-consequent n) binding-augs ..]
        [collect-static-bindings (@ expr-alternate n) binding-augs ..]))
      
      ((-constrain-)
        [collect-static-bindings (@ expr-expression n) binding-augs ..])
      
      (ignore))
      
    [append-static-binding (@ expr-binding-aug n) binding-augs ..])))

(storage undefined-symbol-error (ignore))

(constrain preprocessed-expression-address
  (\ r (with-vars (a b) (`(function (expr (list initializer) (hash-table string bndg-aug) region region ,a) ,b)r)r)))

(function preprocessed-expression-address (s inits bindings buf :b handler)
  (substitute (.. buf handler)
    (if [= (@ expr-type s) (-symbol-)]
      (do
        (ignore
          If the expression, s, is a mere symbol, then we can just lookup its value in
          the bindings list instead of preprocessing, compiling, and then evaluating
          the expression.)
        (bind-if [ht-contains (@ expr-name s) bindings bndg]
          (bndg) (@ bndg-offset $bndg)
          {handler (storage _ undefined-symbol-error (@ expr-name s))}))
      (do
        (let (expr-container [make-function empty-string nil s null-fragment null-expr ..])
        (let (exprs-preprocessed [generate-metaprogram [cons expr-container nil ..] inits bindings buf :b handler]) (do
        [load-program-and-mutate exprs-preprocessed inits bindings buf :b handler]
        (let (expr-container-preprocessed [@car exprs-preprocessed])
        [(@ bndg-offset (@ expr-reference expr-container-preprocessed))]))))))))

(ignore
  This function replaces meta-expressions with the code generated by calling the
  corresponding expression builder. It also sets the signatures of constrain-expressions
  to the result of evaluating a signature builder.)

(constrain vgenerate-metas
  (\ r (with-vars (a) (`(function (expr (values (list initializer) (hash-table string bndg-aug) region region ,a)) expr)r)r)))

(function vgenerate-metas (s ctx)
  (bind (inits bindings buf :b handler) ctx
    (switch = (@ expr-type s)
      ((-meta-)
        (let (macro [cast [preprocessed-expression-address (@ expr-target s) inits bindings buf :b handler]])
          [vgenerate-metas [build-expression [macro [list->fragment [@cdr [frag->list (@ expr-fragment s)]]] buf] s buf handler] ctx]))
      
      ((-constrain-)
        (let (macro [cast [preprocessed-expression-address (@ expr-target s) inits bindings buf :b handler]])
          (do (setf bndg-signature (@ expr-binding-aug s) [macro buf]) s)))
      
      s)))

(constrain init-function
  (\ r (with-vars (a b) (`(function (expr (list initializer) (hash-table string bndg-aug) region region ,a (ref ,b)) ,b)r)r)))

(function init-function (function-expr inits bindings buf :b handler cache)
  (substitute (.. buf handler)
    (if [not= $cache null-cache]
      $cache
      (let (function-expr-ref (storage _ function-expr)) (do
        [pre-visit-expressions vgenerate-metas function-expr-ref (values storage inits bindings buf :b handler)]
        [load-program-and-mutate [cons $function-expr-ref nil ..] inits bindings buf :b handler]
        [set cache (@ bndg-offset (@ expr-reference $function-expr-ref))]
        $cache)))))

(storage null-cache (ignore))

(ignore
  From the supplied list of expressions, returns lazy versions of the
  contained functions. That is, the meta-expressions within the functions are
  expanded only when they are first called.)

(constrain generate-metaprogram
  (\ r (with-vars (a) (`(function ((list expr) (list initializer) (hash-table string bndg-aug) region region ,a) (list expr))r)r)))

(function generate-metaprogram (exprs inits bindings buf :b handler)
  (substitute (.. buf handler)
    [reverse (fold (c nil) (s exprs)
      (let (cache [region-alloc (unit) buf handler]) (do
        [set cache null-cache]
        
        (if [= (@ expr-type s) (-function-)]
          (let (params (reverse-map (_ (@ expr-parameters s)) empty-string ..))
          (let (args (reverse-map (_ (@ expr-parameters s)) [make-symbol empty-string null-fragment null-expr ..] ..))
          (let (thunk [make-function (@ bndg-name (@ expr-reference s)) params
            [make-invoke (make-invokeN [make-literal init-function null-fragment null-expr ..]
            ([make-literal s null-fragment null-expr ..] [make-literal inits null-fragment null-expr ..]
            [make-literal bindings null-fragment null-expr ..] [make-literal buf null-fragment null-expr ..]
            [make-literal :b null-fragment null-expr ..] [make-literal handler null-fragment null-expr ..]
            [make-literal cache null-fragment null-expr ..]) null-fragment null-expr ..) args null-fragment null-expr ..]
            null-fragment null-expr ..]) (do
          (foreach (a (@ expr-parameters thunk)) (t args) (setf expr-reference t a))
          [cons thunk c ..]))))
        
          c)))) ..]))
