< The following function wraps the arithmetic intrinsics so that the addresses of
  functions like + and - can be taken like non-intrinsic functions.>

(constrain wrap-arithmetic-intrinsics (\ r (?(a b) (`(function (region ,:a) (list (expr ,:b)))r)r)))

(function wrap-arithmetic-intrinsics (buf handler)
  (sub (.. buf handler) (list (..)
    [make-unary-intrinsic [rstrcpy (" get0b) ..] ..]
    [make-unary-intrinsic [rstrcpy (" getb) ..] ..]
    [make-unary-intrinsic [rstrcpy (" get1b) ..] ..]
    [make-unary-intrinsic [rstrcpy (" get2b) ..] ..]
    [make-unary-intrinsic [rstrcpy (" get4b) ..] ..]
    [make-unary-intrinsic [rstrcpy (" get8b) ..] ..]
    [make-unary-intrinsic [rstrcpy (" get) ..] ..]
    [make-binary-intrinsic [rstrcpy (" setb) ..] ..]
    [make-binary-intrinsic [rstrcpy (" set1b) ..] ..]
    [make-binary-intrinsic [rstrcpy (" set2b) ..] ..]
    [make-binary-intrinsic [rstrcpy (" set4b) ..] ..]
    [make-binary-intrinsic [rstrcpy (" set8b) ..] ..]
    [make-binary-intrinsic [rstrcpy (" set) ..] ..]
    [make-binary-intrinsic [rstrcpy (" +) ..] ..]
    [make-binary-intrinsic [rstrcpy (" -) ..] ..]
    [make-binary-intrinsic [rstrcpy (" *) ..] ..]
    [make-binary-intrinsic [rstrcpy (" /) ..] ..]
    [make-binary-intrinsic [rstrcpy (" rem) ..] ..]
    [make-binary-intrinsic [rstrcpy (" =) ..] ..]
    [make-binary-intrinsic [rstrcpy (" lt) ..] ..]
    [make-binary-intrinsic [rstrcpy (" gt) ..] ..]
    [make-binary-intrinsic [rstrcpy (" shl) ..] ..]
    [make-binary-intrinsic [rstrcpy (" shr) ..] ..]
    [make-binary-intrinsic [rstrcpy (" bor) ..] ..]
    [make-binary-intrinsic [rstrcpy (" bxor) ..] ..]
    [make-binary-intrinsic [rstrcpy (" band) ..] ..]
    [make-unary-intrinsic [rstrcpy (" bnot) ..] ..])))

(constrain undefined-symbol? (\ r (?(a b) (`(function ((expr ,:b)) ,:a)r)r)))

(function undefined-symbol? (n)
  (and [= (@ expr-type n) (-symbol-)]
    [= (@ bndg-state (@ expr-symbol-reference (& expr-symbol n))) (undefined-state)]))

(constrain symbol-name= (\ r (?(a b) (`(function (string (expr ,:b)) ,:a)r)r)))

(function symbol-name= (str n)
  [str= str (@ bndg-name (@ expr-symbol-reference (& expr-symbol n)))])

(constrain variable (\ r (?(a b) (`(function (!:Ref:,;b ,:b) ,:a)r)r)))

(function variable (var val) (do [set var val] (true)))

(constrain match-undefined-unary-invoke (\ r (?(a b) (`(function (!:Ref:string !:Ref:(expr ,:b) (expr ,:b)) ,:a)r)r)))

(function match-undefined-unary-invoke (name arg1 n)
  ((exprm:invoke? (property?
    (expr-invoke-target (exprm:symbol? (property?
      (expr-symbol-reference (property?
        (bndg-state (|[= (undefined-state)]))
        (bndg-name (|[variable name])))))))
    (expr-invoke-arguments (list?
      (|[variable arg1]))))) n (true) (false)))

(constrain initialize-unary-arithmetic-operators
  (\ r (?(a b c d) (`(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c)r)r)))

(function initialize-unary-arithmetic-operators (n offset inits ret-val buf hdl)
  (bind-if [match-undefined-unary-invoke name arg1 n] (name arg1)
    (let
        (arg1-val-bndg (@ expr-binding-aug $:arg1))
        (expr-val-bndg (@ expr-binding-aug n))
      (switch str= $:name
        ((" get0b) (" getb) (" get1b) (" get2b) (" get4b) (" get8b) (" get) (" bnot) (do
          [initialize-expressions (storage-cons [coalesce-expr-bndg $:arg1] nil) nil offset
            0x:FFFFFFFFFFFF0830 (@ expr-depth n) inits ret-val buf hdl]
          (setf bndg-size (@ expr-binding-aug n) (word-size))
          (setf expr-generator n [function-to-generator generate-unary-arithmetic-operators])
          (true)))
        
        (false)))
    (false)))

< If the given binding is not already in a register, a move is generated from the binding
  to the given register. Returns the register in which the value at the binding can be
  found.>

(constrain generate-move-to-register
  (\ r (?(a) (`(function (register bndg-aug !:Ref:(list instr) !:Ref:(list reloc) region ,:a) register)r)r)))

(function generate-move-to-register (reg bndg c relocs r handler)
  (sub (.. r handler)
    (if [= (@ bndg-storage bndg) (register-storage)]
      (@ bndg-offset bndg)
      (do
        [prepend (make-instrN (x86-mov) ([make-reg-op reg ..] [bndg-to-op bndg relocs ..]) ..) c ..]
        reg))))

< The following function generates inline assembly for the following functions: getb,
  get1b, get2b, get4b, get8b, get, setb, set1b, set2b, set4b, set8b, set, +, -, *, /, rem,
  =, lt, gt, shl, shr, bor, bxor, band, bnot. This function only applies to invocations of functions
  with the aforementioned names that are undefined in the invocation's lexical
  environment.>

(constrain generate-unary-arithmetic-operators
  (\ r (?(a b c) (`(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b)r)r)))

(function generate-unary-arithmetic-operators (n c relocs r handler)
  (sub (.. r handler)
    (bind-if [match-undefined-unary-invoke name arg1 n] (name arg1)
      (let
        (arg1-val-bndg (@ expr-binding-aug $:arg1))
        (expr-val-bndg (@ expr-binding-aug n))
        
      (switch str= $:name
        ((" get0b) (do
          [generate-expression $:arg1 c relocs ..]))
          
        ((" getb) (" get1b) (do
          [generate-expression $:arg1 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r11) arg1-val-bndg c relocs ..])
            [prepend (make-instrN(x86-movzx)
              ([bndg-to-op expr-val-bndg relocs ..][make-mem-op #:1 arg1-reg (none)#:0 #:0 #:4 ..][make-reg-op(r11)..])..) c ..])))
        
        ((" get2b) (do
          [generate-expression $:arg1 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r11) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-movzx)
              ([bndg-to-op expr-val-bndg relocs ..][make-mem-op #:2 arg1-reg (none)#:0 #:0 #:4 ..][make-reg-op(r11)..])..) c ..])))
        
        ((" get4b) (do
          [generate-expression $:arg1 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r11) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-movzx)
              ([bndg-to-op expr-val-bndg relocs ..][make-mem-op #:4 arg1-reg (none)#:0 #:0 #:4 ..][make-reg-op(r11)..])..) c ..])))
        
        ((" get8b) (" get) (do
          [generate-expression $:arg1 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r11) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-mov)
              ([bndg-to-op expr-val-bndg relocs ..][make-mem-op #:8 arg1-reg (none)#:0 #:0 #:4 ..][make-reg-op(r11)..])..) c ..])))
        
        ((" bnot) (do
          [generate-expression $:arg1 c relocs ..]
          [prepend (make-instrN(x86-mov)
            ([bndg-to-op expr-val-bndg relocs ..][bndg-to-op arg1-val-bndg relocs ..][make-reg-op (r11)..]) ..) c ..]
          [prepend (make-instrN (x86-not) ([bndg-to-op expr-val-bndg relocs ..]) ..) c ..]))
          
        (~)))
      (~))))

(constrain match-undefined-binary-invoke (\ r (?(a b) (`(function (!:Ref:string !:Ref:(expr ,:b) !:Ref:(expr ,:b) (expr ,:b)) ,:a)r)r)))

(function match-undefined-binary-invoke (name arg1 arg2 n)
  ((exprm:invoke? (property?
    (expr-invoke-target (exprm:symbol? (property?
      (expr-symbol-reference (property?
        (bndg-state (|[= (undefined-state)]))
        (bndg-name (|[variable name])))))))
    (expr-invoke-arguments (list?
      (|[variable arg1])
      (|[variable arg2]))))) n (true) (false)))

(constrain initialize-binary-arithmetic-operators
  (\ r (?(a b c d) (`(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c)r)r)))

(function initialize-binary-arithmetic-operators (n offset inits ret-val buf hdl)
  (bind-if [match-undefined-binary-invoke name arg1 arg2 n] (name arg1 arg2)
    (let
      (arg1-val-bndg (@ expr-binding-aug $:arg1))
      (arg2-val-bndg (@ expr-binding-aug $:arg2))
      
    (switch str= $:name
      ((" bor) (" bxor) (" band) (" +) (" -) (do
        [initialize-expressions (storage-cons [coalesce-expr-bndg $:arg1] (storage-cons [coalesce-expr-bndg $:arg2] nil))
          nil offset 0x:FFFFFFFFFFFF0C30 (@ expr-depth n) inits ret-val buf hdl]
        (setf bndg-condition-jump (@ expr-binding-aug n) (x86-jnz))
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf expr-generator n [function-to-generator generate-binary-arithmetic-operators])
        (true)))
      
      ((" =) (do
        [initialize-expressions (storage-cons [coalesce-expr-bndg $:arg1] (storage-cons [coalesce-expr-bndg $:arg2] nil))
          nil offset 0x:FFFFFFFFFFFF0C30 (@ expr-depth n) inits ret-val buf hdl]
        (setf bndg-condition-jump (@ expr-binding-aug n) (x86-je))
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf expr-generator n [function-to-generator generate-binary-arithmetic-operators])
        (true)))
      
      ((" lt) (do
        [initialize-expressions (storage-cons [coalesce-expr-bndg $:arg1] (storage-cons [coalesce-expr-bndg $:arg2] nil))
          nil offset 0x:FFFFFFFFFFFF0C30 (@ expr-depth n) inits ret-val buf hdl]
        (setf bndg-condition-jump (@ expr-binding-aug n) (x86-jb))
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf expr-generator n [function-to-generator generate-binary-arithmetic-operators])
        (true)))
      
      ((" gt) (do
        [initialize-expressions (storage-cons [coalesce-expr-bndg $:arg1] (storage-cons [coalesce-expr-bndg $:arg2] nil))
          nil offset 0x:FFFFFFFFFFFF0C30 (@ expr-depth n) inits ret-val buf hdl]
        (setf bndg-condition-jump (@ expr-binding-aug n) (x86-ja))
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf expr-generator n [function-to-generator generate-binary-arithmetic-operators])
        (true)))
      
      ((" set0b) (" setb) (" set1b) (" set2b) (" set4b) (" set8b) (" set) (do
        [initialize-expressions (storage-cons [coalesce-expr-bndg $:arg1] (storage-cons [coalesce-expr-bndg $:arg2] nil))
          nil offset 0x:FFFFFFFFFFFF0C30 (@ expr-depth n) inits ret-val buf hdl]
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf expr-generator n [function-to-generator generate-binary-arithmetic-operators])
        (true)))
      
      ((" /) (" rem) (do
        (setf bndg-preferred-storage arg1-val-bndg (register-storage))
        (setf bndg-preferred-offset arg1-val-bndg (rax))
        [initialize-expressions (storage-cons $:arg1 (storage-cons $:arg2 nil)) nil offset
          0x:FFFFFFFFFFFF0034 (@ expr-depth n) inits ret-val buf hdl]
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf expr-generator n [function-to-generator generate-binary-arithmetic-operators])
        (true)))
      
      ((" *) (do
        (setf bndg-preferred-storage arg1-val-bndg (register-storage))
        (setf bndg-preferred-offset arg1-val-bndg (rax))
        ((values? .:bottom-offset .:in-use)
          [initialize-expressions (storage-cons $:arg1 (storage-cons $:arg2 nil)) nil offset
            0x:FFFFFFFFFFFF0030 (@ expr-depth n) inits bind buf hdl] (do
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf expr-generator n [function-to-generator generate-binary-arithmetic-operators])
        (values (use-storage ret-val) bottom-offset [bor in-use 0x:0000000000000004])
        (true)) (~))))
      
      ((" shl) (" shr) (do
        (setf bndg-preferred-storage arg2-val-bndg (register-storage))
        (setf bndg-preferred-offset arg2-val-bndg (rcx))
        [initialize-expressions (storage-cons $:arg1 (storage-cons $:arg2 nil)) nil offset
          0x:FFFFFFFFFFFF0830 (@ expr-depth n) inits ret-val buf hdl]
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf expr-generator n [function-to-generator generate-binary-arithmetic-operators])
        (true)))
      
      (false)))
    (false)))

(constrain generate-binary-arithmetic-operators
  (\ r (?(a b c) (`(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b)r)r)))

(function generate-binary-arithmetic-operators (n c relocs r handler)
  (sub (.. r handler)
    (bind-if [match-undefined-binary-invoke name arg1 arg2 n] (name arg1 arg2)
      (let
        (arg1-val-bndg (@ expr-binding-aug $:arg1))
        (arg2-val-bndg (@ expr-binding-aug $:arg2))
        (expr-val-bndg (@ expr-binding-aug n))
        
      (switch str= $:name
        ((" set0b) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]))
          
        ((" setb) (" set1b) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r10) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-mov)
              ([make-mem-op #:1 arg1-reg (none)#:0 #:0 #:4 ..][bndg-to-partial-op #:1 arg2-val-bndg relocs ..][make-reg-op(r11l)..]) ..) c ..])))
        
        ((" set2b) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r10) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-mov)
              ([make-mem-op #:2 arg1-reg (none)#:0 #:0 #:4 ..][bndg-to-partial-op #:2 arg2-val-bndg relocs ..][make-reg-op(r11w)..]) ..) c ..])))
        
        ((" set4b) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r10) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-mov)
              ([make-mem-op #:4 arg1-reg (none)#:0 #:0 #:4 ..][bndg-to-partial-op #:4 arg2-val-bndg relocs ..][make-reg-op(r11d)..]) ..) c ..])))
        
        ((" set8b) (" set) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r10) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-mov)
              ([make-mem-op #:8 arg1-reg (none)#:0 #:0 #:4 ..][bndg-to-partial-op #:8 arg2-val-bndg relocs ..][make-reg-op(r11)..]) ..) c ..])))
          
        ((" +) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          [generate-bndg-bndg-move expr-val-bndg arg1-val-bndg (r11) c relocs ..]
          [prepend (make-instrN (x86-add)
            ([bndg-to-op expr-val-bndg relocs ..][bndg-to-op arg2-val-bndg relocs ..][make-reg-op (r11) ..]) ..) c ..]))
        
        ((" -) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          [generate-bndg-bndg-move expr-val-bndg arg1-val-bndg (r11) c relocs ..]
          [prepend (make-instrN (x86-sub)
            ([bndg-to-op expr-val-bndg relocs ..][bndg-to-op arg2-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]))
        
        ((" *) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (rax) ..] [bndg-to-op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mul) ([bndg-to-op arg2-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mov) ([bndg-to-op expr-val-bndg relocs ..] [make-reg-op (rax) ..]) ..) c ..]))
        
        ((" /) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          [prepend (make-instrN (x86-xor) ([make-reg-op (rdx) ..] [make-reg-op (rdx) ..]) ..) c ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (rax) ..] [bndg-to-op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-div) ([bndg-to-op arg2-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mov) ([bndg-to-op expr-val-bndg relocs ..] [make-reg-op (rax) ..]) ..) c ..]))
        
        ((" rem) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          [prepend (make-instrN (x86-xor) ([make-reg-op (rdx) ..] [make-reg-op (rdx) ..]) ..) c ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (rax) ..] [bndg-to-op arg1-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-div) ([bndg-to-op arg2-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN (x86-mov) ([bndg-to-op expr-val-bndg relocs ..] [make-reg-op (rdx) ..]) ..) c ..]))
        
        ((" =) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          (if (@ bndg-is-condition expr-val-bndg) (~)
            [prepend (make-instrN(x86-xor)
              ([bndg-to-op expr-val-bndg relocs ..][bndg-to-op expr-val-bndg relocs ..][make-reg-op (r11)..])..) c ..])
          [prepend (make-instrN(x86-cmp)
            ([bndg-to-op arg1-val-bndg relocs ..][bndg-to-op arg2-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          (if (@ bndg-is-condition expr-val-bndg) (~)
            [prepend (make-instrN (x86-setz) ([bndg-to-partial-op #:1 expr-val-bndg relocs ..]) ..) c ..])))
        
        ((" lt) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          (if (@ bndg-is-condition expr-val-bndg) (~)
            [prepend (make-instrN(x86-xor)
              ([bndg-to-op expr-val-bndg relocs ..][bndg-to-op expr-val-bndg relocs ..][make-reg-op (r11)..])..) c ..])
          [prepend (make-instrN(x86-cmp)
            ([bndg-to-op arg1-val-bndg relocs ..][bndg-to-op arg2-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          (if (@ bndg-is-condition expr-val-bndg) (~)
            [prepend (make-instrN (x86-setb) ([bndg-to-partial-op #:1 expr-val-bndg relocs ..]) ..) c ..])))
        
        ((" gt) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          (if (@ bndg-is-condition expr-val-bndg) (~)
            [prepend (make-instrN(x86-xor)
              ([bndg-to-op expr-val-bndg relocs ..][bndg-to-op expr-val-bndg relocs ..][make-reg-op (r11)..])..) c ..])
          [prepend (make-instrN(x86-cmp)
            ([bndg-to-op arg1-val-bndg relocs ..][bndg-to-op arg2-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          (if (@ bndg-is-condition expr-val-bndg) (~)
            [prepend (make-instrN (x86-seta) ([bndg-to-partial-op #:1 expr-val-bndg relocs ..]) ..) c ..])))
        
        ((" shl) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (rcx) ..] [bndg-to-op arg2-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN(x86-mov)
            ([bndg-to-op expr-val-bndg relocs ..][bndg-to-op arg1-val-bndg relocs ..][make-reg-op(r11)..])..) c ..]
          [prepend (make-instrN (x86-shl) ([bndg-to-op expr-val-bndg relocs ..] [make-reg-op (cl) ..]) ..) c ..]))
        
        ((" shr) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          [prepend (make-instrN (x86-mov) ([make-reg-op (rcx) ..] [bndg-to-op arg2-val-bndg relocs ..]) ..) c ..]
          [prepend (make-instrN(x86-mov)
            ([bndg-to-op expr-val-bndg relocs ..][bndg-to-op arg1-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN (x86-shr) ([bndg-to-op expr-val-bndg relocs ..] [make-reg-op (cl) ..]) ..) c ..]))
        
        ((" bor) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          [generate-bndg-bndg-move expr-val-bndg arg1-val-bndg (r11) c relocs ..]
          [prepend (make-instrN(x86-or)
            ([bndg-to-op expr-val-bndg relocs ..][bndg-to-op arg2-val-bndg relocs ..][make-reg-op (r11)..]) ..) c ..]))
        
        ((" bxor) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          [generate-bndg-bndg-move expr-val-bndg arg1-val-bndg (r11) c relocs ..]
          [prepend (make-instrN(x86-xor)
            ([bndg-to-op expr-val-bndg relocs ..][bndg-to-op arg2-val-bndg relocs ..][make-reg-op (r11)..]) ..) c ..]))
        
        ((" band) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-expression $:arg2 c relocs ..]
          [generate-bndg-bndg-move expr-val-bndg arg1-val-bndg (r11) c relocs ..]
          [prepend (make-instrN(x86-and)
            ([bndg-to-op expr-val-bndg relocs ..][bndg-to-op arg2-val-bndg relocs ..][make-reg-op (r11)..]) ..) c ..]))
          
        (~)))
      (~))))

(constrain match-undefined-binary-right-imm-invoke (\ r (?(a b c) (`(function (!:Ref:string !:Ref:(expr ,:c) !:Ref:,;b (expr ,:c)) ,:a)r)r)))

(function match-undefined-binary-right-imm-invoke (name arg1 arg2 n)
  ((exprm:invoke? (property?
    (expr-invoke-target (exprm:symbol? (property?
      (expr-symbol-reference (property?
        (bndg-state (|[= (undefined-state)]))
        (bndg-name (|[variable name])))))))
    (expr-invoke-arguments (list?
      (|[variable arg1])
      (exprm:literal? (property?
        (expr-value (|[variable arg2])))))))) n (true) (false)))

(constrain initialize-binary-right-imm-arithmetic-operators
  (\ r (?(a b c d) (`(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c)r)r)))

(function initialize-binary-right-imm-arithmetic-operators (n offset inits ret-val buf hdl)
  (bind-if [match-undefined-binary-right-imm-invoke name arg1 arg2 n] (name arg1 arg2)
    (switch str= $:name
      ((" set0b) (" setb) (" set1b) (" set2b) (" set4b) (" shl) (" shr) (do
        [initialize-expressions (storage-cons [coalesce-expr-bndg $:arg1] nil)
          nil offset 0x:FFFFFFFFFFFF0C30 (@ expr-depth n) inits ret-val buf hdl]
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf expr-generator n [function-to-generator generate-binary-right-imm-arithmetic-operators])
        (true)))
        
      ((" set8b) (" set) (and [sword? $:arg2] (do
        [initialize-expressions (storage-cons [coalesce-expr-bndg $:arg1] nil)
          nil offset 0x:FFFFFFFFFFFF0C30 (@ expr-depth n) inits ret-val buf hdl]
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf expr-generator n [function-to-generator generate-binary-right-imm-arithmetic-operators])
        (true))))
      
      ((" bor) (" bxor) (" band) (" +) (" -) (and (or [sbyte? $:arg2] [sword? $:arg2]) (do
        [initialize-expressions (storage-cons [coalesce-expr-bndg $:arg1] nil)
          nil offset 0x:FFFFFFFFFFFF0C30 (@ expr-depth n) inits ret-val buf hdl]
        (setf bndg-condition-jump (@ expr-binding-aug n) (x86-jnz))
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf expr-generator n [function-to-generator generate-binary-right-imm-arithmetic-operators])
        (true))))
      
      ((" =) (and (or [sbyte? $:arg2] [sword? $:arg2]) (do
        [initialize-expressions (storage-cons [coalesce-expr-bndg $:arg1] nil)
          nil offset 0x:FFFFFFFFFFFF0C30 (@ expr-depth n) inits ret-val buf hdl]
        (setf bndg-condition-jump (@ expr-binding-aug n) (x86-je))
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf expr-generator n [function-to-generator generate-binary-right-imm-arithmetic-operators])
        (true))))
      
      ((" lt) (and (or [sbyte? $:arg2] [sword? $:arg2]) (do
        [initialize-expressions (storage-cons [coalesce-expr-bndg $:arg1] nil)
          nil offset 0x:FFFFFFFFFFFF0C30 (@ expr-depth n) inits ret-val buf hdl]
        (setf bndg-condition-jump (@ expr-binding-aug n) (x86-jb))
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf expr-generator n [function-to-generator generate-binary-right-imm-arithmetic-operators])
        (true))))
      
      ((" gt) (and (or [sbyte? $:arg2] [sword? $:arg2]) (do
        [initialize-expressions (storage-cons [coalesce-expr-bndg $:arg1] nil)
          nil offset 0x:FFFFFFFFFFFF0C30 (@ expr-depth n) inits ret-val buf hdl]
        (setf bndg-condition-jump (@ expr-binding-aug n) (x86-ja))
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf expr-generator n [function-to-generator generate-binary-right-imm-arithmetic-operators])
        (true))))
      
      (false))
    (false)))

(constrain generate-binary-right-imm-arithmetic-operators
  (\ r (?(a b c) (`(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b)r)r)))

(function generate-binary-right-imm-arithmetic-operators (n c relocs r handler)
  (sub (.. r handler)
    (bind-if [match-undefined-binary-right-imm-invoke name arg1 arg2 n] (name arg1 arg2)
      (let
        (arg1-val-bndg (@ expr-binding-aug $:arg1))
        (expr-val-bndg (@ expr-binding-aug n))
        (imm-size (if [sbyte? $:arg2] #:1 (if [sword? $:arg2] #:4 (~))))
        
      (switch str= $:name
        ((" set0b) (do
          [generate-expression $:arg1 c relocs ..]))
          
        ((" setb) (" set1b) (do
          [generate-expression $:arg1 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r10) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-mov)
              ([make-mem-op #:1 arg1-reg (none)#:0 #:0 #:4 ..][make-imm-op #:1 $:arg2 ..][make-reg-op(r11l)..]) ..) c ..])))
        
        ((" set2b) (do
          [generate-expression $:arg1 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r10) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-mov)
              ([make-mem-op #:2 arg1-reg (none)#:0 #:0 #:4 ..][make-imm-op #:2 $:arg2 ..][make-reg-op(r11w)..]) ..) c ..])))
        
        ((" set4b) (do
          [generate-expression $:arg1 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r10) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-mov)
              ([make-mem-op #:4 arg1-reg (none)#:0 #:0 #:4 ..][make-imm-op #:4 $:arg2 ..][make-reg-op(r11d)..]) ..) c ..])))
        
        ((" set8b) (" set) (and [sword? $:arg2] (do
          [generate-expression $:arg1 c relocs ..]
          (let (arg1-reg [generate-move-to-register (r10) arg1-val-bndg c relocs ..])
            [prepend (make-instrN (x86-mov)
              ([make-mem-op #:8 arg1-reg (none)#:0 #:0 #:4 ..][make-imm-op #:4 $:arg2 ..][make-reg-op(r11)..]) ..) c ..]))))
          
        ((" +) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-bndg-bndg-move expr-val-bndg arg1-val-bndg (r11) c relocs ..]
          [prepend (make-instrN (x86-add)
            ([bndg-to-op expr-val-bndg relocs ..][make-imm-op imm-size $:arg2 ..][make-reg-op (r11) ..]) ..) c ..]))
        
        ((" -) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-bndg-bndg-move expr-val-bndg arg1-val-bndg (r11) c relocs ..]
          [prepend (make-instrN (x86-sub)
            ([bndg-to-op expr-val-bndg relocs ..][make-imm-op imm-size $:arg2 ..][make-reg-op (r11)..])..) c ..]))
        
        ((" =) (do
          [generate-expression $:arg1 c relocs ..]
          (if (@ bndg-is-condition expr-val-bndg) (~)
            [prepend (make-instrN(x86-xor)
              ([bndg-to-op expr-val-bndg relocs ..][bndg-to-op expr-val-bndg relocs ..][make-reg-op (r11)..])..) c ..])
          [prepend (make-instrN(x86-cmp)
            ([bndg-to-op arg1-val-bndg relocs ..][make-imm-op imm-size $:arg2 ..][make-reg-op (r11)..])..) c ..]
          (if (@ bndg-is-condition expr-val-bndg) (~)
            [prepend (make-instrN (x86-setz) ([bndg-to-partial-op #:1 expr-val-bndg relocs ..]) ..) c ..])))
        
        ((" lt) (do
          [generate-expression $:arg1 c relocs ..]
          (if (@ bndg-is-condition expr-val-bndg) (~)
            [prepend (make-instrN(x86-xor)
              ([bndg-to-op expr-val-bndg relocs ..][bndg-to-op expr-val-bndg relocs ..][make-reg-op (r11)..])..) c ..])
          [prepend (make-instrN(x86-cmp)
            ([bndg-to-op arg1-val-bndg relocs ..][make-imm-op imm-size $:arg2 ..][make-reg-op (r11)..])..) c ..]
          (if (@ bndg-is-condition expr-val-bndg) (~)
            [prepend (make-instrN (x86-setc) ([bndg-to-partial-op #:1 expr-val-bndg relocs ..]) ..) c ..])))
        
        ((" gt) (do
          [generate-expression $:arg1 c relocs ..]
          (if (@ bndg-is-condition expr-val-bndg) (~)
            [prepend (make-instrN(x86-xor)
              ([bndg-to-op expr-val-bndg relocs ..][bndg-to-op expr-val-bndg relocs ..][make-reg-op (r11)..])..) c ..])
          [prepend (make-instrN(x86-cmp)
            ([bndg-to-op arg1-val-bndg relocs ..][make-imm-op imm-size $:arg2 ..][make-reg-op (r11)..])..) c ..]
          (if (@ bndg-is-condition expr-val-bndg) (~)
            [prepend (make-instrN (x86-seta) ([bndg-to-partial-op #:1 expr-val-bndg relocs ..]) ..) c ..])))
        
        ((" shl) (do
          [generate-expression $:arg1 c relocs ..]
          [prepend (make-instrN(x86-mov)
            ([bndg-to-op expr-val-bndg relocs ..][bndg-to-op arg1-val-bndg relocs ..][make-reg-op(r11)..])..) c ..]
          [prepend (make-instrN (x86-shl) ([bndg-to-op expr-val-bndg relocs ..] [make-imm-op #:1 $:arg2 ..]) ..) c ..]))
        
        ((" shr) (do
          [generate-expression $:arg1 c relocs ..]
          [prepend (make-instrN(x86-mov)
            ([bndg-to-op expr-val-bndg relocs ..][bndg-to-op arg1-val-bndg relocs ..][make-reg-op (r11)..])..) c ..]
          [prepend (make-instrN (x86-shr) ([bndg-to-op expr-val-bndg relocs ..] [make-imm-op #:1 $:arg2 ..]) ..) c ..]))
        
        ((" bor) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-bndg-bndg-move expr-val-bndg arg1-val-bndg (r11) c relocs ..]
          [prepend (make-instrN(x86-or)
            ([bndg-to-op expr-val-bndg relocs ..][make-imm-op imm-size $:arg2 ..][make-reg-op (r11)..]) ..) c ..]))
        
        ((" bxor) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-bndg-bndg-move expr-val-bndg arg1-val-bndg (r11) c relocs ..]
          [prepend (make-instrN(x86-xor)
            ([bndg-to-op expr-val-bndg relocs ..][make-imm-op imm-size $:arg2 ..][make-reg-op (r11)..]) ..) c ..]))
        
        ((" band) (do
          [generate-expression $:arg1 c relocs ..]
          [generate-bndg-bndg-move expr-val-bndg arg1-val-bndg (r11) c relocs ..]
          [prepend (make-instrN(x86-and)
            ([bndg-to-op expr-val-bndg relocs ..][make-imm-op imm-size $:arg2 ..][make-reg-op (r11)..]) ..) c ..]))
          
        (~)))
      (~))))

(function sbyte? (val)
  (or [= val [band val 0x:000000000000007F]] [= val [bor val 0x:FFFFFFFFFFFFFF80]]))

(function sword? (val)
  (or [= val [band val 0x:000000007FFFFFFF]] [= val [bor val 0x:FFFFFFFF80000000]]))

(function match-get-base+offset (name base offset n)
  ((exprm:invoke? (property?
    (expr-invoke-target (|[undefined-symbol?]))
    (expr-invoke-target (exprm:symbol? (property? (expr-symbol-reference
      (property? (bndg-name (|[variable name])))))))
    (expr-invoke-arguments (list?
      (exprm:invoke? (property?
        (expr-invoke-target (|[undefined-symbol?]))
        (expr-invoke-target (|[symbol-name= (" +)]))
        (expr-invoke-arguments
          (or?
            (list?
              (exprm:literal? (property?
                (expr-value (|[variable offset]))))
              (|[variable base]))
            (list?
              (|[variable base])
              (exprm:literal? (property?
                (expr-value (|[variable offset]))))))))))))) n (true) (false)))

(constrain initialize-get-base+offset
  (\ r (?(a b c d) (`(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c)r)r)))

(function initialize-get-base+offset (n offset inits ret-val buf hdl)
  (bind-if (and [match-get-base+offset name base addr-offset n] [sbyte? $:addr-offset])
    (name base addr-offset)
      (let
          (base-val-bndg (@ expr-binding-aug $:base))
          (expr-val-bndg (@ expr-binding-aug n))
        (switch str= $:name
          ((" get0b) (" getb) (" get1b) (" get2b) (" get4b) (" get8b) (" get) (do
            [initialize-expressions (storage-cons [coalesce-expr-bndg $:base] nil) nil offset
              0x:FFFFFFFFFFFF0830 (@ expr-depth n) inits ret-val buf hdl]
            (setf bndg-size (@ expr-binding-aug n) (word-size))
            (setf expr-generator n [function-to-generator generate-get-base+offset])
            (true)))
          
          (false)))
    (false)))

(constrain generate-get-base+offset
  (\ r (?(a b c) (`(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b)r)r)))

(function generate-get-base+offset (n c relocs r handler)
  (sub (.. r handler)
    (bind-if [match-get-base+offset name base offset n]
      (name base offset)
        (if [sbyte? $:offset]
          (switch str= $:name
            ((" get0b) (do
              [generate-expression $:base c relocs ..]))
              
            ((" getb) (" get1b) (do
              [generate-expression $:base c relocs ..]
              (let (base-reg [generate-move-to-register (r11) (@ expr-binding-aug $:base) c relocs ..])
                [prepend (make-instrN (x86-movzx) ([bndg-to-op (@ expr-binding-aug n) relocs ..]
                  [make-mem-op #:1 base-reg (none)#:0 $:offset #:1 ..] [make-reg-op(r11)..]) ..) c ..])))
            
            ((" get2b) (do
              [generate-expression $:base c relocs ..]
              (let (base-reg [generate-move-to-register (r11) (@ expr-binding-aug $:base) c relocs ..])
                [prepend (make-instrN (x86-movzx) ([bndg-to-op (@ expr-binding-aug n) relocs ..]
                  [make-mem-op #:2 base-reg (none)#:0 $:offset #:1 ..] [make-reg-op(r11)..]) ..) c ..])))
            
            ((" get4b) (do
              [generate-expression $:base c relocs ..]
              (let (base-reg [generate-move-to-register (r11) (@ expr-binding-aug $:base) c relocs ..])
                [prepend (make-instrN (x86-movzx) ([bndg-to-op (@ expr-binding-aug n) relocs ..]
                  [make-mem-op #:4 base-reg (none)#:0 $:offset #:1 ..] [make-reg-op(r11)..]) ..) c ..])))
            
            ((" get) (" get8b) (do
              [generate-expression $:base c relocs ..]
              (let (base-reg [generate-move-to-register (r11) (@ expr-binding-aug $:base) c relocs ..])
                [prepend (make-instrN (x86-mov) ([bndg-to-op (@ expr-binding-aug n) relocs ..]
                  [make-mem-op(word-size)base-reg(none)#:0 $:offset #:1 ..] [make-reg-op(r11)..]) ..) c ..])))
            (~))
          (~))
      (~))))

(function match-set-base+offset (name base offset value n)
  ((exprm:invoke? (property?
    (expr-invoke-target (|[undefined-symbol?]))
    (expr-invoke-target (exprm:symbol? (property? (expr-symbol-reference
      (property? (bndg-name (|[variable name])))))))
    (expr-invoke-arguments (list?
      (exprm:invoke? (property?
          (expr-invoke-target (|[undefined-symbol?]))
          (expr-invoke-target (|[symbol-name= (" +)]))
          (expr-invoke-arguments
            (or?
              (list?
                (exprm:literal? (property?
                  (expr-value (|[variable offset]))))
                (|[variable base]))
              (list?
                (|[variable base])
                (exprm:literal? (property?
                  (expr-value (|[variable offset])))))))))
      (|[variable value]))))) n (true) (false)))

(constrain initialize-set-base+offset
  (\ r (?(a b c d) (`(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c)r)r)))

(function initialize-set-base+offset (n offset inits ret-val buf hdl)
  (bind-if [match-set-base+offset name base addr-offset val n] (name base addr-offset val)
    (let
      (base-val-bndg (@ expr-binding-aug $:base))
      (val-val-bndg (@ expr-binding-aug $:val))
      (expr-val-bndg (@ expr-binding-aug n))
      
    (switch str= $:name
      ((" set0b) (" setb) (" set1b) (" set2b) (" set4b) (" set8b) (" set) (do
        [initialize-expressions (storage-cons [coalesce-expr-bndg $:base] (storage-cons [coalesce-expr-bndg $:val] nil))
          nil offset 0x:FFFFFFFFFFFF0C30 (@ expr-depth n) inits ret-val buf hdl]
        (setf bndg-size (@ expr-binding-aug n) (word-size))
        (setf expr-generator n [function-to-generator generate-set-base+offset])
        (true)))
      
      (false)))
    (false)))

(constrain generate-set-base+offset
  (\ r (?(a b c) (`(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b)r)r)))

(function generate-set-base+offset (n c relocs r handler)
  (sub (.. r handler)
    (bind-if [match-set-base+offset name base offset value n]
      (name base offset value)
        (if [sbyte? $:offset]
          (switch str= $:name
            ((" set0b) (do
              [generate-expression $:value c relocs ..]
              [generate-expression $:base c relocs ..]))
              
            ((" setb) (" set1b) (do
              [generate-expression $:value c relocs ..]
              [generate-expression $:base c relocs ..]
              (let (base-reg [generate-move-to-register (r10) (@ expr-binding-aug $:base) c relocs ..])
                [prepend (make-instrN (x86-mov) ([make-mem-op #:1 base-reg (none)#:0 $:offset #:1 ..]
                  [bndg-to-partial-op #:1 (@ expr-binding-aug $:value) relocs ..] [make-reg-op(r11)..]) ..) c ..])))
            
            ((" set2b) (do
              [generate-expression $:value c relocs ..]
              [generate-expression $:base c relocs ..]
              (let (base-reg [generate-move-to-register (r10) (@ expr-binding-aug $:base) c relocs ..])
                [prepend (make-instrN (x86-mov) ([make-mem-op #:2 base-reg (none)#:0 $:offset #:1 ..]
                  [bndg-to-partial-op #:2 (@ expr-binding-aug $:value) relocs ..] [make-reg-op(r11)..]) ..) c ..])))
            
            ((" set4b) (do
              [generate-expression $:value c relocs ..]
              [generate-expression $:base c relocs ..]
              (let (base-reg [generate-move-to-register (r10) (@ expr-binding-aug $:base) c relocs ..])
                [prepend (make-instrN (x86-mov) ([make-mem-op #:4 base-reg (none)#:0 $:offset #:1 ..]
                  [bndg-to-partial-op #:4 (@ expr-binding-aug $:value) relocs ..] [make-reg-op(r11)..]) ..) c ..])))
            
            ((" set) (" set8b) (do
              [generate-expression $:value c relocs ..]
              [generate-expression $:base c relocs ..]
              (let (base-reg [generate-move-to-register (r10) (@ expr-binding-aug $:base) c relocs ..])
                [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)base-reg(none)#:0 $:offset #:1 ..]
                  [bndg-to-op (@ expr-binding-aug $:value) relocs ..] [make-reg-op(r11)..]) ..) c ..])))
                  
            (~))
          (~))
      (~))))

(constrain initialize-arithmetic-intrinsics
  (\ r (?(a b c d) (`(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c)r)r)))

(function initialize-arithmetic-intrinsics (n offset inits ret-val buf hdl)
  (sub (.. buf hdl) (or
    [initialize-get-base+offset n offset inits ret-val ..]
    [initialize-set-base+offset n offset inits ret-val ..]
    [initialize-unary-arithmetic-operators n offset inits ret-val ..]
    [initialize-binary-right-imm-arithmetic-operators n offset inits ret-val ..]
    [initialize-binary-arithmetic-operators n offset inits ret-val ..])))

