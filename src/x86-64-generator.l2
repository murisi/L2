(constant word-size #:8 \:r:[var r])

(-- Offsets for the register contents in the continuation buffer.)

  (constant cont-size [* #:7 (word-size)] \:r:[var r])

  (constant cont-r15 [* #:6 (word-size)] \:r:[var r])

  (constant cont-r12 [* #:5 (word-size)] \:r:[var r])

  (constant cont-rbx [* #:4 (word-size)] \:r:[var r])

  (constant cont-r13 [* #:3 (word-size)] \:r:[var r])

  (constant cont-r14 [* #:2 (word-size)] \:r:[var r])

  (constant cont-cir [* #:1 (word-size)] \:r:[var r])

  (constant cont-rbp [* #:0 (word-size)] \:r:[var r])

(constant callee-saved-x64-r64s-len #:5 \:r:[var r])

(storage callee-saved-x64-r64s (rbx)(r12)(r13)(r14)(r15))

(-- Looks up the (non-register) memory storage associated with a given context.)

(constrain context->memory-storage \:r:(`(function (bndg-context) bndg-storage)r))

(function context->memory-storage (context)
  (switch = context
    ((intra-function-context) (frame-relative-storage))
    ((extra-function-context) (absolute-storage))
    (~)))

(-- Storage expressions and escaping continuations need to store data that persists beyond
  the evaluation of the expression. That is, the buffers associated with the
  aforementioned expressions cannot be overwritten. Hence we need to place them in
  distinct locations.)

(constrain place-perm-bindings \:r:(?(a b) (`(function ((expr ,:b) ,:a) ,:a)r)r))

(function place-perm-bindings (n offset)
  (switch = (@ expr:type n)
    ((-function-) (do
      (setf expr:frame-size (& expr:function n) [place-perm-bindings (@ expr:function-expression (& expr:function n)) [- #:0 [* (callee-saved-x64-r64s-len)(word-size)]]])
      offset))
    
    ((-constrain-)
      [place-perm-bindings (@ expr:constrain-expression (& expr:constrain n)) offset])
    
    ((-invoke-) (-jump-)
      (let (offset [place-perm-bindings $:[expr-target n] offset])
      (fold (offset offset) (u (%:list-iter $:[expr-arguments n])) [place-perm-bindings u offset])))
    
    ((-if-)
      (let (offset [place-perm-bindings (@ expr:condition (& expr:if n)) offset])
      (let (offset [place-perm-bindings (@ expr:consequent (& expr:if n)) offset])
      (let (offset [place-perm-bindings (@ expr:alternate (& expr:if n)) offset])
        offset))))
    
    ((-continuation-) (-with-)
      (if $:[expr-escapes n]
        (let (offset [- offset [* [length $:[expr-parameters n]] (word-size)]]) (do
          (for (offset (%:range-from offset (word-size))) (t (%:list-iter $:[expr-parameters n])) (~) (do
            (setf bndg-preferred-storage t [context->memory-storage (@ bndg-context t)])
            (setf bndg-preferred-offset t offset)
            (setf bndg-size t (word-size))))
          (let (cont-bndg $:[expr-reference n]) (offset [- offset (cont-size)]) (do
          (setf bndg-storage cont-bndg [context->memory-storage (@ bndg-context cont-bndg)])
          (setf bndg-size cont-bndg (cont-size))
          (setf bndg-offset cont-bndg offset)
          [place-perm-bindings $:[expr-expression n] offset]))))
        (let (cont-bndg $:[expr-reference n]) (do
          (setf bndg-storage cont-bndg [context->memory-storage (@ bndg-context cont-bndg)])
          (setf bndg-size cont-bndg #:0)
          (setf bndg-offset cont-bndg offset)
          [place-perm-bindings $:[expr-expression n] offset]))))
    
    ((-storage-)
      (let (storage-size [* [length (@ expr:storage-arguments (& expr:storage n))] (word-size)])
      (let (offset [- offset storage-size]) (do
      (setf bndg-size (@ expr:storage-reference (& expr:storage n)) storage-size)
      (setf bndg-offset (@ expr:storage-reference (& expr:storage n)) offset)
      (setf bndg-storage (@ expr:storage-reference (& expr:storage n)) [context->memory-storage (@ bndg-context (@ expr:storage-reference (& expr:storage n)))])
      (for (offset (%:range-from offset (word-size))) (u (%:list-iter (@ expr:storage-arguments (& expr:storage n)))) (~) (do
        (setf bndg-size (@ expr:binding-aug u) (word-size))
        (setf bndg-preferred-offset (@ expr:binding-aug u) offset)
        (setf bndg-preferred-storage (@ expr:binding-aug u) [context->memory-storage (@ bndg-context (@ expr:binding-aug u))])))
      (fold (offset offset) (u (%:list-iter (@ expr:storage-arguments (& expr:storage n)))) [place-perm-bindings u offset])))))
    
    offset))

(-- Checks whether the given register is in use according to the given register usage
  vector.)

(constrain register-in-use? \:r:(`(function (register reg-use-vec) ())r))

(function register-in-use? (reg reg-use-vec)
  (let (reg-idx [band reg 0x:F])
  (if [band [<< #:1 reg-idx] reg-use-vec] (true) (false))))

(-- Takes a binding, a register to assign it to, and a bit-vector indicating the registers
  already in use. Assigns the given binding to the given register if it is not already in
  use and returns an indication to that effect, otherwise it fails.)

(function try-bndg-to-preferred-location (bndg in-use)
  (switch = (@ bndg-preferred-storage bndg)
    ((nil-storage) in-use)
    
    ((frame-relative-storage) (absolute-storage) (do
      (setf bndg-storage bndg (@ bndg-preferred-storage bndg))
      (setf bndg-offset bndg (@ bndg-preferred-offset bndg))
      in-use))
      
    ((register-storage)
      (let (reg (@ bndg-preferred-offset bndg))
      (let (reg-idx [band reg 0x:F])
      (let (reg-occupied? [band [<< #:1 reg-idx] in-use])
      (if (or reg-occupied? [= reg (none)])
        in-use
        (do
          (setf bndg-size bndg (word-size))
          (setf bndg-storage bndg (register-storage))
          (setf bndg-offset bndg reg)
          [bor [<< #:1 reg-idx] in-use]))))))
          
    (~)))

(function try-expr-to-preferred-location (n in-use)
  [try-bndg-to-preferred-location (@ expr:binding-aug n) in-use])

(-- Takes a binding, the current offset in the stack frame, and a bit-vector indicating the
  registers that are currently in use. Returns the new stack offset and register usage
  bit-vector after the given bit-vector is placed.)

(storage binding-to-register/memory-prefs (r10)(r11)(rax)(r9)(r8)(rcx)(rdx)(rsi)(rdi)(r12)(r13)(r14)(r15)(rbx)(rsp)(rbp))

(constrain binding-to-register/memory \:r:(?(a) (`(function (bndg-aug ,:a reg-use-vec) reg-use-vec)r)r))

(function binding-to-register/memory (bndg offset in-use)
  (if [= in-use 0x:FFFFFFFFFFFFFFFF]
    (do
      (setf bndg-size bndg (word-size))
      (setf bndg-storage bndg [context->memory-storage (@ bndg-context bndg)])
      (setf bndg-offset bndg offset)
      in-use)
    (do
      (setf bndg-size bndg (word-size))
      (setf bndg-storage bndg (register-storage))
      (let (free-register
        (loop search (i #:0)
          (let (test-reg ($(loc (unit) i binding-to-register/memory-prefs)))
            (if [register-in-use? test-reg in-use] {search [+ i #:1]} test-reg))))
      (let (new-in-use [bor in-use [<< #:1 [band free-register 0x:0F]]]) (do
      (setf bndg-offset bndg free-register)
      new-in-use))))))

(function expr-to-register/memory (n offset in-use)
  [binding-to-register/memory (@ expr:binding-aug n) offset in-use])

(function coalesce-expr-bndg (n)
  (if (and [= (@ expr:type n) (-symbol-)] [= (@ bndg-mode (@ expr:symbol-reference (& expr:symbol n))) (value-mode)])
    (do (setf expr:binding-aug n (@ expr:symbol-reference (& expr:symbol n))) n)
    n))

(function bndg-assigned? (bndg) [not= (@ bndg-storage bndg) (nil-storage)])

(function expr-assigned? (expr) [bndg-assigned? (@ expr:binding-aug expr)])

(constrain initializer->function
  \:r:(?(a b c d) `:(function (initializer)
    (function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c)):r r))

(function initializer->function (x) [cast x])

(constrain function->initializer
  \:r:(?(a b c d) `:(function
    ((function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c)) initializer):r r))

(function function->initializer (x) [cast x])

(constrain initialize-expressions
  \:r:(?(a b c d e)
    `:(function ((list (expr ,:e)) (list bndg-aug) ,:a reg-use-vec ,:c (list initializer) ,:b region ,:d) (values ,:a reg-use-vec)):r r))

(function initialize-expressions (exprs bndgs offset mask depth inits ret-val buf hdl)
  (let (sub-expr-offset [- offset [* [+ [length exprs] [length bndgs]] (word-size)]])
  ((values? .:bottom-offset .:in-use)
    (loop init-subs (bottom-offset sub-expr-offset) (in-use mask) (u exprs)
      (if [nil? u]
        (values (use-storage bind) bottom-offset in-use)
        ((values? .:bottom-offset' .:in-use') [initialize-expression [@car u] sub-expr-offset inits bind buf hdl]
          {init-subs [min bottom-offset bottom-offset'] [bor in-use in-use'] [@cdr u]} (~)))) (do
  (for (u (%:list-iter exprs)) (~) (setf bndg-storage (@ expr:binding-aug u) (nil-storage)))
  (for (u (%:list-iter bndgs)) (~) (setf bndg-storage u (nil-storage)))
  (let (in-use (fold (in-use in-use) (u (%:list-iter exprs))
    (if (and [> [expr-binding-depth u] depth] (@ bndg-is-read (@ expr:binding-aug u)))
      [try-expr-to-preferred-location u in-use]
      in-use)))
  (let (in-use (fold (in-use in-use) (u (%:list-iter bndgs))
    (if (and [>= [bndg-depth u] depth] (@ bndg-is-read u))
      [try-bndg-to-preferred-location u in-use]
      in-use)))
  (let (in-use
    (loop assign-args (offset [- offset [* [length exprs] (word-size)]]) (in-use in-use) (u exprs)
      (if [nil? u]
        in-use
        (let (v [@car u])
          {assign-args [+ offset (word-size)]
            (if (and [> [expr-binding-depth v] depth] (not [expr-assigned? v]) (@ bndg-is-read (@ expr:binding-aug v)))
              [expr-to-register/memory v offset in-use]
              in-use) [@cdr u]}))))
  (let (in-use
    (loop assign-args (offset [- offset [* [+ [length exprs] [length bndgs]] (word-size)]]) (in-use in-use) (u bndgs)
      (if [nil? u]
        in-use
        (let (v [@car u])
          {assign-args [+ offset (word-size)]
            (if (and [>= [bndg-depth v] depth] (not [bndg-assigned? v]) (@ bndg-is-read v))
              [binding-to-register/memory v offset in-use]
              in-use) [@cdr u]}))))
  (values (use-storage ret-val) bottom-offset in-use)))))) (~))))

(constrain generate-function
  \:r:(?(a b c) `:(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b):r r))

(function generate-function (n c relocs r handler)
  (sub (.. r handler) (let
      (ref-val-bndg (@ expr:function-reference (& expr:function n)))
      (expr-val-bndg (@ expr:binding-aug n))
      (body-val-bndg (@ expr:binding-aug (@ expr:function-expression (& expr:function n))))
      (after-binding [make-binding-aug (reference-mode) (extra-function-context) (absolute-storage) (local-scope) (defined-state) empty-string null-fragment null-expr ..]) (do
    
    [prepend(make-instrN(x86-lea)([bndg->op expr-val-bndg relocs ..][bndg->op ref-val-bndg relocs ..][make-reg-op(r11)..])..) c ..]
    [prepend (make-instrN (x86-jmp)([make-relative-relocation-immediate #:4 after-binding relocs ..])..) c ..]
    [prepend [make-label ref-val-bndg ..] c ..]
    [prepend (make-instrN(x86-push)([make-reg-op (rbp) ..])..) c ..]
    [prepend (make-instrN(x86-mov)([make-reg-op (rbp) ..] [make-reg-op (rsp) ..])..) c ..]
    [prepend (make-instrN(x86-sub)([make-reg-op (rsp) ..] [make-imm-op #:4 [- #:0 (@ expr:frame-size (& expr:function n))] ..])..) c ..]
    
    (let (save-offset [- #:0 [* (callee-saved-x64-r64s-len)(word-size)]])
    (for (i (%:range #:0 (callee-saved-x64-r64s-len))) (~)
      (let (current-register ($(loc(word-size)i callee-saved-x64-r64s)))
        (if [register-in-use? current-register (@ expr:registers-used (& expr:function n))]
          [prepend (make-instrN (x86-mov)
            ([make-mem-op(word-size)(rbp)(none)#:0[+ save-offset[* i(word-size)]]#:4 ..]
            [make-reg-op current-register ..]) ..) c ..]
          (~)))))
     
    (-- Move first 6 parameters to their slots)
    (and [> [length (@ expr:function-parameters (& expr:function n))] #:0] (do
      [generate-bndg-register-move [@car(@ expr:function-parameters (& expr:function n))] (rdi) c relocs ..]
    (and [> [length (@ expr:function-parameters (& expr:function n))] #:1] (do
      [generate-bndg-register-move [@cadr(@ expr:function-parameters (& expr:function n))] (rsi) c relocs ..]
    (and [> [length (@ expr:function-parameters (& expr:function n))] #:2] (do
      [generate-bndg-register-move [@caddr(@ expr:function-parameters (& expr:function n))] (rdx) c relocs ..]
    (and [> [length (@ expr:function-parameters (& expr:function n))] #:3] (do
      [generate-bndg-register-move [@cadddr(@ expr:function-parameters (& expr:function n))] (rcx) c relocs ..]
    (and [> [length (@ expr:function-parameters (& expr:function n))] #:4] (do
      [generate-bndg-register-move [@caddddr(@ expr:function-parameters (& expr:function n))] (r8) c relocs ..]
    (and [> [length (@ expr:function-parameters (& expr:function n))] #:5]
      [generate-bndg-register-move [@cadddddr(@ expr:function-parameters (& expr:function n))] (r9) c relocs ..])))))))))))
    
    (let (rem-offset [* #:2(word-size)])
    (let (rem-params (if [>= [length (@ expr:function-parameters (& expr:function n))] #:6] [@cddddddr (@ expr:function-parameters (& expr:function n))] nil))
    (fold (offset rem-offset) (u (%:list-iter rem-params)) (do
      [prepend (make-instrN(x86-mov)
        ([bndg->op u relocs ..][make-mem-op(word-size)(rbp)(none)#:0 offset #:4 ..][make-reg-op(r11)..])..) c ..]
      [+ offset (word-size)]))))
    
    (-- Execute the function body)
    [generate-expression (@ expr:function-expression (& expr:function n)) c relocs ..]
    [generate-register-bndg-move (rax) body-val-bndg c relocs ..]
    
    (let (save-offset [- #:0 [* (callee-saved-x64-r64s-len)(word-size)]])
    (for (i (%:range #:0 (callee-saved-x64-r64s-len))) (~)
      (let (current-register ($(loc(word-size)i callee-saved-x64-r64s)))
        (if [register-in-use? current-register (@ expr:registers-used (& expr:function n))]
          [prepend (make-instrN (x86-mov)
            ([make-reg-op current-register ..]
            [make-mem-op(word-size)(rbp)(none)#:0[+ save-offset[* i(word-size)]]#:4 ..]) ..) c ..]
          (~)))))
          
    [prepend (make-instrN(x86-leave)()..) c ..]
    [prepend (make-instrN(x86-ret)()..) c ..]
    [prepend [make-label after-binding ..] c ..]))))

(constrain initialize-function
  \:r:(?(a b c d) (`(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c)r)r))

(function initialize-function (n offset inits ret-val buf hdl)
  (and [= (@ expr:type n) (-function-)] (do
    (let (call-regs (storage _ (rdi)(rsi)(rdx)(rcx)(r8)(r9)))
      (loop set-prefs (rem-params (@ expr:function-parameters (& expr:function n))) (i #:0)
        (if (or [= i #:6] [nil? rem-params]) (~) (do
          (setf bndg-preferred-storage [@car rem-params] (register-storage))
          (setf bndg-preferred-offset [@car rem-params] ($(loc (unit) i call-regs)))
          {set-prefs [@cdr rem-params] [+ i #:1]}))))
    
    (let (rem-offset [* #:2(word-size)])
    (let (rem-params (if [>= [length (@ expr:function-parameters (& expr:function n))] #:6] [@cddddddr (@ expr:function-parameters (& expr:function n))] nil))
    (loop assign-params (offset rem-offset) (u rem-params)
      (if [nil? u] (~) (do
        (setf bndg-preferred-storage [@car u] (frame-relative-storage))
        (setf bndg-preferred-offset [@car u] offset)
        {assign-params [+ offset (word-size)] [@cdr u]})))))
    
    (setf bndg-preferred-storage (@ expr:binding-aug (@ expr:function-expression (& expr:function n))) (register-storage))
    (setf bndg-preferred-offset (@ expr:binding-aug (@ expr:function-expression (& expr:function n))) (rax))
    
    ((values? .:frame-size .:in-use)
      [initialize-expressions (storage-cons (@ expr:function-expression (& expr:function n)) nil) (@ expr:function-parameters (& expr:function n))
        (@ expr:frame-size (& expr:function n)) 0x:FFFFFFFFFFFF0830 (@ expr:depth n) inits ret-val buf hdl] (do
    (setf expr:registers-used (& expr:function n) in-use)
    (setf expr:frame-size (& expr:function n) frame-size)
    (for (t (%:list-iter (@ expr:function-parameters (& expr:function n)))) (~) (setf bndg-size t (word-size)))) (~))
    (setf bndg-size (@ expr:binding-aug n) (word-size))
    (setf expr:generator n [function->generator generate-function])
    (values (use-storage ret-val) offset 0x:0000000000000800)
    (true))))

(constrain generate-store-continuation \:r:(?(a b) `:(function ((expr ,:b) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) !:Ref:(list instr)):r r))

(function generate-store-continuation (n c relocs r handler)
  (sub (.. r handler) (let
      (cont-val-bndg $:[expr-reference n])
      (cont-instr-bndg $:[expr-instr-bndg n]) (do
    [prepend (make-instrN (x86-lea) ([make-reg-op (r11) ..] [bndg->op cont-val-bndg relocs ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r11)(none)#:0(cont-rbx)#:4 ..] [make-reg-op (rbx) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r11)(none)#:0(cont-r12)#:4 ..] [make-reg-op (r12) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r11)(none)#:0(cont-r13)#:4 ..] [make-reg-op (r13) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r11)(none)#:0(cont-r14)#:4 ..] [make-reg-op (r14) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r11)(none)#:0(cont-r15)#:4 ..] [make-reg-op (r15) ..]) ..) c ..]
    [prepend (make-instrN (x86-lea) ([make-mem-op(word-size)(r11)(none)#:0(cont-cir)#:4 ..] [bndg->op cont-instr-bndg relocs ..] [make-reg-op (r10) ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-mem-op(word-size)(r11)(none)#:0(cont-rbp)#:4 ..] [make-reg-op (rbp) ..]) ..) c ..]))))

(constrain generate-continuation
  \:r:(?(a b c) `:(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) !:Ref:(list instr)):r r))

(function generate-continuation (n c relocs r handler)
  (sub (.. r handler) (let
      (cont-val-bndg (@ expr:continuation-reference (& expr:continuation n)))
      (expr-val-bndg (@ expr:binding-aug n))
      (after-binding [make-binding-aug (reference-mode) (extra-function-context) (absolute-storage) (local-scope) (defined-state) empty-string null-fragment null-expr ..]) (do
    (if (@ expr:continuation-escapes (& expr:continuation n)) (do
      [prepend (make-instrN(x86-lea)([bndg->op expr-val-bndg relocs ..][bndg->op cont-val-bndg relocs ..][make-reg-op (r11) ..]) ..) c ..]
      [generate-store-continuation n c relocs ..])
      (~))
    
    [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #:4 after-binding relocs ..]) ..) c ..]
    [prepend [make-label (@ expr:continuation-instr-bndg (& expr:continuation n)) ..] c ..]
    [generate-expression (@ expr:continuation-expression (& expr:continuation n)) c relocs ..]
    [prepend [make-label after-binding ..] c ..]))))

(constrain initialize-continuation
  \:r:(?(a b c d) `:(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c):r r))

(function initialize-continuation (n offset inits ret-val buf hdl)
  (and [= (@ expr:type n) (-continuation-)] (do
    [initialize-expressions (storage-cons (@ expr:continuation-expression (& expr:continuation n)) nil) (@ expr:continuation-parameters (& expr:continuation n))
      offset 0x:FFFFFFFFFFFF0C38 (@ expr:depth n) inits ret-val buf hdl]
    (setf bndg-size (@ expr:binding-aug n) (word-size))
    (setf expr:generator n [function->generator generate-continuation])
    (true))))

(constrain generate-with
  \:r:(?(a b c) `:(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b):r r))

(function generate-with (n c relocs r handler)
  (sub (.. r handler) (let
      (expr-val-bndg (@ expr:binding-aug n))
      (body-val-bndg (@ expr:binding-aug (@ expr:with-expression (& expr:with n))))
      (param-val-bndg [@car(@ expr:with-parameters (& expr:with n))])
      (end-instr-binding
        [make-binding-aug (reference-mode) (extra-function-context) (absolute-storage) (local-scope) (defined-state) empty-string null-fragment null-expr ..]) (do
    (if (@ expr:with-escapes (& expr:with n)) [generate-store-continuation n c relocs ..] (~))
    [generate-expression (@ expr:with-expression (& expr:with n)) c relocs ..]
    [generate-bndg-bndg-move expr-val-bndg body-val-bndg (r11) c relocs ..]
    (if [bndg= expr-val-bndg param-val-bndg]
      [prepend [make-label (@ expr:with-instr-bndg (& expr:with n)) ..] c ..]
      (do
        [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #:4 end-instr-binding relocs ..]) ..) c ..]
        [prepend [make-label (@ expr:with-instr-bndg (& expr:with n)) ..] c ..]
        [generate-bndg-bndg-move expr-val-bndg param-val-bndg (r11) c relocs ..]
        [prepend [make-label end-instr-binding ..] c ..]))))))

(constrain initialize-with \:r:(?(a b c d) `:(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c):r r))

(function initialize-with (n offset inits ret-val buf hdl)
  (and [= (@ expr:type n) (-with-)] (do
    (setf expr:binding-aug (@ expr:with-expression (& expr:with n)) (@ expr:binding-aug n))
    (if (@ expr:with-escapes (& expr:with n)) (~) (setf car (@ expr:with-parameters (& expr:with n)) (@ expr:binding-aug n)))
    
    (loop search (rem-jumps (@ expr:with-jumps (& expr:with n)))
      (if [nil? rem-jumps] (~)
        (let (arg [@car (@ expr:jump-arguments (& expr:jump [@car rem-jumps]))])
          (if [= (@ expr:type arg) (-symbol-)]
            (let (repl-target (@ expr:symbol-reference (& expr:symbol arg)))
              (if (and [= (@ bndg-mode repl-target) (value-mode)] [> [bndg-depth repl-target] (@ expr:depth n)] (not [bndg-escapes repl-target]))
                [visit-expressions vreplace-value-bindings (storage _ (@ expr:with-expression (& expr:with n)))
                  (values storage repl-target [@car (@ expr:with-parameters (& expr:with n))])]
                {search [@cdr rem-jumps]}))
            {search [@cdr rem-jumps]}))))
    
    [initialize-expressions (storage-cons (@ expr:with-expression (& expr:with n)) nil) (@ expr:with-parameters (& expr:with n))
      offset 0x:FFFFFFFFFFFF0C38 (@ expr:depth n) inits ret-val buf hdl]
    
    (setf bndg-size (@ expr:binding-aug n) (word-size))
    (setf expr:generator n [function->generator generate-with])
    (true))))

(constrain generate-storage
  \:r:(?(a b c) `:(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b):r r))

(function generate-storage (n c relocs r handler)
  (sub (.. r handler) (let
      (expr-val-bndg (@ expr:binding-aug n))
      (storage-val-bndg (@ expr:storage-reference (& expr:storage n))) (do
    (for (t (%:list-iter (@ expr:storage-arguments (& expr:storage n)))) (~) [generate-expression t c relocs ..])
    [prepend(make-instrN(x86-lea)
      ([bndg->op expr-val-bndg relocs ..][bndg->op storage-val-bndg relocs ..][make-reg-op(r11) ..])..) c ..]))))

(constrain initialize-storage \:r:(?(a b c d) `:(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c):r r))

(function initialize-storage (n offset inits ret-val buf hdl)
  (and [= (@ expr:type n) (-storage-)] (do
    [initialize-expressions (@ expr:storage-arguments (& expr:storage n)) nil offset 0x:FFFFFFFFFFFF0C38 (@ expr:depth n) inits ret-val buf hdl]
    (setf bndg-size (@ expr:binding-aug n) (word-size))
    (setf expr:generator n [function->generator generate-storage])
    (true))))

(constrain generate-buffer-to-dest
  \:r:(?(a b c) `:(function ((expr ,:c) register ,:a !:Ref:(list instr) !:Ref:(list reloc) region ,:b) ()):r r))

(function generate-buffer-to-dest (n dest-reg offset c relocs r handler)
  (sub (.. r handler)
    (for (dest-offset (%:range-from offset (word-size))) (t (%:list-iter $:[expr-arguments n])) (~)
      (let (arg-val-bndg (@ expr:binding-aug t)) (do
        [prepend (make-instrN (x86-mov)
          ([make-mem-op(word-size)dest-reg(none)#:0 dest-offset #:4 ..][bndg->op arg-val-bndg relocs ..][make-reg-op(r11)..]) ..) c ..]
        (~))))))

(constrain generate-load-continuation
  \:r:(?(a) `:(function (register !:Ref:(list instr) !:Ref:(list reloc) region ,:a) !:Ref:(list instr)):r r))

(function generate-load-continuation (src-reg c relocs r handler)
  (sub (.. r handler) (do
    [prepend (make-instrN (x86-mov) ([make-reg-op (rbx) ..] [make-mem-op(word-size)src-reg(none)#:0(cont-rbx)#:4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r12) ..] [make-mem-op(word-size)src-reg(none)#:0(cont-r12)#:4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r13) ..] [make-mem-op(word-size)src-reg(none)#:0(cont-r13)#:4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r14) ..] [make-mem-op(word-size)src-reg(none)#:0(cont-r14)#:4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r15) ..] [make-mem-op(word-size)src-reg(none)#:0(cont-r15)#:4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (r11) ..] [make-mem-op(word-size)src-reg(none)#:0(cont-cir)#:4 ..]) ..) c ..]
    [prepend (make-instrN (x86-mov) ([make-reg-op (rbp) ..] [make-mem-op(word-size)src-reg(none)#:0(cont-rbp)#:4 ..]) ..) c ..]
    [prepend (make-instrN(x86-jmp)([make-reg-op (r11) ..])..) c ..])))

(constrain generate-jump
  \:r:(?(a b c) `:(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b):r r))

(function generate-jump (n c relocs r handler)
  (sub (.. r handler) (do
    (if (and [= (@ expr:type (@ expr:jump-target (& expr:jump n))) (-continuation-)] (not (@ expr:continuation-escapes (& expr:continuation (@ expr:jump-target (& expr:jump n))))))
      (let (cont (@ expr:jump-target (& expr:jump n))) (do
        (for (t (%:list-iter (@ expr:jump-arguments (& expr:jump n)))) (~) [generate-expression t c relocs ..])
        (for (t (%:list-iter(@ expr:jump-arguments (& expr:jump n)))) (u (%:list-iter(@ expr:continuation-parameters (& expr:continuation cont)))) (~)
          (let (src-bndg (@ expr:binding-aug t)) (dest-bndg u)
            [generate-bndg-bndg-move dest-bndg src-bndg (r11) c relocs ..]))
        [prepend [make-label (@ expr:continuation-instr-bndg (& expr:continuation cont)) ..] c ..]
        [generate-expression (@ expr:continuation-expression (& expr:continuation cont)) c relocs ..]))
    
    (bind-if
      (loop enter (with-expr (@ expr:short-circuit (& expr:jump n))) (current (@ expr:short-circuit (& expr:jump n)))
        (if [= n current]
          (do [set dest with-expr] (true))
        (if (and [not= current null-expr] [= (@ expr:type current) (-with-)])
          {enter current (@ expr:with-expression (& expr:with current))}
        (if (and [= (@ expr:type current) (-jump-)] [= (@ expr:type (@ expr:jump-target (& expr:jump current))) (-continuation-)])
          {enter with-expr (@ expr:continuation-expression (& expr:continuation (@ expr:jump-target (& expr:jump current))))}
          (false)))))
      (dest)
        (let (dest-bndg (@ expr:binding-aug (@ expr:with-expression (& expr:with $:dest))))
            (src-bndg (@ expr:binding-aug [@car (@ expr:jump-arguments (& expr:jump n))])) (do
          [generate-expression [@car (@ expr:jump-arguments (& expr:jump n))] c relocs ..]
          [generate-bndg-bndg-move dest-bndg src-bndg (r11) c relocs ..]))
    
    (if [not= (@ expr:short-circuit (& expr:jump n)) null-expr]
      (let (cont-instr-bndg $:[expr-instr-bndg(@ expr:short-circuit (& expr:jump n))]) (do
        (if [= (@ expr:type(@ expr:jump-target (& expr:jump n))) (-continuation-)]
          [generate-expression (@ expr:jump-target (& expr:jump n)) c relocs ..]
          (~))
        (for (t (%:list-iter (@ expr:jump-arguments (& expr:jump n)))) (~) [generate-expression t c relocs ..])
        (for (t (%:list-iter(@ expr:jump-arguments (& expr:jump n)))) (u (%:list-iter $:[expr-parameters (@ expr:short-circuit (& expr:jump n))])) (~)
          (let (src-bndg (@ expr:binding-aug t)) (dest-bndg u)
            [generate-bndg-bndg-move dest-bndg src-bndg (r11) c relocs ..]))
        [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #:4 cont-instr-bndg relocs ..]) ..) c ..]))
        
      (let (ref-val-bndg (@ expr:binding-aug (@ expr:jump-target (& expr:jump n)))) (do
        (for (t (%:list-iter (@ expr:jump-arguments (& expr:jump n)))) (~) [generate-expression t c relocs ..])
        [generate-expression (@ expr:jump-target (& expr:jump n)) c relocs ..]
        [generate-register-bndg-move (r10) ref-val-bndg c relocs ..]
        [generate-buffer-to-dest n (r10) (cont-size) c relocs ..]
        [generate-load-continuation (r10) c relocs ..]))))))))

(constrain initialize-jump \:r:(?(a b c d) `:(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c):r r))

(function initialize-jump (n offset inits ret-val buf hdl)
  (and [= (@ expr:type n) (-jump-)] (do
    (if [= (@ expr:type (@ expr:jump-target (& expr:jump n))) (-continuation-)]
      (do
        (for (u (%:list-iter(@ expr:jump-arguments (& expr:jump n)))) (v (%:list-iter(@ expr:continuation-parameters (& expr:continuation (@ expr:jump-target (& expr:jump n)))))) (~)
          (setf expr:binding-aug u v))
        [initialize-expressions (storage-cons (@ expr:continuation-expression (& expr:continuation (@ expr:jump-target (& expr:jump n)))) (@ expr:jump-arguments (& expr:jump n)))
          nil offset 0x:FFFFFFFFFFFF0C38 (@ expr:depth n) inits ret-val buf hdl])
    (if (and [not= (@ expr:short-circuit (& expr:jump n)) null-expr] [= [length $:[expr-parameters (@ expr:short-circuit (& expr:jump n))]] #:1])
      (do
        (setf expr:binding-aug [@car (@ expr:jump-arguments (& expr:jump n))] [@car $:[expr-parameters (@ expr:short-circuit (& expr:jump n))]])
        [initialize-expressions (storage-cons (@ expr:jump-target (& expr:jump n)) (@ expr:jump-arguments (& expr:jump n))) nil offset
          0x:FFFFFFFFFFFF0C30 (@ expr:depth n) inits ret-val buf hdl])
      [initialize-expressions (storage-cons (@ expr:jump-target (& expr:jump n)) (@ expr:jump-arguments (& expr:jump n))) nil offset
        0x:FFFFFFFFFFFF0C30 (@ expr:depth n) inits ret-val buf hdl]))
    (setf bndg-size (@ expr:binding-aug n) (word-size))
    (setf expr:generator n [function->generator generate-jump])
    (true))))

(constrain generate-invoke
  \:r:(?(a b c) `:(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b):r r))

(function generate-invoke (n c relocs r handler)
  (sub (.. r handler) (let
      (expr-val-bndg (@ expr:binding-aug n))
      (ref-expr (@ expr:invoke-target (& expr:invoke n)))
      (ref-val-bndg (@ expr:binding-aug (@ expr:invoke-target (& expr:invoke n)))) (do
    (-- If the invoke expression's reference is not an absolute symbol, then put the
      target address into a register and then emit a call on that register.)
    (if (and [= (@ expr:type ref-expr) (-symbol-)] [absolute-reference-symbol? ref-expr])
      (~)
      [generate-expression (@ expr:invoke-target (& expr:invoke n)) c relocs ..])
    (for (t (%:list-iter (@ expr:invoke-arguments (& expr:invoke n)))) (~) [generate-expression t c relocs ..])
    (for (t (%:list-iter [reverse (if [> [length (@ expr:invoke-arguments (& expr:invoke n))] #:6] [@cddddddr(@ expr:invoke-arguments (& expr:invoke n))] nil) ..])) (~)
      (let (src-val-bndg (@ expr:binding-aug t))
        [prepend (make-instrN(x86-push) ([bndg->op src-val-bndg relocs ..]) ..) c ..]))
    
    (and [> [length (@ expr:invoke-arguments (& expr:invoke n))] #:0] (do
      [generate-register-bndg-move (rdi) (@ expr:binding-aug [@car(@ expr:invoke-arguments (& expr:invoke n))]) c relocs ..]
    (and [> [length (@ expr:invoke-arguments (& expr:invoke n))] #:1] (do
      [generate-register-bndg-move (rsi) (@ expr:binding-aug [@cadr(@ expr:invoke-arguments (& expr:invoke n))]) c relocs ..]
    (and [> [length (@ expr:invoke-arguments (& expr:invoke n))] #:2] (do
      [generate-register-bndg-move (rdx) (@ expr:binding-aug [@caddr(@ expr:invoke-arguments (& expr:invoke n))]) c relocs ..]
    (and [> [length (@ expr:invoke-arguments (& expr:invoke n))] #:3] (do
      [generate-register-bndg-move (rcx) (@ expr:binding-aug [@cadddr(@ expr:invoke-arguments (& expr:invoke n))]) c relocs ..]
    (and [> [length (@ expr:invoke-arguments (& expr:invoke n))] #:4] (do
      [generate-register-bndg-move (r8) (@ expr:binding-aug [@caddddr(@ expr:invoke-arguments (& expr:invoke n))]) c relocs ..]
    (and [> [length (@ expr:invoke-arguments (& expr:invoke n))] #:5]
      [generate-register-bndg-move (r9) (@ expr:binding-aug [@cadddddr(@ expr:invoke-arguments (& expr:invoke n))]) c relocs ..])))))))))))
    
    [prepend (make-instrN(x86-xor)([make-reg-op (rax) ..] [make-reg-op (rax) ..])..) c ..]
    (if (and [= (@ expr:type ref-expr) (-symbol-)] [absolute-reference-symbol? ref-expr])
      (let (ref-sym-bndg (@ expr:symbol-reference (& expr:symbol ref-expr)))
        [prepend (make-instrN(x86-call)([make-relative-relocation-immediate #:4 ref-sym-bndg relocs ..])..) c ..])
      [prepend (make-instrN(x86-call)([bndg->op ref-val-bndg relocs ..])..) c ..])
    [generate-bndg-register-move expr-val-bndg (rax) c relocs ..]
    
    (if [> [length (@ expr:invoke-arguments (& expr:invoke n))] #:6]
      (let (drop [*(word-size)[-[length(@ expr:invoke-arguments (& expr:invoke n))]#:6]])
        [prepend (make-instrN(x86-add)([make-reg-op (rsp) ..] [make-imm-op #:4 drop ..])..) c ..])
      (~))))))

(constrain initialize-invoke \:r:(?(a b c d) `:(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c):r r))

(function initialize-invoke (n offset inits ret-val buf hdl)
  (and [= (@ expr:type n) (-invoke-)] (do
    (let (call-regs (storage _ (rdi)(rsi)(rdx)(rcx)(r8)(r9)))
      (loop set-prefs (rem-args (@ expr:invoke-arguments (& expr:invoke n))) (i #:0)
        (if (or [= i #:6] [nil? rem-args]) (~) (do
          (setf bndg-preferred-storage (@ expr:binding-aug [@car rem-args]) (register-storage))
          (setf bndg-preferred-offset (@ expr:binding-aug [@car rem-args]) ($(loc (unit) i call-regs)))
          {set-prefs [@cdr rem-args] [+ i #:1]}))))
    ((values? .:bottom-offset .:in-use)
      [initialize-expressions (storage-cons (@ expr:invoke-target (& expr:invoke n)) (@ expr:invoke-arguments (& expr:invoke n))) nil offset
        0x:FFFFFFFFFFFF0031 (@ expr:depth n) inits ret-val buf hdl] (do
    (setf bndg-size (@ expr:binding-aug n) (word-size))
    (setf expr:generator n [function->generator generate-invoke])
    (values (use-storage ret-val) bottom-offset [bor in-use 0x:FFFFFFFFFFFF0FF7])
    (true)) (~)))))

(constrain generate-if
  \:r:(?(a b c) `:(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b):r r))

(function generate-if (n c relocs r handler)
  (sub (.. r handler)
    (let
        (expr-val-bndg (@ expr:binding-aug n))
        (condition-val-bndg (@ expr:binding-aug (@ expr:condition (& expr:if n))))
        (consequent-val-bndg (@ expr:binding-aug (@ expr:consequent (& expr:if n))))
        (alternate-val-bndg (@ expr:binding-aug (@ expr:alternate (& expr:if n))))
        (consequent-instr-bndg
          [make-binding-aug (reference-mode) (extra-function-context) (absolute-storage) (local-scope) (defined-state) empty-string null-fragment null-expr ..])
        (alternate-instr-bndg
          [make-binding-aug (reference-mode) (extra-function-context) (absolute-storage) (local-scope) (defined-state) empty-string null-fragment null-expr ..])
        (end-instr-binding
          [make-binding-aug (reference-mode) (extra-function-context) (absolute-storage) (local-scope) (defined-state) empty-string null-fragment null-expr ..]) (do
      
      [generate-expression (@ expr:condition (& expr:if n)) c relocs ..]
      [prepend (make-instrN(x86-or)([bndg->op condition-val-bndg relocs ..][bndg->op condition-val-bndg relocs ..][make-reg-op(r11)..])..) c ..]
      [prepend (make-instrN (x86-jz) ([make-relative-relocation-immediate #:4 alternate-instr-bndg relocs ..]) ..) c ..]
      [prepend [make-label consequent-instr-bndg ..] c ..]
      [generate-expression (@ expr:consequent (& expr:if n)) c relocs ..]
      [generate-bndg-bndg-move expr-val-bndg consequent-val-bndg (r11) c relocs ..]
      [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #:4 end-instr-binding relocs ..]) ..) c ..]
      [prepend [make-label alternate-instr-bndg ..] c ..]
      [generate-expression (@ expr:alternate (& expr:if n)) c relocs ..]
      [generate-bndg-bndg-move expr-val-bndg alternate-val-bndg (r11) c relocs ..]
      [prepend [make-label end-instr-binding ..] c ..]))))

(constrain initialize-if \:r:(?(a b c d) `:(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c):r r))

(function initialize-if (n offset inits ret-val buf hdl)
  (sub (.. buf hdl)
    (and [= (@ expr:type n) (-if-)] (with-region buf (do
      (setf expr:binding-aug (@ expr:consequent (& expr:if n)) (@ expr:binding-aug n))
      (setf expr:binding-aug (@ expr:alternate (& expr:if n)) (@ expr:binding-aug n))
      [initialize-expressions
        (storage-cons (@ expr:consequent (& expr:if n)) (storage-cons (@ expr:alternate (& expr:if n)) (storage-cons (@ expr:condition (& expr:if n)) nil)))
        nil offset 0x:FFFFFFFFFFFF0830 (@ expr:depth n) inits ret-val buf hdl]
      (setf expr:generator n [function->generator generate-if])
      (setf bndg-size (@ expr:binding-aug n) (word-size))
      (true))))))

(constrain negate-jump-condition \:r:(`(function (instr-code) instr-code)r))

(function negate-jump-condition (jc)
  (switch = jc
    ((x86-jae) (x86-jb))
    ((x86-jbe) (x86-ja))
    ((x86-jb) (x86-jae))
    ((x86-ja) (x86-jbe))
    ((x86-je) (x86-jne))
    ((x86-jne) (x86-je))
    (~)))

(constrain generate-optimized-if
  \:r:(?(a b c) (`(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b)r)r))

(function generate-optimized-if (n c relocs r handler)
  (sub (.. r handler)
    (let
        (expr-val-bndg (@ expr:binding-aug n))
        (condition-val-bndg (@ expr:binding-aug (@ expr:condition (& expr:if n))))
        (consequent-val-bndg (@ expr:binding-aug (@ expr:consequent (& expr:if n))))
        (alternate-val-bndg (@ expr:binding-aug (@ expr:alternate (& expr:if n))))
        (consequent-instr-bndg
          [make-binding-aug (reference-mode) (extra-function-context) (absolute-storage) (local-scope) (defined-state) empty-string null-fragment null-expr ..])
        (alternate-instr-bndg
          [make-binding-aug (reference-mode) (extra-function-context) (absolute-storage) (local-scope) (defined-state) empty-string null-fragment null-expr ..])
        (end-instr-binding
          [make-binding-aug (reference-mode) (extra-function-context) (absolute-storage) (local-scope) (defined-state) empty-string null-fragment null-expr ..]) (do
          
      (loop gen-cond (sub-if (@ expr:condition (& expr:if n)))
        (if (and [= (@ expr:type sub-if) (-literal-)] (@ expr:value (& expr:literal sub-if)))
          (~)
        (if (and [= (@ expr:type sub-if) (-literal-)] (not (@ expr:value (& expr:literal sub-if))))
          [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #:4 alternate-instr-bndg relocs ..]) ..) c ..]
        (if (or [not= (@ expr:type sub-if) (-if-)] (not (or [= (@ expr:type (@ expr:consequent (& expr:if sub-if))) (-literal-)] [= (@ expr:type (@ expr:alternate (& expr:if sub-if))) (-literal-)])))
          (do
            [generate-expression sub-if c relocs ..]
            (let (sub-if-bndg (@ expr:binding-aug sub-if))
            (if [= (@ bndg-condition-jump sub-if-bndg) (x86-nop)]
              (do
                [prepend (make-instrN(x86-or)([bndg->op sub-if-bndg relocs ..][bndg->op sub-if-bndg relocs ..][make-reg-op(r11)..])..) c ..]
                [prepend (make-instrN (x86-jz) ([make-relative-relocation-immediate #:4 alternate-instr-bndg relocs ..]) ..) c ..])
              [prepend (make-instrN [negate-jump-condition (@ bndg-condition-jump sub-if-bndg)] ([make-relative-relocation-immediate #:4 alternate-instr-bndg relocs ..]) ..) c ..])))
          (let (sub-if-val-bndg (@ expr:binding-aug (@ expr:condition (& expr:if sub-if))))
              (consequent (@ expr:consequent (& expr:if sub-if)))
              (alternate (@ expr:alternate (& expr:if sub-if))) (do
            [generate-expression (@ expr:condition (& expr:if sub-if)) c relocs ..]
            (let (jmp-instr (if [= (@ bndg-condition-jump (@ expr:binding-aug (@ expr:condition (& expr:if sub-if)))) (x86-nop)]
              (do
                [prepend (make-instrN(x86-or)([bndg->op sub-if-val-bndg relocs ..][bndg->op sub-if-val-bndg relocs ..][make-reg-op(r11)..])..) c ..]
                (x86-jnz))
              (@ bndg-condition-jump (@ expr:binding-aug (@ expr:condition (& expr:if sub-if))))))
            
            (if (and [= (@ expr:type sub-if) (-if-)] [= (@ expr:type consequent) (-literal-)] (@ expr:value (& expr:literal consequent))) (do
              [prepend (make-instrN jmp-instr ([make-relative-relocation-immediate #:4 consequent-instr-bndg relocs ..]) ..) c ..]
              {gen-cond (@ expr:alternate (& expr:if sub-if))})
            (if (and [= (@ expr:type sub-if) (-if-)] [= (@ expr:type consequent) (-literal-)] (not (@ expr:value (& expr:literal consequent)))) (do
              [prepend (make-instrN jmp-instr ([make-relative-relocation-immediate #:4 alternate-instr-bndg relocs ..]) ..) c ..]
              {gen-cond (@ expr:alternate (& expr:if sub-if))})
            (if (and [= (@ expr:type sub-if) (-if-)] [= (@ expr:type alternate) (-literal-)] (@ expr:value (& expr:literal alternate))) (do
              [prepend (make-instrN [negate-jump-condition jmp-instr] ([make-relative-relocation-immediate #:4 consequent-instr-bndg relocs ..]) ..) c ..]
              {gen-cond (@ expr:consequent (& expr:if sub-if))})
            (if (and [= (@ expr:type sub-if) (-if-)] [= (@ expr:type alternate) (-literal-)] (not (@ expr:value (& expr:literal alternate)))) (do
              [prepend (make-instrN [negate-jump-condition jmp-instr] ([make-relative-relocation-immediate #:4 alternate-instr-bndg relocs ..]) ..) c ..]
              {gen-cond (@ expr:consequent (& expr:if sub-if))})
            (~))))))))))))
        
      [prepend [make-label consequent-instr-bndg ..] c ..]
      [generate-expression (@ expr:consequent (& expr:if n)) c relocs ..]
      [generate-bndg-bndg-move expr-val-bndg consequent-val-bndg (r11) c relocs ..]
      [prepend (make-instrN (x86-jmp) ([make-relative-relocation-immediate #:4 end-instr-binding relocs ..]) ..) c ..]
      [prepend [make-label alternate-instr-bndg ..] c ..]
      [generate-expression (@ expr:alternate (& expr:if n)) c relocs ..]
      [generate-bndg-bndg-move expr-val-bndg alternate-val-bndg (r11) c relocs ..]
      [prepend [make-label end-instr-binding ..] c ..]))))

(constrain initialize-optimized-if \:r:(?(a b c d) `:(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c):r r))

(function initialize-optimized-if (n offset inits ret-val buf hdl)
  (sub (.. buf hdl)
    (and [= (@ expr:type n) (-if-)] (with-region buf
      (let (conds (loop gen-cond (sub-if (@ expr:condition (& expr:if n))) (conds nil)
        (if (or [not= (@ expr:type sub-if) (-if-)] (not (or [= (@ expr:type (@ expr:consequent (& expr:if sub-if))) (-literal-)] [= (@ expr:type (@ expr:alternate (& expr:if sub-if))) (-literal-)])))
          (do
            (setf bndg-is-condition (@ expr:binding-aug sub-if) (true))
            [cons sub-if conds ..])
          (let (sub-if-val-bndg (@ expr:binding-aug (@ expr:condition (& expr:if sub-if))))
              (consequent (@ expr:consequent (& expr:if sub-if)))
              (alternate (@ expr:alternate (& expr:if sub-if))) (do
            (setf bndg-is-condition (@ expr:binding-aug (@ expr:condition (& expr:if sub-if))) (true))
            (if (and [= (@ expr:type sub-if) (-if-)] [= (@ expr:type consequent) (-literal-)] (@ expr:value (& expr:literal consequent))) (do
              {gen-cond (@ expr:alternate (& expr:if sub-if)) [cons (@ expr:condition (& expr:if sub-if)) conds ..]})
            (if (and [= (@ expr:type sub-if) (-if-)] [= (@ expr:type consequent) (-literal-)] (not (@ expr:value (& expr:literal consequent)))) (do
              {gen-cond (@ expr:alternate (& expr:if sub-if)) [cons (@ expr:condition (& expr:if sub-if)) conds ..]})
            (if (and [= (@ expr:type sub-if) (-if-)] [= (@ expr:type alternate) (-literal-)] (@ expr:value (& expr:literal alternate))) (do
              {gen-cond (@ expr:consequent (& expr:if sub-if)) [cons (@ expr:condition (& expr:if sub-if)) conds ..]})
            (if (and [= (@ expr:type sub-if) (-if-)] [= (@ expr:type alternate) (-literal-)] (not (@ expr:value (& expr:literal alternate)))) (do
              {gen-cond (@ expr:consequent (& expr:if sub-if)) [cons (@ expr:condition (& expr:if sub-if)) conds ..]})
            (~)))))))))) (do
          
      (setf expr:binding-aug (@ expr:consequent (& expr:if n)) (@ expr:binding-aug n))
      (setf expr:binding-aug (@ expr:alternate (& expr:if n)) (@ expr:binding-aug n))
      [initialize-expressions
        (storage-cons (@ expr:consequent (& expr:if n)) (storage-cons (@ expr:alternate (& expr:if n)) conds))
        nil offset 0x:FFFFFFFFFFFF0830 (@ expr:depth n) inits ret-val buf hdl]
      (setf expr:generator n [function->generator generate-optimized-if])
      (setf bndg-size (@ expr:binding-aug n) (word-size))
      (true)))))))

(constrain generate-constrain
  \:r:(?(a b c) `:(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b):r r))

(function generate-constrain (n c relocs r handler)
  (sub (.. r handler)
    (let
        (expr-val-bndg (@ expr:binding-aug n))
        (body-val-bndg (@ expr:binding-aug (@ expr:constrain-expression (& expr:constrain n)))) (do
      [generate-expression (@ expr:constrain-expression (& expr:constrain n)) c relocs ..]
      [generate-bndg-bndg-move expr-val-bndg body-val-bndg (r11) c relocs ..]))))

(constrain initialize-constrain
  \:r:(?(a b c d) `:(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c):r r))

(function initialize-constrain (n offset inits ret-val buf hdl)
  (and [= (@ expr:type n) (-constrain-)] (do
    (setf expr:binding-aug (@ expr:constrain-expression (& expr:constrain n)) (@ expr:binding-aug n))
    [initialize-expressions (storage-cons (@ expr:constrain-expression (& expr:constrain n)) nil) nil offset
      0x:FFFFFFFFFFFF0830 (@ expr:depth n) inits ret-val buf hdl]
    (setf bndg-size (@ expr:binding-aug n) (word-size))
    (setf expr:generator n [function->generator generate-constrain])
    (true))))

(-- Checks if a symbol is a reference symbol that is bound to an absolute location in
  memory.)

(constrain absolute-reference-symbol? \:r:(?(a b) `:(function ((expr ,:b)) ,:a):r r))

(function absolute-reference-symbol? (n)
  (and
    [= (@ expr:type n) (-symbol-)]
    [= (@ bndg-mode (@ expr:symbol-reference (& expr:symbol n))) (reference-mode)]
    [= (@ bndg-storage (@ expr:symbol-reference (& expr:symbol n))) (absolute-storage)]))

(constrain generate-symbol
  \:r:(?(a b c) `:(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b):r r))

(function generate-symbol (n c relocs r handler)
  (sub (.. r handler)
    (let (expr-val-bndg (@ expr:binding-aug n))
        (symbol-val-bndg (@ expr:symbol-reference (& expr:symbol n))) (do
      (if [= (@ bndg-mode (@ expr:symbol-reference (& expr:symbol n))) (value-mode)]
        [generate-bndg-bndg-move expr-val-bndg symbol-val-bndg (r11) c relocs ..]
        [prepend (make-instrN(x86-lea)
          ([bndg->op expr-val-bndg relocs ..][bndg->op symbol-val-bndg relocs ..][make-reg-op(r11)..])..) c ..])))))

(constrain initialize-symbol \:r:(?(a b c d) `:(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c):r r))

(function initialize-symbol (n offset inits ret-val buf hdl)
  (and [= (@ expr:type n) (-symbol-)] (do
    (setf bndg-size (@ expr:binding-aug n) (word-size))
    (setf expr:generator n [function->generator generate-symbol])
    (values (use-storage ret-val) offset 0x:0000000000000800)
    (true))))

(constrain generate-literal
  \:r:(?(a b c) `:(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b):r r))

(function generate-literal (n c relocs r handler) (sub (.. r handler)
  (let (expr-val-bndg (@ expr:binding-aug n)) (do
    [prepend(make-instrN(x86-mov)([bndg->op expr-val-bndg relocs ..][make-imm-op #:8 (@ expr:value (& expr:literal n))..][make-reg-op (r11)..])..) c ..]))))

(constrain initialize-literal \:r:(?(a b c d) `:(function ((expr ,:a) ,:b (list initializer) (values ,:b reg-use-vec) region ,:d) ,:c):r r))

(function initialize-literal (n offset inits ret-val buf hdl)
  (and [= (@ expr:type n) (-literal-)] (do
    (setf bndg-size (@ expr:binding-aug n) (word-size))
    (setf expr:generator n [function->generator generate-literal])
    (values (use-storage ret-val) offset 0x:0000000000000800)
    (true))))

(constrain initialize-expression \:r:(?(a b c d) `:(function ((expr ,:a) ,:b (list initializer) ,:c region ,:d) (values ,:b reg-use-vec)):r r))

(function initialize-expression (n offset inits ret-val buf hdl)
  (sub (.. buf hdl) (do (or
    (fold (found? (false)) (init (%:list-iter inits)) (or found? [[initializer->function init] n offset inits ret-val ..]))
    [initialize-function n offset inits ret-val ..]
    [initialize-continuation n offset inits ret-val ..]
    [initialize-with n offset inits ret-val ..]
    [initialize-storage n offset inits ret-val ..]
    [initialize-jump n offset inits ret-val ..]
    [initialize-invoke n offset inits ret-val ..]
    [initialize-optimized-if n offset inits ret-val ..]
    [initialize-constrain n offset inits ret-val ..]
    [initialize-symbol n offset inits ret-val ..]
    [initialize-literal n offset inits ret-val ..])
    ret-val)))

(constrain generator->function
  \:r:(?(a b c) `:(function (generator)
    (function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b)):r r))

(function generator->function (x) [cast x])

(constrain function->generator
  \:r:(?(a b c) `:(function
    ((function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b)) generator):r r))

(function function->generator (x) [cast x])

(constrain make-absolute-relocation-immediate
  \:r:(?(a b c) `:(function (,:a ,:b bndg-aug !:Ref:(list reloc) region ,:c) operand):r r))

(function make-absolute-relocation-immediate (size addend bndg relocs r handler)
  (sub (.. r handler)
    (let (op [make-imm-op size #:0 ..]) (do
      [prepend [make-relocation
        (switch = size
          (#:1 (r-x86-64-8))
          (#:2 (r-x86-64-16))
          (#:4 (r-x86-64-32))
          (#:8 (r-x86-64-64))
          (~)) op bndg addend
        (function _(ctx ofst size instr-pos instr-size) ctx) ..] relocs ..]
      op))))

(constrain make-relative-relocation-immediate
  \:r:(?(a b) `:(function (,:a bndg-aug !:Ref:(list reloc) region ,:b) operand):r r))

(function make-relative-relocation-immediate (size bndg relocs r handler)
  (sub (.. r handler)
    (let (op [make-imm-op size #:0 ..]) (do
      [prepend [make-relocation
        (switch = size
          (#:1 (r-x86-64-pc8))
          (#:2 (r-x86-64-pc16))
          (#:4 (r-x86-64-pc32))
          (#:8 (r-x86-64-pc64))
          (~)) op bndg (~)
        (function _(ctx ofst size instr-pos instr-size)
          [- ofst [+ instr-pos instr-size]]) ..] relocs ..]
      op))))

(constrain make-label \:r:(?(a) `:(function (bndg-aug region ,:a) instr):r r))

(function make-label (bndg r handler)
  (sub (.. r handler)
    (let (lbl (make-instrN (label) () ..)) (do
      (setf instr-binding lbl bndg)
      lbl))))

(constrain bndg->partial-op \:r:(?(a b) `:(function (,:b bndg-aug !:Ref:(list reloc) region ,:a) operand):r r))

(function bndg->partial-op (op-size bndg relocs buf handler)
  (sub (.. buf handler)
    (if [= (@ bndg-storage bndg) (nil-storage)]
      [make-none-op ..]
      
    (if [= (@ bndg-storage bndg) (absolute-storage)]
      (let (op [make-mem-op op-size (rip) (none) #:0 #:0 #:4 ..]) (do
        [prepend [make-relocation (r-x86-64-pc32) op bndg (~)
          (function _(ctx ofst size instr-pos instr-size)
            [- ofst [+ instr-pos instr-size]]) ..] relocs ..]
        op))
    
    (if (and [= (@ bndg-storage bndg) (frame-relative-storage)] [= (@ bndg-state bndg) (defined-state)])
      [make-mem-op op-size (rbp) (none) #:0 (@ bndg-offset bndg) #:4 ..]
    
    (if [= (@ bndg-storage bndg) (register-storage)]
      [make-reg-op
        [(switch = op-size
          (#:1 reg-lower-8)
          (#:2 reg-lower-16)
          (#:4 reg-lower-32)
          (#:8 reg-lower-64)
          (~)) (@ bndg-offset bndg)] ..]
    
      (~)))))))

(constrain bndg->op \:r:(?(a) `:(function (bndg-aug !:Ref:(list reloc) region ,:a) operand):r r))

(function bndg->op (bndg relocs buf handler)
  [bndg->partial-op (@ bndg-size bndg) bndg relocs buf handler])

(constrain bndg= \:r:(?(a) `:(function (bndg-aug bndg-aug) ,:a):r r))

(function bndg= (a b)
  (and [= (@ bndg-storage a) (@ bndg-storage b)]
    [= (@ bndg-offset a) (@ bndg-offset b)]
    [= (@ bndg-size a) (@ bndg-size b)]))

(constrain generate-bndg-bndg-move
  \:r:(?(a b) `:(function (bndg-aug bndg-aug register !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b):r r))

(function generate-bndg-bndg-move (dst src tmp c relocs r handler)
  (sub (.. r handler)
    (if [bndg= dst src]
      (~)
      [prepend (make-instrN(x86-mov)([bndg->op dst relocs ..][bndg->op src relocs ..][make-reg-op tmp ..])..) c ..])))

(constrain generate-register-bndg-move
  \:r:(?(a b) `:(function (register bndg-aug !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b):r r))

(function generate-register-bndg-move (dst src c relocs r handler)
  (sub (.. r handler)
    (if (and [= (@ bndg-storage src) (register-storage)] [= dst (@ bndg-offset src)])
      (~)
      [prepend (make-instrN(x86-mov)([make-reg-op dst ..][bndg->op src relocs ..])..) c ..])))

(constrain generate-bndg-register-move
  \:r:(?(a b) `:(function (bndg-aug register !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b):r r))

(function generate-bndg-register-move (dst src c relocs r handler)
  (sub (.. r handler)
    (if (and [= (@ bndg-storage dst) (register-storage)] [= src (@ bndg-offset dst)])
      (~)
      [prepend (make-instrN(x86-mov)([bndg->op dst relocs ..][make-reg-op src ..])..) c ..])))

(constrain generate-expression
  \:r:(?(a b c) `:(function ((expr ,:c) !:Ref:(list instr) !:Ref:(list reloc) region ,:a) ,:b):r r))

(function generate-expression (n c relocs r handler)
  (sub (.. r handler)
    [[generator->function (@ expr:generator n)] n c relocs ..]))

(constrain generate-program
  \:r:(?(a b c) `:(function ((list (expr ,:c)) ,:b region ,:a)
    (values (list instr) (list reloc) (list (values string (list instr) (list reloc))))):r r))

(function generate-program (exprs outs r handler)
  (sub (.. r handler)
    (let (c (storage _ nil)) (relocs (storage _ nil)) (func-secs (storage _ nil)) (do
      (for (expr (%:list-iter exprs)) (~)
        (if [not= (@ expr:type expr) (-function-)]
          [generate-expression expr c relocs ..]
          (let (c (storage _ nil)) (relocs (storage _ nil)) (do
            [generate-expression expr c relocs ..]
            [append (values (region-storage ..) (@ bndg-name (@ expr:function-reference (& expr:function expr))) [reverse $:c ..] $:relocs) func-secs ..]))))
      (values (use-storage outs) [reverse $:c ..] $:relocs $:func-secs)))))

