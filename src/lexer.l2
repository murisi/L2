(ignore Casts to/from fragment and its various subtypes.)

  (constrain frag->list (\ r (`(function (frag) (list frag))r)))

  (function frag->list (x) [cast x])

  (constrain list->fragment (\ r (`(function ((list frag)) frag)r)))

  (function list->fragment (x) [cast x])

  (constrain token->fragment (\ r (`(function ((list tchar)) frag)r)))

  (function token->fragment (x) [cast x])

  (constrain fragment->token (\ r (`(function (frag) (list tchar))r)))

  (function fragment->token (x) [cast x])

  (constrain frag->vbl (\ r (`(function (frag) vbl)r)))

  (function frag->vbl (x) [cast x])

  (constrain vbl->frag (\ r (`(function (vbl) frag)r)))

  (function vbl->frag (x) [cast x])

(ignore Declaration of emt and emt? which is used by macros being compiled.)

  (constrain emt! (\ r (with-vars (et) (`(list ,et)r)r)))

  (storage emt! (ignore)(ignore))

  [init-nil emt!]

  (constrain emt?! (\ r (with-vars (et a) (`(function ((list ,et)) ,a)r)r)))
  
  (function emt?! (x) [= x emt!])

(ignore Declaration of or and or? which is used by type signatures being compiled.)

  (constrain or! (\ r (with-vars (et) (`(list ,et)r)r)))

  (storage or! (ignore)(ignore))

  [init-nil or!]

  (constrain or?! (\ r (with-vars (et a) (`(function ((list ,et)) ,a)r)r)))
  
  (function or?! (x) [= x or!])

(ignore Declaration of and and and? which is used by type signatures being compiled.)

  (constrain and! (\ r (with-vars (et) (`(list ,et)r)r)))

  (storage and! (ignore)(ignore))

  [init-nil and!]

  (constrain and?! (\ r (with-vars (et a) (`(function ((list ,et)) ,a)r)r)))
  
  (function and?! (x) [= x and!])

(ignore Functions to create variables and evaluate fragments containing variables.)

  (constrain vbl (\ r (with-vars (a) (`(function (region ,a) vbl)r)r)))

  (function vbl (r handler)
    (let (l [region-alloc (list-struct) r handler]) (do
      (setf car l [cast vbl])
      (setf cdr l l)
      [frag->vbl [list->fragment l]])))

  (constrain vbl? (\ r (with-vars (a) (`(function (frag) ,a)r)r)))

  (function vbl? (s) (let (t [frag->list s]) (cand [= (@ cdr t) t] [= (@ car t) [cast vbl]])))

  (constrain vbl= (\ r (with-vars (a) (`(function (vbl vbl) ,a)r)r)))

  (function vbl= (a b) [= a b])

  (constrain evaluate (\ r (`(function (frag (hash-table vbl frag)) frag)r)))

  (function evaluate (val assigns)
    (loop next (val val)
      (if [vbl? val]
        (bind-if [ht-contains [frag->vbl val] assigns next-val]
          (next-val) {next $next-val}
          val)
        val)))

  (constrain recursive-evaluate (\ r (with-vars (a) (`(function (frag (hash-table vbl frag) region ,a) frag)r)r)))

  (function recursive-evaluate (frag assigns r handler)
    (substitute (.. r handler)
      (let (d [evaluate frag assigns])
        (if (cor [vbl? d] [i/f:token? d])
          d
          [list->fragment (map (x [frag->list d]) [recursive-evaluate x assigns ..] ..)]))))

(ignore
  What follows is a struct for representing fragment characters. It is conceptually in
  union with the list-struct.)

  (function character-struct (l r) [=# #16 r])

  (ignore
    This field should be set to character-flag to indicate that a given reference is a
    character rather than a list.)
    
  (function cs-flag (l r) [property #8 #8 (\ r (`(@ (,[var r]) (,[var r]))r)) l r])

  (ignore This field contains the ASCII character represented by the this fragment character.)
    
  (function cs-character (l r) [property #0 #8 (\ r (`(@ (,[var r]) (,[var r]))r)) l r])

(ignore Functions for creating, accessing, and comparing characters.)

  (ignore Returns a reference to a fragment character representing the supplied ASCII character.)

  (function char-init (s r) (`(storage _ (char (,[@fst s])) character-flag)r))

  (ignore Returns the fragment character representing the supplied ASCII character.)

  (function tkn-char (s r) (`(constrain ($(loc (unit) (,[@fst s]) characters)) (\ r (` tchar r)))r))

  (storage null-fragment (ignore))

  (ignore
    Checks if two fragment characters are equal. a is a fragment character. b is a fragment
    character. Return value is (true) if they are equal and (false) otherwise.)

  (function i/f:char= (a b) [= (@ cs-character a) (@ cs-character b)])

(ignore Following array is used to lookup fragment character corresponding to ASCII character.)

(storage characters
  #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 #0 (char-init !) (char-init ")
  (char-init #) (char-init $) (char-init %) (char-init &) (char-init ') #0 #0 (char-init *) (char-init +) (char-init ,)
  (char-init -) (char-init .) (char-init /) (char-init 0) (char-init 1) (char-init 2) (char-init 3) (char-init 4) (char-init 5)
  (char-init 6) (char-init 7) (char-init 8) (char-init 9) (char-init :) (char-init ;) (char-init <) (char-init =) (char-init >)
  (char-init ?) (char-init @) (char-init A) (char-init B) (char-init C) (char-init D) (char-init E) (char-init F) (char-init G)
  (char-init H) (char-init I) (char-init J) (char-init K) (char-init L) (char-init M) (char-init N) (char-init O) (char-init P)
  (char-init Q) (char-init R) (char-init S) (char-init T) (char-init U) (char-init V) (char-init W) (char-init X) (char-init Y)
  (char-init Z) #0 (char-init \) #0 (char-init ^) (char-init _) (char-init `) (char-init a) (char-init b) (char-init c)
  (char-init d) (char-init e) (char-init f) (char-init g) (char-init h) (char-init i) (char-init j) (char-init k) (char-init l)
  (char-init m) (char-init n) (char-init o) (char-init p) (char-init q) (char-init r) (char-init s) (char-init t) (char-init u)
  (char-init v) (char-init w) (char-init x) (char-init y) (char-init z) #0 (char-init |) #0 (char-init ~) #0)

(ignore
  Builds a token from a given C-string. str is the C-string that the constructed token
  will be based on. r is the region in which the token will be constructed. Return value
  is the constructed token.)

(constrain build-token (\ r (with-vars (c) (`(function (string region ,c) (list tchar))r)r)))

(function build-token (str r handler)
  (let (sexprs-start (storage _ emt!))
    (loop cons-char (sexprs-end sexprs-start) (strptr str)
      (if [getb strptr]
        {cons-char [append (tkn-char [getb strptr]) sexprs-end r handler] [+ strptr #1]}
        $sexprs-start))))

(ignore
  Moves the supplied index forward to the first non-space character. l2src is a
  reference to the beginning of a buffer containing characters. l2src-sz contains
  the size in bytes of the buffer. pos is the reference to an index integer that
  will be increased. Return value is the number of remaining characters in the
  buffer.)

(function after-leading-space (l2src l2src-sz pos)
  (loop find-space
    (if (cand [< $pos l2src-sz] [isspace [getb[+ l2src $pos]]])
      (do [set+ pos #1] {find-space})
      [- l2src-sz $pos])))

(ignore
  If there is a space at the current position in the buffer, then build a token
  containing solely the sigil. Otherwise build a token of the form (<sigil>
  <token>) where token is the token starting at the current position in the
  buffer. sigil is a string. l2src is a reference to the start of a buffer
  containing characters. l2src-sz is the size of the buffer. pos is a reference
  to the current index in the buffer. r is the region into which the token
  should be put. Return value is the constructed token.)

(constrain build-sigilled-token (\ r (with-vars (a b c d e f) (`(function (,a ,b ,c ,d ,e ,f) frag)r)r)))

(function build-sigilled-token (sigil l2src l2src-sz pos r handler)
  (substitute (.. r handler)
    (if [= l2src-sz $pos]
      [token->fragment [build-token sigil ..]]
      (let (d [getb [+ l2src $pos]])
        (if (cor [isspace d] [= d (rparen)] [= d (rbrace)] [= d (rbracket)] [= d (lparen)] [= d (lbrace)] [= d (lbracket)])
          [token->fragment [build-token sigil ..]]
          [list->fragment [ccons [token->fragment [build-token sigil ..]] [build-fragment l2src l2src-sz pos ..] emt! ..]])))))

(ignore
  Builds a fragment list starting at the current position in the buffer and ending
  at the specified delimiter and then prefixes it with the given primitive.
  primitive is a string. delimiter is an ascii character. For rest of parameters,
  see above.)

(constrain build-fragment-list (\ r (with-vars (a b c d e) (`(function (string ,a ,b ,c ,d region ,e) (list frag))r)r)))

(function build-fragment-list (primitive delimeter l2src l2src-sz pos r handler)
  (substitute (.. r handler)
    (let (sexprs-start (storage _ emt!))
      (loop cons-frag (sexprs-end [append [token->fragment [build-token primitive ..]] sexprs-start ..])
        (let (rem [after-leading-space l2src l2src-sz pos])
          (if (cand rem [= [getb [+ l2src $pos]] delimeter])
            (do [set+ pos #1] $sexprs-start)
            {cons-frag [append [build-fragment l2src l2src-sz pos ..] sexprs-end ..]}))))))

(storage unexpected-char-error (ignore))

(ignore Builds a fragment starting at the current position in the buffer. For parameters, see above.)

(constrain build-fragment (\ r (with-vars (a b c d e) (`(function (,a ,b ,c ,d ,e) frag)r)r)))

(function build-fragment (l2src l2src-sz pos r handler)
  (substitute (.. r handler) (if [= l2src-sz $pos]
    {handler (storage _ unexpected-char-error #0 $pos)}
    (let (c [getb [+ l2src $pos]])
      (if (cor [isspace c] [= c (rparen)] [= c (rbrace)] [= c (rbracket)])
        {handler (storage _ unexpected-char-error c $pos)}
        (do
          [set+ pos #1]
          (switch = c
            ((lparen) [list->fragment [@cdr [build-fragment-list (" expression) (rparen) l2src l2src-sz pos ..]]])
            ((lbrace) [list->fragment [build-fragment-list (" jump) (rbrace) l2src l2src-sz pos ..]])
            ((lbracket) [list->fragment [build-fragment-list (" invoke) (rbracket) l2src l2src-sz pos ..]])
            ((char $) [build-sigilled-token (" $) l2src l2src-sz pos ..])
            ((char #) [build-sigilled-token (" #) l2src l2src-sz pos ..])
            ((char ,) [build-sigilled-token (" ,) l2src l2src-sz pos ..])
            ((char `) [build-sigilled-token (" `) l2src l2src-sz pos ..])
            
            [token->fragment
              (let (ls (storage _ emt!))
              (loop cons-char (le ls) (c c)
                (let (le [append (tkn-char c) le ..])
                (if [= $pos l2src-sz] $ls
                  (let (c [getb [+ l2src $pos]])
                  (if (cor [isspace c] (switch = c ((lparen)(rparen)(lbrace)(rbrace)(lbracket)(rbracket) (true)) (false))) $ls
                    (do [set+ pos #1] {cons-char le c})))))))])))))))

(storage character-flag (ignore))

(ignore Checks if the fragment d is a token. A token is a non-empty list of characters.)

(constrain i/f:token? (\ r (with-vars (a) (`(function (frag) ,a)r)r)))

(function i/f:token? (e)
  (let (d [fragment->token e])
    (cand (not [vbl? e]) [length d] [= (@ cs-flag[@car d]) character-flag])))

(constrain i/f:token= (\ r (with-vars (a) (`(function ((list tchar) (list tchar)) ,a)r)r)))

(function i/f:token= (a b)
  (loop check-car (a a) (b b)
    (if (cand [nil? a] [nil? b])
      (true)
    (if (cor [nil? a] [nil? b])
      (false)
    (if [= (@ cs-character [@car a]) (@ cs-character [@car b])]
      {check-car [@cdr a] [@cdr b]}
      (false))))))

(ignore
  Converts the given token into an ASCII string. d is the token that is to be converted.
  r is the region into which the string should be put. The return value is the constructed
  string.)

(constrain to-string (\ r (with-vars (a) (`(function ((list tchar) region ,a) string)r)r)))

(function to-string (d r handler)
  (let (str [region-alloc [+ [length d] #1] r handler])
    (loop put-char (d d) (i #0)
      (if [nil? d]
        (do
          [setb [+ str i] (nul)]
          str)
        (do
          [setb [+ str i] (@ cs-character [@car d])]
          {put-char [@cdr d] [+ i #1]})))))

(ignore
  Copies the given fragment into the given region. l is the fragment that is to
  be copied. r is the region into which the fragment should be copied. The return
  value is the copied fragment.)

(constrain copy-fragment (\ r (with-vars (b) (`(function (frag (hash-table vbl vbl) region ,b) frag)r)r)))

(function copy-fragment (l var-map r handler)
  (substitute (.. r handler)
    (if [vbl? l]
      (let (l [frag->vbl l])
        [vbl->frag (bind-if [ht-contains l var-map new-l]
          (new-l) $new-l
          (let (new-l [vbl ..]) (do [ht-put l new-l var-map ..] new-l)))])
    (if [i/f:token? l]
      [token->fragment (map (s [fragment->token l]) (tkn-char (@ cs-character s)) ..)]
      [list->fragment (map (s [frag->list l]) [copy-fragment s var-map ..] ..)]))))

(ignore Checks whether two fragments are equal modulo variable identity.)

(constrain fragment= (\ r (with-vars (a b) (`(function (frag frag (hash-table vbl vbl) region ,a) ,b)r)r)))

(function fragment= (frag1 frag2 var-map r handler)
  (substitute (.. r handler)
    (if (cand [vbl? frag1] [vbl? frag2])
      (let (vbl1 [frag->vbl frag1]) (vbl2 [frag->vbl frag2])
        (bind-if [ht-contains vbl1 var-map val]
          (val) [= $val vbl2]
          [ht-put vbl1 vbl2 var-map ..]))
    (if (cor [vbl? frag1] [vbl? frag2])
      (false)
    (if (cand [i/f:token? frag1] [i/f:token? frag2])
      [i/f:token= [fragment->token frag1] [fragment->token frag2]]
    (if (cor [i/f:token? frag1] [i/f:token? frag2])
      (false)
    (loop elt= (l1 [frag->list frag1]) (l2 [frag->list frag2])
      (if (cand [nil? l1] [nil? l2]) (true)
      (if (cor [nil? l1] [nil? l2]) (false)
      (if [fragment= [@car l1] [@car l2] var-map ..]
        {elt= [@cdr l1] [@cdr l2]}
        (false)))))))))))

(ignore Prints the given fragment out to standard output. d is the fragment that is to be printed.)

(constrain print-fragment (\ r (with-vars (b) (`(function (frag ,b) ())r)r)))

(function print-fragment (d hdl)
  (if [vbl? d]
    (do
      [print-char (stdout) (char !) hdl]
      [print-uint (stdout) [rem d #8192] hdl])
  (if [i/f:token? d]
    (foreach (t [fragment->token d]) [print-char (stdout) (@ cs-character t) hdl])
    (do
      [print-char (stdout) (lparen) hdl]
      (foreach (fl [frag->list d]) (do
        [print-fragment fl hdl]
        [print-str (stdout) ("(space)) hdl]))
      [print-char (stdout) (rparen) hdl]))))

